(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const a of i)if(a.type==="childList")for(const s of a.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&n(s)}).observe(document,{childList:!0,subtree:!0});function r(i){const a={};return i.integrity&&(a.integrity=i.integrity),i.referrerPolicy&&(a.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?a.credentials="include":i.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function n(i){if(i.ep)return;i.ep=!0;const a=r(i);fetch(i.href,a)}})();/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */function m(t){if(!t)throw new Error("Assertion failed.")}const Xr=t=>{const e=(t%360+360)%360;if(e===0||e===90||e===180||e===270)return e;throw new Error(`Invalid rotation ${t}.`)},$=t=>t&&t[t.length-1],Tt=t=>t>=0&&t<2**32;class j{constructor(e){this.bytes=e,this.pos=0}seekToByte(e){this.pos=8*e}readBit(){const e=Math.floor(this.pos/8),r=this.bytes[e]??0,n=7-(this.pos&7),i=(r&1<<n)>>n;return this.pos++,i}readBits(e){if(e===1)return this.readBit();let r=0;for(let n=0;n<e;n++)r<<=1,r|=this.readBit();return r}writeBits(e,r){const n=this.pos+e;for(let i=this.pos;i<n;i++){const a=Math.floor(i/8);let s=this.bytes[a];const o=7-(i&7);s&=~(1<<o),s|=(r&1<<n-i-1)>>n-i-1<<o,this.bytes[a]=s}this.pos=n}readAlignedByte(){if(this.pos%8!==0)throw new Error("Bitstream is not byte-aligned.");const e=this.pos/8,r=this.bytes[e]??0;return this.pos+=8,r}skipBits(e){this.pos+=e}getBitsLeft(){return this.bytes.length*8-this.pos}clone(){const e=new j(this.bytes);return e.pos=this.pos,e}}const B=t=>{let e=0;for(;t.readBits(1)===0&&e<32;)e++;if(e>=32)throw new Error("Invalid exponential-Golomb code.");return(1<<e)-1+t.readBits(e)},Ft=t=>{const e=B(t);return(e&1)===0?-(e>>1):e+1>>1},xe=t=>t.constructor===Uint8Array?t:t instanceof ArrayBuffer?new Uint8Array(t):new Uint8Array(t.buffer,t.byteOffset,t.byteLength),te=t=>t.constructor===DataView?t:t instanceof ArrayBuffer?new DataView(t):new DataView(t.buffer,t.byteOffset,t.byteLength),he=new TextDecoder,ye=new TextEncoder,Yr=t=>Object.fromEntries(Object.entries(t).map(([e,r])=>[r,e])),Vt={bt709:1,bt470bg:5,smpte170m:6,bt2020:9,smpte432:12},Zn=Yr(Vt),Ut={bt709:1,smpte170m:6,linear:8,"iec61966-2-1":13,pg:16,hlg:18},Jn=Yr(Ut),Wt={rgb:0,bt709:1,bt470bg:5,smpte170m:6,"bt2020-ncl":9},ei=Yr(Wt),os=t=>!!t&&!!t.primaries&&!!t.transfer&&!!t.matrix&&t.fullRange!==void 0,cr=t=>t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer||ArrayBuffer.isView(t);class je{constructor(){this.currentPromise=Promise.resolve()}async acquire(){let e;const r=new Promise(i=>{e=i}),n=this.currentPromise;return this.currentPromise=r,await n,e}}const pn=t=>[...t].map(e=>e.toString(16).padStart(2,"0")).join(""),gn=t=>(t=t>>1&1431655765|(t&1431655765)<<1,t=t>>2&858993459|(t&858993459)<<2,t=t>>4&252645135|(t&252645135)<<4,t=t>>8&16711935|(t&16711935)<<8,t=t>>16&65535|(t&65535)<<16,t>>>0),K=(t,e,r)=>{let n=0,i=t.length-1,a=-1;for(;n<=i;){const s=n+i>>1,o=r(t[s]);o===e?(a=s,i=s-1):o<e?n=s+1:i=s-1}return a},L=(t,e,r)=>{let n=0,i=t.length-1,a=-1;for(;n<=i;){const s=n+(i-n+1)/2|0;r(t[s])<=e?(a=s,n=s+1):i=s-1}return a},He=(t,e,r)=>{const n=L(t,r(e),r);t.splice(n+1,0,e)},ee=()=>{let t,e;return{promise:new Promise((n,i)=>{t=n,e=i}),resolve:t,reject:e}},ti=(t,e)=>{for(let r=t.length-1;r>=0;r--)if(e(t[r]))return t[r]},ri=(t,e)=>{for(let r=t.length-1;r>=0;r--)if(e(t[r]))return r;return-1},cs=async function*(t){Symbol.iterator in t?yield*t[Symbol.iterator]():yield*t[Symbol.asyncIterator]()},ls=t=>{if(!(Symbol.iterator in t)&&!(Symbol.asyncIterator in t))throw new TypeError("Argument must be an iterable or async iterable.")},$e=t=>{throw new Error(`Unexpected value: ${t}`)},lr=(t,e,r)=>{const n=t.getUint8(e),i=t.getUint8(e+1),a=t.getUint8(e+2);return r?n|i<<8|a<<16:n<<16|i<<8|a},us=(t,e,r)=>lr(t,e,r)<<8>>8,ni=(t,e,r,n)=>{r=r>>>0,r=r&16777215,n?(t.setUint8(e,r&255),t.setUint8(e+1,r>>>8&255),t.setUint8(e+2,r>>>16&255)):(t.setUint8(e,r>>>16&255),t.setUint8(e+1,r>>>8&255),t.setUint8(e+2,r&255))},ds=(t,e,r,n)=>{r=G(r,-8388608,8388607),r<0&&(r=r+16777216&16777215),ni(t,e,r,n)},kn=(t,e)=>({async next(){const r=await t.next();return r.done?{value:void 0,done:!0}:{value:e(r.value),done:!1}},return(){return t.return()},throw(r){return t.throw(r)},[Symbol.asyncIterator](){return this}}),G=(t,e,r)=>Math.max(e,Math.min(r,t)),ue="und",Jt=(t,e)=>{const r=10**e;return Math.round(t*r)/r},hs=(t,e)=>Math.round(t/e)*e,fs=t=>{let e=0;for(;t;)e++,t>>=1;return e},ms=/^[a-z]{3}$/,Dt=t=>ms.test(t),Ue=1e6*(1+Number.EPSILON),bn=(t,e)=>{const r={...t,...e};if(t.headers||e.headers){const n=t.headers?wn(t.headers):{},i=e.headers?wn(e.headers):{},a={...n};Object.entries(i).forEach(([s,o])=>{const c=Object.keys(a).find(l=>l.toLowerCase()===s.toLowerCase());c&&delete a[c],a[s]=o}),r.headers=a}return r},wn=t=>{if(t instanceof Headers){const e={};return t.forEach((r,n)=>{e[n]=r}),e}if(Array.isArray(t)){const e={};return t.forEach(([r,n])=>{e[r]=n}),e}return t},Tn=async(t,e,r,n)=>{let i=0;for(;;)try{return await t(e,r)}catch(a){i++;const s=n(i,a);if(s===null)throw a;if(console.error("Retrying failed fetch. Error:",a),!Number.isFinite(s)||s<0)throw new TypeError("Retry delay must be a non-negative finite number.");s>0&&await new Promise(o=>setTimeout(o,1e3*s))}},ps=(t,e)=>{const r=t<0?-1:1;t=Math.abs(t);let n=0,i=1,a=1,s=0,o=t;for(;;){const c=Math.floor(o),l=c*a+n,u=c*s+i;if(u>e)return{numerator:r*a,denominator:s};if(n=a,i=s,a=l,s=u,o=1/(o-c),!isFinite(o))break}return{numerator:r*a,denominator:s}};class ur{constructor(){this.currentPromise=Promise.resolve()}call(e){return this.currentPromise=this.currentPromise.then(e)}}let hr=null;const fr=()=>{if(hr!==null)return hr;const t=!!(typeof navigator<"u"&&navigator.vendor?.match(/apple/i)&&!navigator.userAgent?.match(/crios/i)&&!navigator.userAgent?.match(/fxios/i)&&!navigator.userAgent?.match(/Opera|OPT\//));return hr=t,t};let mr=null;const Mt=()=>mr!==null?mr:mr=typeof navigator<"u"&&navigator.userAgent?.includes("Firefox"),lt=(t,e)=>t!==-1?t:e,Fr=(t,e,r,n)=>t<=n&&r<=e,ii=function*(t){for(const e in t){const r=t[e];r!==void 0&&(yield{key:e,value:r})}},gs=t=>{const e=atob(t),r=new Uint8Array(e.length);for(let n=0;n<e.length;n++)r[n]=e.charCodeAt(n);return r},si=()=>{Symbol.dispose??=Symbol("Symbol.dispose")};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class gt{constructor(e,r){if(this.data=e,this.mimeType=r,!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if(typeof r!="string")throw new TypeError("mimeType must be a string.")}}class ai{constructor(e,r,n,i){if(this.data=e,this.mimeType=r,this.name=n,this.description=i,!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if(r!==void 0&&typeof r!="string")throw new TypeError("mimeType, when provided, must be a string.");if(n!==void 0&&typeof n!="string")throw new TypeError("name, when provided, must be a string.");if(i!==void 0&&typeof i!="string")throw new TypeError("description, when provided, must be a string.")}}const Ar=t=>{if(!t||typeof t!="object")throw new TypeError("tags must be an object.");if(t.title!==void 0&&typeof t.title!="string")throw new TypeError("tags.title, when provided, must be a string.");if(t.description!==void 0&&typeof t.description!="string")throw new TypeError("tags.description, when provided, must be a string.");if(t.artist!==void 0&&typeof t.artist!="string")throw new TypeError("tags.artist, when provided, must be a string.");if(t.album!==void 0&&typeof t.album!="string")throw new TypeError("tags.album, when provided, must be a string.");if(t.albumArtist!==void 0&&typeof t.albumArtist!="string")throw new TypeError("tags.albumArtist, when provided, must be a string.");if(t.trackNumber!==void 0&&(!Number.isInteger(t.trackNumber)||t.trackNumber<=0))throw new TypeError("tags.trackNumber, when provided, must be a positive integer.");if(t.tracksTotal!==void 0&&(!Number.isInteger(t.tracksTotal)||t.tracksTotal<=0))throw new TypeError("tags.tracksTotal, when provided, must be a positive integer.");if(t.discNumber!==void 0&&(!Number.isInteger(t.discNumber)||t.discNumber<=0))throw new TypeError("tags.discNumber, when provided, must be a positive integer.");if(t.discsTotal!==void 0&&(!Number.isInteger(t.discsTotal)||t.discsTotal<=0))throw new TypeError("tags.discsTotal, when provided, must be a positive integer.");if(t.genre!==void 0&&typeof t.genre!="string")throw new TypeError("tags.genre, when provided, must be a string.");if(t.date!==void 0&&(!(t.date instanceof Date)||Number.isNaN(t.date.getTime())))throw new TypeError("tags.date, when provided, must be a valid Date.");if(t.lyrics!==void 0&&typeof t.lyrics!="string")throw new TypeError("tags.lyrics, when provided, must be a string.");if(t.images!==void 0){if(!Array.isArray(t.images))throw new TypeError("tags.images, when provided, must be an array.");for(const e of t.images){if(!e||typeof e!="object")throw new TypeError("Each image in tags.images must be an object.");if(!(e.data instanceof Uint8Array))throw new TypeError("Each image.data must be a Uint8Array.");if(typeof e.mimeType!="string")throw new TypeError("Each image.mimeType must be a string.");if(!["coverFront","coverBack","unknown"].includes(e.kind))throw new TypeError("Each image.kind must be 'coverFront', 'coverBack', or 'unknown'.")}}if(t.comment!==void 0&&typeof t.comment!="string")throw new TypeError("tags.comment, when provided, must be a string.");if(t.raw!==void 0){if(!t.raw||typeof t.raw!="object")throw new TypeError("tags.raw, when provided, must be an object.");for(const e of Object.values(t.raw))if(e!==null&&typeof e!="string"&&!(e instanceof Uint8Array)&&!(e instanceof gt)&&!(e instanceof ai))throw new TypeError("Each value in tags.raw must be a string, Uint8Array, RichImageData, AttachedFile, or null.")}};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Ce=["avc","hevc","vp9","av1","vp8"],ne=["pcm-s16","pcm-s16be","pcm-s24","pcm-s24be","pcm-s32","pcm-s32be","pcm-f32","pcm-f32be","pcm-f64","pcm-f64be","pcm-u8","pcm-s8","ulaw","alaw"],At=["aac","opus","mp3","vorbis","flac"],Pe=[...At,...ne],er=["webvtt"],yn=[{maxMacroblocks:99,maxBitrate:64e3,level:10},{maxMacroblocks:396,maxBitrate:192e3,level:11},{maxMacroblocks:396,maxBitrate:384e3,level:12},{maxMacroblocks:396,maxBitrate:768e3,level:13},{maxMacroblocks:396,maxBitrate:2e6,level:20},{maxMacroblocks:792,maxBitrate:4e6,level:21},{maxMacroblocks:1620,maxBitrate:4e6,level:22},{maxMacroblocks:1620,maxBitrate:1e7,level:30},{maxMacroblocks:3600,maxBitrate:14e6,level:31},{maxMacroblocks:5120,maxBitrate:2e7,level:32},{maxMacroblocks:8192,maxBitrate:2e7,level:40},{maxMacroblocks:8192,maxBitrate:5e7,level:41},{maxMacroblocks:8704,maxBitrate:5e7,level:42},{maxMacroblocks:22080,maxBitrate:135e6,level:50},{maxMacroblocks:36864,maxBitrate:24e7,level:51},{maxMacroblocks:36864,maxBitrate:24e7,level:52},{maxMacroblocks:139264,maxBitrate:24e7,level:60},{maxMacroblocks:139264,maxBitrate:48e7,level:61},{maxMacroblocks:139264,maxBitrate:8e8,level:62}],Sn=[{maxPictureSize:36864,maxBitrate:128e3,tier:"L",level:30},{maxPictureSize:122880,maxBitrate:15e5,tier:"L",level:60},{maxPictureSize:245760,maxBitrate:3e6,tier:"L",level:63},{maxPictureSize:552960,maxBitrate:6e6,tier:"L",level:90},{maxPictureSize:983040,maxBitrate:1e7,tier:"L",level:93},{maxPictureSize:2228224,maxBitrate:12e6,tier:"L",level:120},{maxPictureSize:2228224,maxBitrate:3e7,tier:"H",level:120},{maxPictureSize:2228224,maxBitrate:2e7,tier:"L",level:123},{maxPictureSize:2228224,maxBitrate:5e7,tier:"H",level:123},{maxPictureSize:8912896,maxBitrate:25e6,tier:"L",level:150},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:150},{maxPictureSize:8912896,maxBitrate:4e7,tier:"L",level:153},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:153},{maxPictureSize:8912896,maxBitrate:6e7,tier:"L",level:156},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:156},{maxPictureSize:35651584,maxBitrate:6e7,tier:"L",level:180},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:180},{maxPictureSize:35651584,maxBitrate:12e7,tier:"L",level:183},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:183},{maxPictureSize:35651584,maxBitrate:24e7,tier:"L",level:186},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:186}],We=[{maxPictureSize:36864,maxBitrate:2e5,level:10},{maxPictureSize:73728,maxBitrate:8e5,level:11},{maxPictureSize:122880,maxBitrate:18e5,level:20},{maxPictureSize:245760,maxBitrate:36e5,level:21},{maxPictureSize:552960,maxBitrate:72e5,level:30},{maxPictureSize:983040,maxBitrate:12e6,level:31},{maxPictureSize:2228224,maxBitrate:18e6,level:40},{maxPictureSize:2228224,maxBitrate:3e7,level:41},{maxPictureSize:8912896,maxBitrate:6e7,level:50},{maxPictureSize:8912896,maxBitrate:12e7,level:51},{maxPictureSize:8912896,maxBitrate:18e7,level:52},{maxPictureSize:35651584,maxBitrate:18e7,level:60},{maxPictureSize:35651584,maxBitrate:24e7,level:61},{maxPictureSize:35651584,maxBitrate:48e7,level:62}],xn=[{maxPictureSize:147456,maxBitrate:15e5,tier:"M",level:0},{maxPictureSize:278784,maxBitrate:3e6,tier:"M",level:1},{maxPictureSize:665856,maxBitrate:6e6,tier:"M",level:4},{maxPictureSize:1065024,maxBitrate:1e7,tier:"M",level:5},{maxPictureSize:2359296,maxBitrate:12e6,tier:"M",level:8},{maxPictureSize:2359296,maxBitrate:3e7,tier:"H",level:8},{maxPictureSize:2359296,maxBitrate:2e7,tier:"M",level:9},{maxPictureSize:2359296,maxBitrate:5e7,tier:"H",level:9},{maxPictureSize:8912896,maxBitrate:3e7,tier:"M",level:12},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:12},{maxPictureSize:8912896,maxBitrate:4e7,tier:"M",level:13},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:13},{maxPictureSize:8912896,maxBitrate:6e7,tier:"M",level:14},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:14},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:15},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:15},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:16},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:16},{maxPictureSize:35651584,maxBitrate:1e8,tier:"M",level:17},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:17},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:18},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:18},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:19},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:19}],Cn=".01.01.01.01.00",Pn=".0.110.01.01.01.0",ks=(t,e,r,n)=>{if(t==="avc"){const a=Math.ceil(e/16)*Math.ceil(r/16),s=yn.find(d=>a<=d.maxMacroblocks&&n<=d.maxBitrate)??$(yn),o=s?s.level:0,c="64".padStart(2,"0"),l="00",u=o.toString(16).padStart(2,"0");return`avc1.${c}${l}${u}`}else if(t==="hevc"){const i="",s="6",o=e*r,c=Sn.find(u=>o<=u.maxPictureSize&&n<=u.maxBitrate)??$(Sn);return`hev1.${i}1.${s}.${c.tier}${c.level}.B0`}else{if(t==="vp8")return"vp8";if(t==="vp9"){const i="00",a=e*r,s=We.find(c=>a<=c.maxPictureSize&&n<=c.maxBitrate)??$(We);return`vp09.${i}.${s.level.toString().padStart(2,"0")}.08`}else if(t==="av1"){const a=e*r,s=xn.find(l=>a<=l.maxPictureSize&&n<=l.maxBitrate)??$(xn);return`av01.0.${s.level.toString().padStart(2,"0")}${s.tier}.08`}}throw new TypeError(`Unhandled codec '${t}'.`)},bs=t=>{const e=t.split("."),i=(1<<7)+1,a=Number(e[1]),s=e[2],o=Number(s.slice(0,-1)),c=(a<<5)+o,l=s.slice(-1)==="H"?1:0,d=Number(e[3])===8?0:1,h=0,f=e[4]?Number(e[4]):0,p=e[5]?Number(e[5][0]):1,g=e[5]?Number(e[5][1]):1,b=e[5]?Number(e[5][2]):0,w=(l<<7)+(d<<6)+(h<<5)+(f<<4)+(p<<3)+(g<<2)+b;return[i,c,w,0]},oi=t=>{const{codec:e,codecDescription:r,colorSpace:n,avcCodecInfo:i,hevcCodecInfo:a,vp9CodecInfo:s,av1CodecInfo:o}=t;if(e==="avc"){if(i){const c=new Uint8Array([i.avcProfileIndication,i.profileCompatibility,i.avcLevelIndication]);return`avc1.${pn(c)}`}if(!r||r.byteLength<4)throw new TypeError("AVC decoder description is not provided or is not at least 4 bytes long.");return`avc1.${pn(r.subarray(1,4))}`}else if(e==="hevc"){let c,l,u,d,h,f;if(a)c=a.generalProfileSpace,l=a.generalProfileIdc,u=gn(a.generalProfileCompatibilityFlags),d=a.generalTierFlag,h=a.generalLevelIdc,f=[...a.generalConstraintIndicatorFlags];else{if(!r||r.byteLength<23)throw new TypeError("HEVC decoder description is not provided or is not at least 23 bytes long.");const g=te(r),b=g.getUint8(1);c=b>>6&3,l=b&31,u=gn(g.getUint32(2)),d=b>>5&1,h=g.getUint8(12),f=[];for(let w=0;w<6;w++)f.push(g.getUint8(6+w))}let p="hev1.";for(p+=["","A","B","C"][c]+l,p+=".",p+=u.toString(16).toUpperCase(),p+=".",p+=d===0?"L":"H",p+=h;f.length>0&&f[f.length-1]===0;)f.pop();return f.length>0&&(p+=".",p+=f.map(g=>g.toString(16).toUpperCase()).join(".")),p}else{if(e==="vp8")return"vp8";if(e==="vp9"){if(!s){const w=t.width*t.height;let k=$(We).level;for(const T of We)if(w<=T.maxPictureSize){k=T.level;break}return`vp09.00.${k.toString().padStart(2,"0")}.08`}const c=s.profile.toString().padStart(2,"0"),l=s.level.toString().padStart(2,"0"),u=s.bitDepth.toString().padStart(2,"0"),d=s.chromaSubsampling.toString().padStart(2,"0"),h=s.colourPrimaries.toString().padStart(2,"0"),f=s.transferCharacteristics.toString().padStart(2,"0"),p=s.matrixCoefficients.toString().padStart(2,"0"),g=s.videoFullRangeFlag.toString().padStart(2,"0");let b=`vp09.${c}.${l}.${u}.${d}`;return b+=`.${h}.${f}.${p}.${g}`,b.endsWith(Cn)&&(b=b.slice(0,-Cn.length)),b}else if(e==="av1"){if(!o){const T=t.width*t.height;let y=$(We).level;for(const x of We)if(T<=x.maxPictureSize){y=x.level;break}return`av01.0.${y.toString().padStart(2,"0")}M.08`}const c=o.profile,l=o.level.toString().padStart(2,"0"),u=o.tier?"H":"M",d=o.bitDepth.toString().padStart(2,"0"),h=o.monochrome?"1":"0",f=100*o.chromaSubsamplingX+10*o.chromaSubsamplingY+1*(o.chromaSubsamplingX&&o.chromaSubsamplingY?o.chromaSamplePosition:0),p=n?.primaries?Vt[n.primaries]:1,g=n?.transfer?Ut[n.transfer]:1,b=n?.matrix?Wt[n.matrix]:1,w=n?.fullRange?1:0;let k=`av01.${c}.${l}${u}.${d}`;return k+=`.${h}.${f.toString().padStart(3,"0")}`,k+=`.${p.toString().padStart(2,"0")}`,k+=`.${g.toString().padStart(2,"0")}`,k+=`.${b.toString().padStart(2,"0")}`,k+=`.${w}`,k.endsWith(Pn)&&(k=k.slice(0,-Pn.length)),k}}throw new TypeError(`Unhandled codec '${e}'.`)},ws=(t,e,r)=>{if(t==="aac")return e>=2&&r<=24e3?"mp4a.40.29":r<=24e3?"mp4a.40.5":"mp4a.40.2";if(t==="mp3")return"mp3";if(t==="opus")return"opus";if(t==="vorbis")return"vorbis";if(t==="flac")return"flac";if(ne.includes(t))return t;throw new TypeError(`Unhandled codec '${t}'.`)},ci=t=>{const{codec:e,codecDescription:r,aacCodecInfo:n}=t;if(e==="aac"){if(!n)throw new TypeError("AAC codec info must be provided.");return n.isMpeg2?"mp4a.67":`mp4a.40.${ui(r).objectType}`}else{if(e==="mp3")return"mp3";if(e==="opus")return"opus";if(e==="vorbis")return"vorbis";if(e==="flac")return"flac";if(e&&ne.includes(e))return e}throw new TypeError(`Unhandled codec '${e}'.`)},tr=[96e3,88200,64e3,48e3,44100,32e3,24e3,22050,16e3,12e3,11025,8e3,7350],li=[-1,1,2,3,4,5,6,8],ui=t=>{if(!t||t.byteLength<2)throw new TypeError("AAC description must be at least 2 bytes long.");const e=new j(t);let r=e.readBits(5);r===31&&(r=32+e.readBits(6));const n=e.readBits(4);let i=null;n===15?i=e.readBits(24):n<tr.length&&(i=tr[n]);const a=e.readBits(4);let s=null;return a>=1&&a<=7&&(s=li[a]),{objectType:r,frequencyIndex:n,sampleRate:i,channelConfiguration:a,numberOfChannels:s}},dr=48e3,di=/^pcm-([usf])(\d+)+(be)?$/,Ke=t=>{if(m(ne.includes(t)),t==="ulaw")return{dataType:"ulaw",sampleSize:1,littleEndian:!0,silentValue:255};if(t==="alaw")return{dataType:"alaw",sampleSize:1,littleEndian:!0,silentValue:213};const e=di.exec(t);m(e);let r;e[1]==="u"?r="unsigned":e[1]==="s"?r="signed":r="float";const n=Number(e[2])/8,i=e[3]!=="be",a=t==="pcm-u8"?2**7:0;return{dataType:r,sampleSize:n,littleEndian:i,silentValue:a}},hi=t=>t.startsWith("avc1")||t.startsWith("avc3")?"avc":t.startsWith("hev1")||t.startsWith("hvc1")?"hevc":t==="vp8"?"vp8":t.startsWith("vp09")?"vp9":t.startsWith("av01")?"av1":t.startsWith("mp4a.40")||t==="mp4a.67"?"aac":t==="mp3"||t==="mp4a.69"||t==="mp4a.6B"||t==="mp4a.6b"?"mp3":t==="opus"?"opus":t==="vorbis"?"vorbis":t==="flac"?"flac":t==="ulaw"?"ulaw":t==="alaw"?"alaw":di.test(t)?t:t==="webvtt"?"webvtt":null,Ts=t=>t==="avc"?{avc:{format:"avc"}}:t==="hevc"?{hevc:{format:"hevc"}}:{},ys=t=>t==="aac"?{aac:{format:"aac"}}:t==="opus"?{opus:{format:"opus"}}:{},Ss=["avc1","avc3","hev1","hvc1","vp8","vp09","av01"],xs=/^(avc1|avc3)\.[0-9a-fA-F]{6}$/,Cs=/^(hev1|hvc1)\.(?:[ABC]?\d+)\.[0-9a-fA-F]{1,8}\.[LH]\d+(?:\.[0-9a-fA-F]{1,2}){0,6}$/,Ps=/^vp09(?:\.\d{2}){3}(?:(?:\.\d{2}){5})?$/,vs=/^av01\.\d\.\d{2}[MH]\.\d{2}(?:\.\d\.\d{3}\.\d{2}\.\d{2}\.\d{2}\.\d)?$/,_s=t=>{if(!t)throw new TypeError("Video chunk metadata must be provided.");if(typeof t!="object")throw new TypeError("Video chunk metadata must be an object.");if(!t.decoderConfig)throw new TypeError("Video chunk metadata must include a decoder configuration.");if(typeof t.decoderConfig!="object")throw new TypeError("Video chunk metadata decoder configuration must be an object.");if(typeof t.decoderConfig.codec!="string")throw new TypeError("Video chunk metadata decoder configuration must specify a codec string.");if(!Ss.some(e=>t.decoderConfig.codec.startsWith(e)))throw new TypeError("Video chunk metadata decoder configuration codec string must be a valid video codec string as specified in the WebCodecs Codec Registry.");if(!Number.isInteger(t.decoderConfig.codedWidth)||t.decoderConfig.codedWidth<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedWidth (positive integer).");if(!Number.isInteger(t.decoderConfig.codedHeight)||t.decoderConfig.codedHeight<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedHeight (positive integer).");if(t.decoderConfig.description!==void 0&&!cr(t.decoderConfig.description))throw new TypeError("Video chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(t.decoderConfig.colorSpace!==void 0){const{colorSpace:e}=t.decoderConfig;if(typeof e!="object")throw new TypeError("Video chunk metadata decoder configuration colorSpace, when provided, must be an object.");const r=Object.keys(Vt);if(e.primaries!=null&&!r.includes(e.primaries))throw new TypeError(`Video chunk metadata decoder configuration colorSpace primaries, when defined, must be one of ${r.join(", ")}.`);const n=Object.keys(Ut);if(e.transfer!=null&&!n.includes(e.transfer))throw new TypeError(`Video chunk metadata decoder configuration colorSpace transfer, when defined, must be one of ${n.join(", ")}.`);const i=Object.keys(Wt);if(e.matrix!=null&&!i.includes(e.matrix))throw new TypeError(`Video chunk metadata decoder configuration colorSpace matrix, when defined, must be one of ${i.join(", ")}.`);if(e.fullRange!=null&&typeof e.fullRange!="boolean")throw new TypeError("Video chunk metadata decoder configuration colorSpace fullRange, when defined, must be a boolean.")}if(t.decoderConfig.codec.startsWith("avc1")||t.decoderConfig.codec.startsWith("avc3")){if(!xs.test(t.decoderConfig.codec))throw new TypeError("Video chunk metadata decoder configuration codec string for AVC must be a valid AVC codec string as specified in Section 3.4 of RFC 6381.")}else if(t.decoderConfig.codec.startsWith("hev1")||t.decoderConfig.codec.startsWith("hvc1")){if(!Cs.test(t.decoderConfig.codec))throw new TypeError("Video chunk metadata decoder configuration codec string for HEVC must be a valid HEVC codec string as specified in Section E.3 of ISO 14496-15.")}else if(t.decoderConfig.codec.startsWith("vp8")){if(t.decoderConfig.codec!=="vp8")throw new TypeError('Video chunk metadata decoder configuration codec string for VP8 must be "vp8".')}else if(t.decoderConfig.codec.startsWith("vp09")){if(!Ps.test(t.decoderConfig.codec))throw new TypeError('Video chunk metadata decoder configuration codec string for VP9 must be a valid VP9 codec string as specified in Section "Codecs Parameter String" of https://www.webmproject.org/vp9/mp4/.')}else if(t.decoderConfig.codec.startsWith("av01")&&!vs.test(t.decoderConfig.codec))throw new TypeError('Video chunk metadata decoder configuration codec string for AV1 must be a valid AV1 codec string as specified in Section "Codecs Parameter String" of https://aomediacodec.github.io/av1-isobmff/.')},Es=["mp4a","mp3","opus","vorbis","flac","ulaw","alaw","pcm"],Is=t=>{if(!t)throw new TypeError("Audio chunk metadata must be provided.");if(typeof t!="object")throw new TypeError("Audio chunk metadata must be an object.");if(!t.decoderConfig)throw new TypeError("Audio chunk metadata must include a decoder configuration.");if(typeof t.decoderConfig!="object")throw new TypeError("Audio chunk metadata decoder configuration must be an object.");if(typeof t.decoderConfig.codec!="string")throw new TypeError("Audio chunk metadata decoder configuration must specify a codec string.");if(!Es.some(e=>t.decoderConfig.codec.startsWith(e)))throw new TypeError("Audio chunk metadata decoder configuration codec string must be a valid audio codec string as specified in the WebCodecs Codec Registry.");if(!Number.isInteger(t.decoderConfig.sampleRate)||t.decoderConfig.sampleRate<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid sampleRate (positive integer).");if(!Number.isInteger(t.decoderConfig.numberOfChannels)||t.decoderConfig.numberOfChannels<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid numberOfChannels (positive integer).");if(t.decoderConfig.description!==void 0&&!cr(t.decoderConfig.description))throw new TypeError("Audio chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(t.decoderConfig.codec.startsWith("mp4a")&&t.decoderConfig.codec!=="mp4a.69"&&t.decoderConfig.codec!=="mp4a.6B"&&t.decoderConfig.codec!=="mp4a.6b"){if(!["mp4a.40.2","mp4a.40.02","mp4a.40.5","mp4a.40.05","mp4a.40.29","mp4a.67"].includes(t.decoderConfig.codec))throw new TypeError("Audio chunk metadata decoder configuration codec string for AAC must be a valid AAC codec string as specified in https://www.w3.org/TR/webcodecs-aac-codec-registration/.");if(!t.decoderConfig.description)throw new TypeError("Audio chunk metadata decoder configuration for AAC must include a description, which is expected to be an AudioSpecificConfig as specified in ISO 14496-3.")}else if(t.decoderConfig.codec.startsWith("mp3")||t.decoderConfig.codec.startsWith("mp4a")){if(t.decoderConfig.codec!=="mp3"&&t.decoderConfig.codec!=="mp4a.69"&&t.decoderConfig.codec!=="mp4a.6B"&&t.decoderConfig.codec!=="mp4a.6b")throw new TypeError('Audio chunk metadata decoder configuration codec string for MP3 must be "mp3", "mp4a.69" or "mp4a.6B".')}else if(t.decoderConfig.codec.startsWith("opus")){if(t.decoderConfig.codec!=="opus")throw new TypeError('Audio chunk metadata decoder configuration codec string for Opus must be "opus".');if(t.decoderConfig.description&&t.decoderConfig.description.byteLength<18)throw new TypeError("Audio chunk metadata decoder configuration description, when specified, is expected to be an Identification Header as specified in Section 5.1 of RFC 7845.")}else if(t.decoderConfig.codec.startsWith("vorbis")){if(t.decoderConfig.codec!=="vorbis")throw new TypeError('Audio chunk metadata decoder configuration codec string for Vorbis must be "vorbis".');if(!t.decoderConfig.description)throw new TypeError("Audio chunk metadata decoder configuration for Vorbis must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-vorbis-codec-registration/.")}else if(t.decoderConfig.codec.startsWith("flac")){if(t.decoderConfig.codec!=="flac")throw new TypeError('Audio chunk metadata decoder configuration codec string for FLAC must be "flac".');if(!t.decoderConfig.description||t.decoderConfig.description.byteLength<42)throw new TypeError("Audio chunk metadata decoder configuration for FLAC must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-flac-codec-registration/.")}else if((t.decoderConfig.codec.startsWith("pcm")||t.decoderConfig.codec.startsWith("ulaw")||t.decoderConfig.codec.startsWith("alaw"))&&!ne.includes(t.decoderConfig.codec))throw new TypeError(`Audio chunk metadata decoder configuration codec string for PCM must be one of the supported PCM codecs (${ne.join(", ")}).`)},Fs=t=>{if(!t)throw new TypeError("Subtitle metadata must be provided.");if(typeof t!="object")throw new TypeError("Subtitle metadata must be an object.");if(!t.config)throw new TypeError("Subtitle metadata must include a config object.");if(typeof t.config!="object")throw new TypeError("Subtitle metadata config must be an object.");if(typeof t.config.description!="string")throw new TypeError("Subtitle metadata config description must be a string.")};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class As{constructor(e){this.mutex=new je,this.firstMediaStreamTimestamp=null,this.trackTimestampInfo=new WeakMap,this.output=e}onTrackClose(e){}validateAndNormalizeTimestamp(e,r,n){r+=e.source._timestampOffset;let i=this.trackTimestampInfo.get(e);if(!i){if(!n)throw new Error("First frame must be a key frame.");i={maxTimestamp:r,maxTimestampBeforeLastKeyFrame:r},this.trackTimestampInfo.set(e,i)}if(r<0)throw new Error(`Timestamps must be non-negative (got ${r}s).`);if(n&&(i.maxTimestampBeforeLastKeyFrame=i.maxTimestamp),r<i.maxTimestampBeforeLastKeyFrame)throw new Error(`Timestamps cannot be smaller than the highest timestamp of the previous GOP (a GOP begins with a key frame and ends right before the next key frame). Got ${r}s, but highest timestamp is ${i.maxTimestampBeforeLastKeyFrame}s.`);return i.maxTimestamp=Math.max(i.maxTimestamp,r),r}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */var kt;(function(t){t[t.IDR=5]="IDR",t[t.SPS=7]="SPS",t[t.PPS=8]="PPS",t[t.SPS_EXT=13]="SPS_EXT"})(kt||(kt={}));var se;(function(t){t[t.RASL_N=8]="RASL_N",t[t.RASL_R=9]="RASL_R",t[t.BLA_W_LP=16]="BLA_W_LP",t[t.RSV_IRAP_VCL23=23]="RSV_IRAP_VCL23",t[t.VPS_NUT=32]="VPS_NUT",t[t.SPS_NUT=33]="SPS_NUT",t[t.PPS_NUT=34]="PPS_NUT",t[t.PREFIX_SEI_NUT=39]="PREFIX_SEI_NUT",t[t.SUFFIX_SEI_NUT=40]="SUFFIX_SEI_NUT"})(se||(se={}));const Lt=t=>{const e=[];let r=0;for(;r<t.length;){let n=-1,i=0;for(let a=r;a<t.length-3;a++){if(t[a]===0&&t[a+1]===0&&t[a+2]===1){n=a,i=3;break}if(a<t.length-4&&t[a]===0&&t[a+1]===0&&t[a+2]===0&&t[a+3]===1){n=a,i=4;break}}if(n===-1)break;if(r>0&&n>r){const a=t.subarray(r,n);a.length>0&&e.push(a)}r=n+i}if(r<t.length){const n=t.subarray(r);n.length>0&&e.push(n)}return e},fi=(t,e)=>{const r=[];let n=0;const i=new DataView(t.buffer,t.byteOffset,t.byteLength);for(;n+e<=t.length;){let a;e===1?a=i.getUint8(n):e===2?a=i.getUint16(n,!1):e===3?a=lr(i,n,!1):e===4?a=i.getUint32(n,!1):($e(e),m(!1)),n+=e;const s=t.subarray(n,n+a);r.push(s),n+=a}return r},Br=t=>{const e=[],r=t.length;for(let n=0;n<r;n++)n+2<r&&t[n]===0&&t[n+1]===0&&t[n+2]===3?(e.push(0,0),n+=2):e.push(t[n]);return new Uint8Array(e)},Bs=t=>{const r=Lt(t);if(r.length===0)return null;let n=0;for(const o of r)n+=4+o.byteLength;const i=new Uint8Array(n),a=new DataView(i.buffer);let s=0;for(const o of r){const c=o.byteLength;a.setUint32(s,c,!1),s+=4,i.set(o,s),s+=o.byteLength}return i},zs=(t,e)=>{if(e.description){const i=(xe(e.description)[4]&3)+1;return fi(t,i)}else return Lt(t)},Yt=t=>t[0]&31,mi=t=>{try{const e=Lt(t),r=e.filter(h=>Yt(h)===kt.SPS),n=e.filter(h=>Yt(h)===kt.PPS),i=e.filter(h=>Yt(h)===kt.SPS_EXT);if(r.length===0||n.length===0)return null;const a=r[0],s=new j(Br(a));if(s.skipBits(1),s.skipBits(2),s.readBits(5)!==7)return console.error("Invalid SPS NAL unit type"),null;const c=s.readAlignedByte(),l=s.readAlignedByte(),u=s.readAlignedByte(),d={configurationVersion:1,avcProfileIndication:c,profileCompatibility:l,avcLevelIndication:u,lengthSizeMinusOne:3,sequenceParameterSets:r,pictureParameterSets:n,chromaFormat:null,bitDepthLumaMinus8:null,bitDepthChromaMinus8:null,sequenceParameterSetExt:null};if(c===100||c===110||c===122||c===144){B(s);const h=B(s);h===3&&s.skipBits(1);const f=B(s),p=B(s);d.chromaFormat=h,d.bitDepthLumaMinus8=f,d.bitDepthChromaMinus8=p,d.sequenceParameterSetExt=i}return d}catch(e){return console.error("Error building AVC Decoder Configuration Record:",e),null}},Rs=t=>{const e=[];e.push(t.configurationVersion),e.push(t.avcProfileIndication),e.push(t.profileCompatibility),e.push(t.avcLevelIndication),e.push(252|t.lengthSizeMinusOne&3),e.push(224|t.sequenceParameterSets.length&31);for(const r of t.sequenceParameterSets){const n=r.byteLength;e.push(n>>8),e.push(n&255);for(let i=0;i<n;i++)e.push(r[i])}e.push(t.pictureParameterSets.length);for(const r of t.pictureParameterSets){const n=r.byteLength;e.push(n>>8),e.push(n&255);for(let i=0;i<n;i++)e.push(r[i])}if(t.avcProfileIndication===100||t.avcProfileIndication===110||t.avcProfileIndication===122||t.avcProfileIndication===144){m(t.chromaFormat!==null),m(t.bitDepthLumaMinus8!==null),m(t.bitDepthChromaMinus8!==null),m(t.sequenceParameterSetExt!==null),e.push(252|t.chromaFormat&3),e.push(248|t.bitDepthLumaMinus8&7),e.push(248|t.bitDepthChromaMinus8&7),e.push(t.sequenceParameterSetExt.length);for(const r of t.sequenceParameterSetExt){const n=r.byteLength;e.push(n>>8),e.push(n&255);for(let i=0;i<n;i++)e.push(r[i])}}return new Uint8Array(e)},pi=(t,e)=>{if(e.description){const i=(xe(e.description)[21]&3)+1;return fi(t,i)}else return Lt(t)},Oe=t=>t[0]>>1&63,gi=t=>{try{const e=Lt(t),r=e.filter(I=>Oe(I)===se.VPS_NUT),n=e.filter(I=>Oe(I)===se.SPS_NUT),i=e.filter(I=>Oe(I)===se.PPS_NUT),a=e.filter(I=>Oe(I)===se.PREFIX_SEI_NUT||Oe(I)===se.SUFFIX_SEI_NUT);if(n.length===0||i.length===0)return null;const s=n[0],o=new j(Br(s));o.skipBits(16),o.readBits(4);const c=o.readBits(3),l=o.readBits(1),{general_profile_space:u,general_tier_flag:d,general_profile_idc:h,general_profile_compatibility_flags:f,general_constraint_indicator_flags:p,general_level_idc:g}=Ds(o,c);B(o);const b=B(o);b===3&&o.skipBits(1),B(o),B(o),o.readBits(1)&&(B(o),B(o),B(o),B(o));const w=B(o),k=B(o);B(o);const y=o.readBits(1)?0:c;for(let I=y;I<=c;I++)B(o),B(o),B(o);B(o),B(o),B(o),B(o),B(o),B(o),o.readBits(1)&&o.readBits(1)&&Ms(o),o.skipBits(1),o.skipBits(1),o.readBits(1)&&(o.skipBits(4),o.skipBits(4),B(o),B(o),o.skipBits(1));const x=B(o);if(Os(o,x),o.readBits(1)){const I=B(o);for(let A=0;A<I;A++)B(o),o.skipBits(1)}o.skipBits(1),o.skipBits(1);let _=0;o.readBits(1)&&(_=Vs(o,c));let C=0;if(i.length>0){const I=i[0],A=new j(Br(I));A.skipBits(16),B(A),B(A),A.skipBits(1),A.skipBits(1),A.skipBits(3),A.skipBits(1),A.skipBits(1),B(A),B(A),Ft(A),A.skipBits(1),A.skipBits(1),A.readBits(1)&&B(A),Ft(A),Ft(A),A.skipBits(1),A.skipBits(1),A.skipBits(1),A.skipBits(1);const M=A.readBits(1),W=A.readBits(1);!M&&!W?C=0:M&&!W?C=2:!M&&W?C=3:C=0}const F=[...r.length?[{arrayCompleteness:1,nalUnitType:se.VPS_NUT,nalUnits:r}]:[],...n.length?[{arrayCompleteness:1,nalUnitType:se.SPS_NUT,nalUnits:n}]:[],...i.length?[{arrayCompleteness:1,nalUnitType:se.PPS_NUT,nalUnits:i}]:[],...a.length?[{arrayCompleteness:1,nalUnitType:Oe(a[0]),nalUnits:a}]:[]];return{configurationVersion:1,generalProfileSpace:u,generalTierFlag:d,generalProfileIdc:h,generalProfileCompatibilityFlags:f,generalConstraintIndicatorFlags:p,generalLevelIdc:g,minSpatialSegmentationIdc:_,parallelismType:C,chromaFormatIdc:b,bitDepthLumaMinus8:w,bitDepthChromaMinus8:k,avgFrameRate:0,constantFrameRate:0,numTemporalLayers:c+1,temporalIdNested:l,lengthSizeMinusOne:3,arrays:F}}catch(e){return console.error("Error building HEVC Decoder Configuration Record:",e),null}},Ds=(t,e)=>{const r=t.readBits(2),n=t.readBits(1),i=t.readBits(5);let a=0;for(let u=0;u<32;u++)a=a<<1|t.readBits(1);const s=new Uint8Array(6);for(let u=0;u<6;u++)s[u]=t.readBits(8);const o=t.readBits(8),c=[],l=[];for(let u=0;u<e;u++)c.push(t.readBits(1)),l.push(t.readBits(1));if(e>0)for(let u=e;u<8;u++)t.skipBits(2);for(let u=0;u<e;u++)c[u]&&t.skipBits(88),l[u]&&t.skipBits(8);return{general_profile_space:r,general_tier_flag:n,general_profile_idc:i,general_profile_compatibility_flags:a,general_constraint_indicator_flags:s,general_level_idc:o}},Ms=t=>{for(let e=0;e<4;e++)for(let r=0;r<(e===3?2:6);r++)if(!t.readBits(1))B(t);else{const i=Math.min(64,1<<4+(e<<1));e>1&&Ft(t);for(let a=0;a<i;a++)Ft(t)}},Os=(t,e)=>{const r=[];for(let n=0;n<e;n++)r[n]=Ns(t,n,e,r)},Ns=(t,e,r,n)=>{let i=0,a=0,s=0;if(e!==0&&(a=t.readBits(1)),a){if(e===r){const c=B(t);s=e-(c+1)}else s=e-1;t.readBits(1),B(t);const o=n[s]??0;for(let c=0;c<=o;c++)t.readBits(1)||t.readBits(1);i=n[s]}else{const o=B(t),c=B(t);for(let l=0;l<o;l++)B(t),t.readBits(1);for(let l=0;l<c;l++)B(t),t.readBits(1);i=o+c}return i},Vs=(t,e)=>{if(t.readBits(1)&&t.readBits(8)===255&&(t.readBits(16),t.readBits(16)),t.readBits(1)&&t.readBits(1),t.readBits(1)&&(t.readBits(3),t.readBits(1),t.readBits(1)&&(t.readBits(8),t.readBits(8),t.readBits(8))),t.readBits(1)&&(B(t),B(t)),t.readBits(1),t.readBits(1),t.readBits(1),t.readBits(1)&&(B(t),B(t),B(t),B(t)),t.readBits(1)&&(t.readBits(32),t.readBits(32),t.readBits(1)&&B(t),t.readBits(1)&&Us(t,!0,e)),t.readBits(1)){t.readBits(1),t.readBits(1),t.readBits(1);const r=B(t);return B(t),B(t),B(t),B(t),r}return 0},Us=(t,e,r)=>{let n=!1,i=!1,a=!1;n=t.readBits(1)===1,i=t.readBits(1)===1,(n||i)&&(a=t.readBits(1)===1,a&&(t.readBits(8),t.readBits(5),t.readBits(1),t.readBits(5)),t.readBits(4),t.readBits(4),a&&t.readBits(4),t.readBits(5),t.readBits(5),t.readBits(5));for(let s=0;s<=r;s++){const o=t.readBits(1)===1;let c=!0;o||(c=t.readBits(1)===1);let l=!1;c?B(t):l=t.readBits(1)===1;let u=1;l||(u=B(t)+1),n&&vn(t,u,a),i&&vn(t,u,a)}},vn=(t,e,r)=>{for(let n=0;n<e;n++)B(t),B(t),r&&(B(t),B(t)),t.readBits(1)},Ws=t=>{const e=[];e.push(t.configurationVersion),e.push((t.generalProfileSpace&3)<<6|(t.generalTierFlag&1)<<5|t.generalProfileIdc&31),e.push(t.generalProfileCompatibilityFlags>>>24&255),e.push(t.generalProfileCompatibilityFlags>>>16&255),e.push(t.generalProfileCompatibilityFlags>>>8&255),e.push(t.generalProfileCompatibilityFlags&255),e.push(...t.generalConstraintIndicatorFlags),e.push(t.generalLevelIdc&255),e.push(240|t.minSpatialSegmentationIdc>>8&15),e.push(t.minSpatialSegmentationIdc&255),e.push(252|t.parallelismType&3),e.push(252|t.chromaFormatIdc&3),e.push(248|t.bitDepthLumaMinus8&7),e.push(248|t.bitDepthChromaMinus8&7),e.push(t.avgFrameRate>>8&255),e.push(t.avgFrameRate&255),e.push((t.constantFrameRate&3)<<6|(t.numTemporalLayers&7)<<3|(t.temporalIdNested&1)<<2|t.lengthSizeMinusOne&3),e.push(t.arrays.length&255);for(const r of t.arrays){e.push((r.arrayCompleteness&1)<<7|0|r.nalUnitType&63),e.push(r.nalUnits.length>>8&255),e.push(r.nalUnits.length&255);for(const n of r.nalUnits){e.push(n.length>>8&255),e.push(n.length&255);for(let i=0;i<n.length;i++)e.push(n[i])}}return new Uint8Array(e)},ki=t=>{const e=new j(t);if(e.readBits(2)!==2)return null;const n=e.readBits(1),a=(e.readBits(1)<<1)+n;if(a===3&&e.skipBits(1),e.readBits(1)===1||e.readBits(1)!==0||(e.skipBits(2),e.readBits(24)!==4817730))return null;let l=8;a>=2&&(l=e.readBits(1)?12:10);const u=e.readBits(3);let d=0,h=0;if(u!==7)if(h=e.readBits(1),a===1||a===3){const C=e.readBits(1),F=e.readBits(1);d=!C&&!F?3:C&&!F?2:1,e.skipBits(1)}else d=1;else d=3,h=1;const f=e.readBits(16),p=e.readBits(16),g=f+1,b=p+1,w=g*b;let k=$(We).level;for(const _ of We)if(w<=_.maxPictureSize){k=_.level;break}return{profile:a,level:k,bitDepth:l,chromaSubsampling:d,videoFullRangeFlag:h,colourPrimaries:u===2?1:u===1?6:2,transferCharacteristics:u===2?1:u===1?6:2,matrixCoefficients:u===7?0:u===2?1:u===1?6:2}},bi=function*(t){const e=new j(t),r=()=>{let n=0;for(let i=0;i<8;i++){const a=e.readAlignedByte();if(n|=(a&127)<<i*7,!(a&128))break;if(i===7&&a&128)return null}return n>=2**32-1?null:n};for(;e.getBitsLeft()>=8;){e.skipBits(1);const n=e.readBits(4),i=e.readBits(1),a=e.readBits(1);e.skipBits(1),i&&e.skipBits(8);let s;if(a){const o=r();if(o===null)return;s=o}else s=Math.floor(e.getBitsLeft()/8);m(e.pos%8===0),yield{type:n,data:t.subarray(e.pos/8,e.pos/8+s)},e.skipBits(s*8)}},wi=t=>{for(const{type:e,data:r}of bi(t)){if(e!==1)continue;const n=new j(r),i=n.readBits(3);n.readBits(1);const a=n.readBits(1);let s=0,o=0,c=0;if(a)s=n.readBits(5);else{if(n.readBits(1)&&(n.skipBits(32),n.skipBits(32),n.readBits(1)))return null;const b=n.readBits(1);b&&(c=n.readBits(5),n.skipBits(32),n.skipBits(5),n.skipBits(5));const w=n.readBits(5);for(let k=0;k<=w;k++){n.skipBits(12);const T=n.readBits(5);if(k===0&&(s=T),T>7){const x=n.readBits(1);k===0&&(o=x)}if(b&&n.readBits(1)){const _=c+1;n.skipBits(_),n.skipBits(_),n.skipBits(1)}n.readBits(1)&&n.skipBits(4)}}const l=n.readBits(1);let u=8;i===2&&l?u=n.readBits(1)?12:10:i<=2&&(u=l?10:8);let d=0;i!==1&&(d=n.readBits(1));let h=1,f=1,p=0;return d||(i===0?(h=1,f=1):i===1?(h=0,f=0):u===12&&(h=n.readBits(1),h&&(f=n.readBits(1))),h&&f&&(p=n.readBits(2))),{profile:i,level:s,tier:o,bitDepth:u,monochrome:d,chromaSubsamplingX:h,chromaSubsamplingY:f,chromaSamplePosition:p}}return null},Ti=t=>{const e=te(t),r=e.getUint8(9),n=e.getUint16(10,!0),i=e.getUint32(12,!0),a=e.getInt16(16,!0),s=e.getUint8(18);let o=null;return s&&(o=t.subarray(19,21+r)),{outputChannelCount:r,preSkip:n,inputSampleRate:i,outputGain:a,channelMappingFamily:s,channelMappingTable:o}},Ls=[480,960,1920,2880,480,960,1920,2880,480,960,1920,2880,480,960,480,960,120,240,480,960,120,240,480,960,120,240,480,960,120,240,480,960],Hs=t=>{const e=t[0]>>3;return{durationInSamples:Ls[e]}},qs=t=>{if(t.length<7)throw new Error("Setup header is too short.");if(t[0]!==5)throw new Error("Wrong packet type in Setup header.");if(String.fromCharCode(...t.slice(1,7))!=="vorbis")throw new Error("Invalid packet signature in Setup header.");const r=t.length,n=new Uint8Array(r);for(let d=0;d<r;d++)n[d]=t[r-1-d];const i=new j(n);let a=0;for(;i.getBitsLeft()>97;)if(i.readBits(1)===1){a=i.pos;break}if(a===0)throw new Error("Invalid Setup header: framing bit not found.");let s=0,o=!1,c=0;for(;i.getBitsLeft()>=97;){const d=i.pos,h=i.readBits(8),f=i.readBits(16),p=i.readBits(16);if(h>63||f!==0||p!==0){i.pos=d;break}if(i.skipBits(1),s++,s>64)break;i.clone().readBits(6)+1===s&&(o=!0,c=s)}if(!o)throw new Error("Invalid Setup header: mode header not found.");if(c>63)throw new Error(`Unsupported mode count: ${c}.`);const l=c;i.pos=0,i.skipBits(a);const u=Array(l).fill(0);for(let d=l-1;d>=0;d--)i.skipBits(40),u[d]=i.readBits(1);return{modeBlockflags:u}},yi=(t,e,r)=>{switch(t){case"avc":return zs(r,e).some(a=>Yt(a)===kt.IDR)?"key":"delta";case"hevc":return pi(r,e).some(a=>{const s=Oe(a);return se.BLA_W_LP<=s&&s<=se.RSV_IRAP_VCL23})?"key":"delta";case"vp8":return(r[0]&1)===0?"key":"delta";case"vp9":{const n=new j(r);if(n.readBits(2)!==2)return null;const i=n.readBits(1);return(n.readBits(1)<<1)+i===3&&n.skipBits(1),n.readBits(1)?null:n.readBits(1)===0?"key":"delta"}case"av1":{let n=!1;for(const{type:i,data:a}of bi(r))if(i===1){const s=new j(a);s.skipBits(4),n=!!s.readBits(1)}else if(i===3||i===6||i===7){if(n)return"key";const s=new j(a);return s.readBits(1)?null:s.readBits(2)===0?"key":"delta"}return null}default:$e(t),m(!1)}};var bt;(function(t){t[t.STREAMINFO=0]="STREAMINFO",t[t.VORBIS_COMMENT=4]="VORBIS_COMMENT",t[t.PICTURE=6]="PICTURE"})(bt||(bt={}));const zr=(t,e)=>{const r=te(t);let n=0;const i=r.getUint32(n,!0);n+=4;const a=he.decode(t.subarray(n,n+i));n+=i,i>0&&(e.raw??={},e.raw.vendor??=a);const s=r.getUint32(n,!0);n+=4;for(let o=0;o<s;o++){const c=r.getUint32(n,!0);n+=4;const l=he.decode(t.subarray(n,n+c));n+=c;const u=l.indexOf("=");if(u===-1)continue;const d=l.slice(0,u).toUpperCase(),h=l.slice(u+1);switch(e.raw??={},e.raw[d]??=h,d){case"TITLE":e.title??=h;break;case"DESCRIPTION":e.description??=h;break;case"ARTIST":e.artist??=h;break;case"ALBUM":e.album??=h;break;case"ALBUMARTIST":e.albumArtist??=h;break;case"COMMENT":e.comment??=h;break;case"LYRICS":e.lyrics??=h;break;case"TRACKNUMBER":{const f=h.split("/"),p=Number.parseInt(f[0],10),g=f[1]&&Number.parseInt(f[1],10);Number.isInteger(p)&&p>0&&(e.trackNumber??=p),g&&Number.isInteger(g)&&g>0&&(e.tracksTotal??=g)}break;case"TRACKTOTAL":{const f=Number.parseInt(h,10);Number.isInteger(f)&&f>0&&(e.tracksTotal??=f)}break;case"DISCNUMBER":{const f=h.split("/"),p=Number.parseInt(f[0],10),g=f[1]&&Number.parseInt(f[1],10);Number.isInteger(p)&&p>0&&(e.discNumber??=p),g&&Number.isInteger(g)&&g>0&&(e.discsTotal??=g)}break;case"DISCTOTAL":{const f=Number.parseInt(h,10);Number.isInteger(f)&&f>0&&(e.discsTotal??=f)}break;case"DATE":{const f=new Date(h);Number.isNaN(f.getTime())||(e.date??=f)}break;case"GENRE":e.genre??=h;break;case"METADATA_BLOCK_PICTURE":{const f=gs(h),p=te(f),g=p.getUint32(0,!1),b=p.getUint32(4,!1),w=String.fromCharCode(...f.subarray(8,8+b)),k=p.getUint32(8+b,!1),T=he.decode(f.subarray(12+b,12+b+k)),y=p.getUint32(b+k+28),x=f.subarray(b+k+32,b+k+32+y);e.images??=[],e.images.push({data:x,mimeType:w,kind:g===3?"coverFront":g===4?"coverBack":"unknown",name:void 0,description:T||void 0})}break}}};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class tt{constructor(e){this.input=e}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Si=[],xi=[],Rr=[],Dr=[];/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const fe=new Uint8Array(0);class H{constructor(e,r,n,i,a=-1,s,o){if(this.data=e,this.type=r,this.timestamp=n,this.duration=i,this.sequenceNumber=a,e===fe&&s===void 0)throw new Error("Internal error: byteLength must be explicitly provided when constructing metadata-only packets.");if(s===void 0&&(s=e.byteLength),!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if(r!=="key"&&r!=="delta")throw new TypeError('type must be either "key" or "delta".');if(!Number.isFinite(n))throw new TypeError("timestamp must be a number.");if(!Number.isFinite(i)||i<0)throw new TypeError("duration must be a non-negative number.");if(!Number.isFinite(a))throw new TypeError("sequenceNumber must be a number.");if(!Number.isInteger(s)||s<0)throw new TypeError("byteLength must be a non-negative integer.");if(o!==void 0&&(typeof o!="object"||!o))throw new TypeError("sideData, when provided, must be an object.");if(o?.alpha!==void 0&&!(o.alpha instanceof Uint8Array))throw new TypeError("sideData.alpha, when provided, must be a Uint8Array.");if(o?.alphaByteLength!==void 0&&(!Number.isInteger(o.alphaByteLength)||o.alphaByteLength<0))throw new TypeError("sideData.alphaByteLength, when provided, must be a non-negative integer.");this.byteLength=s,this.sideData=o??{},this.sideData.alpha&&this.sideData.alphaByteLength===void 0&&(this.sideData.alphaByteLength=this.sideData.alpha.byteLength)}get isMetadataOnly(){return this.data===fe}get microsecondTimestamp(){return Math.trunc(Ue*this.timestamp)}get microsecondDuration(){return Math.trunc(Ue*this.duration)}toEncodedVideoChunk(){if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to a video chunk.");if(typeof EncodedVideoChunk>"u")throw new Error("Your browser does not support EncodedVideoChunk.");return new EncodedVideoChunk({data:this.data,type:this.type,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}alphaToEncodedVideoChunk(e=this.type){if(!this.sideData.alpha)throw new TypeError("This packet does not contain alpha side data.");if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to a video chunk.");if(typeof EncodedVideoChunk>"u")throw new Error("Your browser does not support EncodedVideoChunk.");return new EncodedVideoChunk({data:this.sideData.alpha,type:e,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}toEncodedAudioChunk(){if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to an audio chunk.");if(typeof EncodedAudioChunk>"u")throw new Error("Your browser does not support EncodedAudioChunk.");return new EncodedAudioChunk({data:this.data,type:this.type,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}static fromEncodedChunk(e,r){if(!(e instanceof EncodedVideoChunk||e instanceof EncodedAudioChunk))throw new TypeError("chunk must be an EncodedVideoChunk or EncodedAudioChunk.");const n=new Uint8Array(e.byteLength);return e.copyTo(n),new H(n,e.type,e.timestamp/1e6,(e.duration??0)/1e6,void 0,void 0,r)}clone(e){if(e!==void 0&&(typeof e!="object"||e===null))throw new TypeError("options, when provided, must be an object.");if(e?.timestamp!==void 0&&!Number.isFinite(e.timestamp))throw new TypeError("options.timestamp, when provided, must be a number.");if(e?.duration!==void 0&&!Number.isFinite(e.duration))throw new TypeError("options.duration, when provided, must be a number.");return new H(this.data,this.type,e?.timestamp??this.timestamp,e?.duration??this.duration,this.sequenceNumber,this.byteLength)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const $s=t=>{let n=t,i=4096,a=0,s=12,o=0;for(n<0&&(n=-n,a=128),n+=33,n>8191&&(n=8191);(n&i)!==i&&s>=5;)i>>=1,s--;return o=n>>s-4&15,~(a|s-5<<4|o)&255},js=t=>{let r=0,n=0,i=~t;i&128&&(i&=-129,r=-1),n=((i&240)>>4)+5;const a=(1<<n|(i&15)<<n-4|1<<n-5)-33;return r===0?a:-a},Ks=t=>{let r=2048,n=0,i=11,a=0,s=t;for(s<0&&(s=-s,n=128),s>4095&&(s=4095);(s&r)!==r&&i>=5;)r>>=1,i--;return a=s>>(i===4?1:i-4)&15,(n|i-4<<4|a)^85},Qs=t=>{let e=0,r=0,n=t^85;n&128&&(n&=-129,e=-1),r=((n&240)>>4)+4;let i=0;return r!==4?i=1<<r|(n&15)<<r-4|1<<r-5:i=n<<1|1,e===0?i:-i};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */si();class de{get displayWidth(){return this.rotation%180===0?this.codedWidth:this.codedHeight}get displayHeight(){return this.rotation%180===0?this.codedHeight:this.codedWidth}get microsecondTimestamp(){return Math.trunc(Ue*this.timestamp)}get microsecondDuration(){return Math.trunc(Ue*this.duration)}get hasAlpha(){return this.format&&this.format.includes("A")}constructor(e,r){if(this._closed=!1,e instanceof ArrayBuffer||ArrayBuffer.isView(e)){if(!r||typeof r!="object")throw new TypeError("init must be an object.");if(!("format"in r)||typeof r.format!="string")throw new TypeError("init.format must be a string.");if(!Number.isInteger(r.codedWidth)||r.codedWidth<=0)throw new TypeError("init.codedWidth must be a positive integer.");if(!Number.isInteger(r.codedHeight)||r.codedHeight<=0)throw new TypeError("init.codedHeight must be a positive integer.");if(r.rotation!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(!Number.isFinite(r.timestamp))throw new TypeError("init.timestamp must be a number.");if(r.duration!==void 0&&(!Number.isFinite(r.duration)||r.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");this._data=xe(e).slice(),this.format=r.format,this.codedWidth=r.codedWidth,this.codedHeight=r.codedHeight,this.rotation=r.rotation??0,this.timestamp=r.timestamp,this.duration=r.duration??0,this.colorSpace=new VideoColorSpace(r.colorSpace)}else if(typeof VideoFrame<"u"&&e instanceof VideoFrame){if(r?.rotation!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(r?.timestamp!==void 0&&!Number.isFinite(r?.timestamp))throw new TypeError("init.timestamp, when provided, must be a number.");if(r?.duration!==void 0&&(!Number.isFinite(r.duration)||r.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");this._data=e,this.format=e.format,this.codedWidth=e.displayWidth,this.codedHeight=e.displayHeight,this.rotation=r?.rotation??0,this.timestamp=r?.timestamp??e.timestamp/1e6,this.duration=r?.duration??(e.duration??0)/1e6,this.colorSpace=e.colorSpace}else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof SVGImageElement<"u"&&e instanceof SVGImageElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap||typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&e instanceof OffscreenCanvas){if(!r||typeof r!="object")throw new TypeError("init must be an object.");if(r.rotation!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(!Number.isFinite(r.timestamp))throw new TypeError("init.timestamp must be a number.");if(r.duration!==void 0&&(!Number.isFinite(r.duration)||r.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");if(typeof VideoFrame<"u")return new de(new VideoFrame(e,{timestamp:Math.trunc(r.timestamp*Ue),duration:Math.trunc((r.duration??0)*Ue)||void 0}),r);let n=0,i=0;if("naturalWidth"in e?(n=e.naturalWidth,i=e.naturalHeight):"videoWidth"in e?(n=e.videoWidth,i=e.videoHeight):"width"in e&&(n=Number(e.width),i=Number(e.height)),!n||!i)throw new TypeError("Could not determine dimensions.");const a=new OffscreenCanvas(n,i),s=a.getContext("2d",{alpha:Mt(),willReadFrequently:!0});m(s),s.drawImage(e,0,0),this._data=a,this.format="RGBX",this.codedWidth=n,this.codedHeight=i,this.rotation=r.rotation??0,this.timestamp=r.timestamp,this.duration=r.duration??0,this.colorSpace=new VideoColorSpace({matrix:"rgb",primaries:"bt709",transfer:"iec61966-2-1",fullRange:!0})}else throw new TypeError("Invalid data type: Must be a BufferSource or CanvasImageSource.")}clone(){if(this._closed)throw new Error("VideoSample is closed.");return m(this._data!==null),St(this._data)?new de(this._data.clone(),{timestamp:this.timestamp,duration:this.duration,rotation:this.rotation}):this._data instanceof Uint8Array?new de(this._data.slice(),{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.timestamp,duration:this.duration,colorSpace:this.colorSpace,rotation:this.rotation}):new de(this._data,{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.timestamp,duration:this.duration,colorSpace:this.colorSpace,rotation:this.rotation})}close(){this._closed||(St(this._data)?this._data.close():this._data=null,this._closed=!0)}allocationSize(){if(this._closed)throw new Error("VideoSample is closed.");return m(this._data!==null),St(this._data)?this._data.allocationSize():this._data instanceof Uint8Array?this._data.byteLength:this.codedWidth*this.codedHeight*4}async copyTo(e){if(!cr(e))throw new TypeError("destination must be an ArrayBuffer or an ArrayBuffer view.");if(this._closed)throw new Error("VideoSample is closed.");if(m(this._data!==null),St(this._data))await this._data.copyTo(e);else if(this._data instanceof Uint8Array)xe(e).set(this._data);else{const n=this._data.getContext("2d");m(n);const i=n.getImageData(0,0,this.codedWidth,this.codedHeight);xe(e).set(i.data)}}toVideoFrame(){if(this._closed)throw new Error("VideoSample is closed.");return m(this._data!==null),St(this._data)?new VideoFrame(this._data,{timestamp:this.microsecondTimestamp,duration:this.microsecondDuration||void 0}):this._data instanceof Uint8Array?new VideoFrame(this._data,{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration||void 0,colorSpace:this.colorSpace}):new VideoFrame(this._data,{timestamp:this.microsecondTimestamp,duration:this.microsecondDuration||void 0})}draw(e,r,n,i,a,s,o,c,l){let u=0,d=0,h=this.displayWidth,f=this.displayHeight,p=0,g=0,b=this.displayWidth,w=this.displayHeight;if(s!==void 0?(u=r,d=n,h=i,f=a,p=s,g=o,c!==void 0?(b=c,w=l):(b=h,w=f)):(p=r,g=n,i!==void 0&&(b=i,w=a)),!(typeof CanvasRenderingContext2D<"u"&&e instanceof CanvasRenderingContext2D||typeof OffscreenCanvasRenderingContext2D<"u"&&e instanceof OffscreenCanvasRenderingContext2D))throw new TypeError("context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.");if(!Number.isFinite(u))throw new TypeError("sx must be a number.");if(!Number.isFinite(d))throw new TypeError("sy must be a number.");if(!Number.isFinite(h)||h<0)throw new TypeError("sWidth must be a non-negative number.");if(!Number.isFinite(f)||f<0)throw new TypeError("sHeight must be a non-negative number.");if(!Number.isFinite(p))throw new TypeError("dx must be a number.");if(!Number.isFinite(g))throw new TypeError("dy must be a number.");if(!Number.isFinite(b)||b<0)throw new TypeError("dWidth must be a non-negative number.");if(!Number.isFinite(w)||w<0)throw new TypeError("dHeight must be a non-negative number.");if(this._closed)throw new Error("VideoSample is closed.");({sx:u,sy:d,sWidth:h,sHeight:f}=this._rotateSourceRegion(u,d,h,f,this.rotation));const k=this.toCanvasImageSource();e.save();const T=p+b/2,y=g+w/2;e.translate(T,y),e.rotate(this.rotation*Math.PI/180);const x=this.rotation%180===0?1:b/w;e.scale(1/x,x),e.drawImage(k,u,d,h,f,-b/2,-w/2,b,w),e.restore()}drawWithFit(e,r){if(!(typeof CanvasRenderingContext2D<"u"&&e instanceof CanvasRenderingContext2D||typeof OffscreenCanvasRenderingContext2D<"u"&&e instanceof OffscreenCanvasRenderingContext2D))throw new TypeError("context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.");if(!r||typeof r!="object")throw new TypeError("options must be an object.");if(!["fill","contain","cover"].includes(r.fit))throw new TypeError("options.fit must be 'fill', 'contain', or 'cover'.");if(r.rotation!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError("options.rotation, when provided, must be 0, 90, 180, or 270.");r.crop!==void 0&&Jr(r.crop,"options.");const n=e.canvas.width,i=e.canvas.height,a=r.rotation??this.rotation,[s,o]=a%180===0?[this.codedWidth,this.codedHeight]:[this.codedHeight,this.codedWidth];r.crop&&Zr(r.crop,s,o);let c,l,u,d;const{sx:h,sy:f,sWidth:p,sHeight:g}=this._rotateSourceRegion(r.crop?.left??0,r.crop?.top??0,r.crop?.width??s,r.crop?.height??o,a);if(r.fit==="fill")c=0,l=0,u=n,d=i;else{const[w,k]=r.crop?[r.crop.width,r.crop.height]:[s,o],T=r.fit==="contain"?Math.min(n/w,i/k):Math.max(n/w,i/k);u=w*T,d=k*T,c=(n-u)/2,l=(i-d)/2}const b=a%180===0?1:u/d;e.translate(n/2,i/2),e.rotate(a*Math.PI/180),e.scale(1/b,b),e.translate(-n/2,-i/2),e.drawImage(this.toCanvasImageSource(),h,f,p,g,c,l,u,d)}_rotateSourceRegion(e,r,n,i,a){return a===90?[e,r,n,i]=[r,this.codedHeight-e-n,i,n]:a===180?[e,r]=[this.codedWidth-e-n,this.codedHeight-r-i]:a===270&&([e,r,n,i]=[this.codedWidth-r-i,e,i,n]),{sx:e,sy:r,sWidth:n,sHeight:i}}toCanvasImageSource(){if(this._closed)throw new Error("VideoSample is closed.");if(m(this._data!==null),this._data instanceof Uint8Array){const e=this.toVideoFrame();return queueMicrotask(()=>e.close()),e}else return this._data}setRotation(e){if(![0,90,180,270].includes(e))throw new TypeError("newRotation must be 0, 90, 180, or 270.");this.rotation=e}setTimestamp(e){if(!Number.isFinite(e))throw new TypeError("newTimestamp must be a number.");this.timestamp=e}setDuration(e){if(!Number.isFinite(e)||e<0)throw new TypeError("newDuration must be a non-negative number.");this.duration=e}[Symbol.dispose](){this.close()}}const St=t=>typeof VideoFrame<"u"&&t instanceof VideoFrame,Zr=(t,e,r)=>{t.left=Math.min(t.left,e),t.top=Math.min(t.top,r),t.width=Math.min(t.width,e-t.left),t.height=Math.min(t.height,r-t.top),m(t.width>=0),m(t.height>=0)},Jr=(t,e)=>{if(!t||typeof t!="object")throw new TypeError(e+"crop, when provided, must be an object.");if(!Number.isInteger(t.left)||t.left<0)throw new TypeError(e+"crop.left must be a non-negative integer.");if(!Number.isInteger(t.top)||t.top<0)throw new TypeError(e+"crop.top must be a non-negative integer.");if(!Number.isInteger(t.width)||t.width<0)throw new TypeError(e+"crop.width must be a non-negative integer.");if(!Number.isInteger(t.height)||t.height<0)throw new TypeError(e+"crop.height must be a non-negative integer.")},pr=new Set(["f32","f32-planar","s16","s16-planar","s32","s32-planar","u8","u8-planar"]);class Se{get microsecondTimestamp(){return Math.trunc(Ue*this.timestamp)}get microsecondDuration(){return Math.trunc(Ue*this.duration)}constructor(e){if(this._closed=!1,Ct(e)){if(e.format===null)throw new TypeError("AudioData with null format is not supported.");this._data=e,this.format=e.format,this.sampleRate=e.sampleRate,this.numberOfFrames=e.numberOfFrames,this.numberOfChannels=e.numberOfChannels,this.timestamp=e.timestamp/1e6,this.duration=e.numberOfFrames/e.sampleRate}else{if(!e||typeof e!="object")throw new TypeError("Invalid AudioDataInit: must be an object.");if(!pr.has(e.format))throw new TypeError("Invalid AudioDataInit: invalid format.");if(!Number.isFinite(e.sampleRate)||e.sampleRate<=0)throw new TypeError("Invalid AudioDataInit: sampleRate must be > 0.");if(!Number.isInteger(e.numberOfChannels)||e.numberOfChannels===0)throw new TypeError("Invalid AudioDataInit: numberOfChannels must be an integer > 0.");if(!Number.isFinite(e?.timestamp))throw new TypeError("init.timestamp must be a number.");const r=e.data.byteLength/(xt(e.format)*e.numberOfChannels);if(!Number.isInteger(r))throw new TypeError("Invalid AudioDataInit: data size is not a multiple of frame size.");this.format=e.format,this.sampleRate=e.sampleRate,this.numberOfFrames=r,this.numberOfChannels=e.numberOfChannels,this.timestamp=e.timestamp,this.duration=r/e.sampleRate;let n;if(e.data instanceof ArrayBuffer)n=new Uint8Array(e.data);else if(ArrayBuffer.isView(e.data))n=new Uint8Array(e.data.buffer,e.data.byteOffset,e.data.byteLength);else throw new TypeError("Invalid AudioDataInit: data is not a BufferSource.");const i=this.numberOfFrames*this.numberOfChannels*xt(this.format);if(n.byteLength<i)throw new TypeError("Invalid AudioDataInit: insufficient data size.");this._data=n}}allocationSize(e){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(!Number.isInteger(e.planeIndex)||e.planeIndex<0)throw new TypeError("planeIndex must be a non-negative integer.");if(e.format!==void 0&&!pr.has(e.format))throw new TypeError("Invalid format.");if(e.frameOffset!==void 0&&(!Number.isInteger(e.frameOffset)||e.frameOffset<0))throw new TypeError("frameOffset must be a non-negative integer.");if(e.frameCount!==void 0&&(!Number.isInteger(e.frameCount)||e.frameCount<0))throw new TypeError("frameCount must be a non-negative integer.");if(this._closed)throw new Error("AudioSample is closed.");const r=e.format??this.format,n=e.frameOffset??0;if(n>=this.numberOfFrames)throw new RangeError("frameOffset out of range");const i=e.frameCount!==void 0?e.frameCount:this.numberOfFrames-n;if(i>this.numberOfFrames-n)throw new RangeError("frameCount out of range");const a=xt(r),s=$t(r);if(s&&e.planeIndex>=this.numberOfChannels)throw new RangeError("planeIndex out of range");if(!s&&e.planeIndex!==0)throw new RangeError("planeIndex out of range");return(s?i:i*this.numberOfChannels)*a}copyTo(e,r){if(!cr(e))throw new TypeError("destination must be an ArrayBuffer or an ArrayBuffer view.");if(!r||typeof r!="object")throw new TypeError("options must be an object.");if(!Number.isInteger(r.planeIndex)||r.planeIndex<0)throw new TypeError("planeIndex must be a non-negative integer.");if(r.format!==void 0&&!pr.has(r.format))throw new TypeError("Invalid format.");if(r.frameOffset!==void 0&&(!Number.isInteger(r.frameOffset)||r.frameOffset<0))throw new TypeError("frameOffset must be a non-negative integer.");if(r.frameCount!==void 0&&(!Number.isInteger(r.frameCount)||r.frameCount<0))throw new TypeError("frameCount must be a non-negative integer.");if(this._closed)throw new Error("AudioSample is closed.");const{planeIndex:n,format:i,frameCount:a,frameOffset:s}=r,o=i??this.format;if(!o)throw new Error("Destination format not determined");const c=this.numberOfFrames,l=this.numberOfChannels,u=s??0;if(u>=c)throw new RangeError("frameOffset out of range");const d=a!==void 0?a:c-u;if(d>c-u)throw new RangeError("frameCount out of range");const h=xt(o),f=$t(o);if(f&&n>=l)throw new RangeError("planeIndex out of range");if(!f&&n!==0)throw new RangeError("planeIndex out of range");const g=(f?d:d*l)*h;if(e.byteLength<g)throw new RangeError("Destination buffer is too small");const b=te(e),w=Xs(o);if(Ct(this._data))if(f)if(o==="f32-planar")this._data.copyTo(e,{planeIndex:n,frameOffset:u,frameCount:d,format:"f32-planar"});else{const k=new ArrayBuffer(d*4),T=new Float32Array(k);this._data.copyTo(T,{planeIndex:n,frameOffset:u,frameCount:d,format:"f32-planar"});const y=new DataView(k);for(let x=0;x<d;x++){const _=x*h,C=y.getFloat32(x*4,!0);w(b,_,C)}}else{const k=l,T=new Float32Array(d);for(let y=0;y<k;y++){this._data.copyTo(T,{planeIndex:y,frameOffset:u,frameCount:d,format:"f32-planar"});for(let x=0;x<d;x++){const C=(x*k+y)*h;w(b,C,T[x])}}}else{const k=this._data,T=new DataView(k.buffer,k.byteOffset,k.byteLength),y=this.format,x=Gs(y),_=xt(y),C=$t(y);for(let F=0;F<d;F++)if(f){const v=F*h;let I;C?I=(n*c+(F+u))*_:I=((F+u)*l+n)*_;const A=x(T,I);w(b,v,A)}else for(let v=0;v<l;v++){const A=(F*l+v)*h;let M;C?M=(v*c+(F+u))*_:M=((F+u)*l+v)*_;const W=x(T,M);w(b,A,W)}}}clone(){if(this._closed)throw new Error("AudioSample is closed.");if(Ct(this._data)){const e=new Se(this._data.clone());return e.setTimestamp(this.timestamp),e}else return new Se({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.timestamp,data:this._data})}close(){this._closed||(Ct(this._data)?this._data.close():this._data=new Uint8Array(0),this._closed=!0)}toAudioData(){if(this._closed)throw new Error("AudioSample is closed.");if(Ct(this._data)){if(this._data.timestamp===this.microsecondTimestamp)return this._data.clone();if($t(this.format)){const e=this.allocationSize({planeIndex:0,format:this.format}),r=new ArrayBuffer(e*this.numberOfChannels);for(let n=0;n<this.numberOfChannels;n++)this.copyTo(new Uint8Array(r,n*e,e),{planeIndex:n,format:this.format});return new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:r})}else{const e=new ArrayBuffer(this.allocationSize({planeIndex:0,format:this.format}));return this.copyTo(e,{planeIndex:0,format:this.format}),new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:e})}}else return new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:this._data})}toAudioBuffer(){if(this._closed)throw new Error("AudioSample is closed.");const e=new AudioBuffer({numberOfChannels:this.numberOfChannels,length:this.numberOfFrames,sampleRate:this.sampleRate}),r=new Float32Array(this.allocationSize({planeIndex:0,format:"f32-planar"})/4);for(let n=0;n<this.numberOfChannels;n++)this.copyTo(r,{planeIndex:n,format:"f32-planar"}),e.copyToChannel(r,n);return e}setTimestamp(e){if(!Number.isFinite(e))throw new TypeError("newTimestamp must be a number.");this.timestamp=e}[Symbol.dispose](){this.close()}static*_fromAudioBuffer(e,r){if(!(e instanceof AudioBuffer))throw new TypeError("audioBuffer must be an AudioBuffer.");const n=48e3*5,i=e.numberOfChannels,a=e.sampleRate,s=e.length,o=Math.floor(n/i);let c=0,l=s;for(;l>0;){const u=Math.min(o,l),d=new Float32Array(i*u);for(let h=0;h<i;h++)e.copyFromChannel(d.subarray(h*u,(h+1)*u),h,c);yield new Se({format:"f32-planar",sampleRate:a,numberOfFrames:u,numberOfChannels:i,timestamp:r+c/a,data:d}),c+=u,l-=u}}static fromAudioBuffer(e,r){if(!(e instanceof AudioBuffer))throw new TypeError("audioBuffer must be an AudioBuffer.");const n=48e3*5,i=e.numberOfChannels,a=e.sampleRate,s=e.length,o=Math.floor(n/i);let c=0,l=s;const u=[];for(;l>0;){const d=Math.min(o,l),h=new Float32Array(i*d);for(let p=0;p<i;p++)e.copyFromChannel(h.subarray(p*d,(p+1)*d),p,c);const f=new Se({format:"f32-planar",sampleRate:a,numberOfFrames:d,numberOfChannels:i,timestamp:r+c/a,data:h});u.push(f),c+=d,l-=d}return u}}const xt=t=>{switch(t){case"u8":case"u8-planar":return 1;case"s16":case"s16-planar":return 2;case"s32":case"s32-planar":return 4;case"f32":case"f32-planar":return 4;default:throw new Error("Unknown AudioSampleFormat")}},$t=t=>{switch(t){case"u8-planar":case"s16-planar":case"s32-planar":case"f32-planar":return!0;default:return!1}},Gs=t=>{switch(t){case"u8":case"u8-planar":return(e,r)=>(e.getUint8(r)-128)/128;case"s16":case"s16-planar":return(e,r)=>e.getInt16(r,!0)/32768;case"s32":case"s32-planar":return(e,r)=>e.getInt32(r,!0)/2147483648;case"f32":case"f32-planar":return(e,r)=>e.getFloat32(r,!0)}},Xs=t=>{switch(t){case"u8":case"u8-planar":return(e,r,n)=>e.setUint8(r,G((n+1)*127.5,0,255));case"s16":case"s16-planar":return(e,r,n)=>e.setInt16(r,G(Math.round(n*32767),-32768,32767),!0);case"s32":case"s32-planar":return(e,r,n)=>e.setInt32(r,G(Math.round(n*2147483647),-2147483648,2147483647),!0);case"f32":case"f32-planar":return(e,r,n)=>e.setFloat32(r,n,!0)}},Ct=t=>typeof AudioData<"u"&&t instanceof AudioData;/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const it=t=>{if(!t||typeof t!="object")throw new TypeError("options must be an object.");if(t.metadataOnly!==void 0&&typeof t.metadataOnly!="boolean")throw new TypeError("options.metadataOnly, when defined, must be a boolean.");if(t.verifyKeyPackets!==void 0&&typeof t.verifyKeyPackets!="boolean")throw new TypeError("options.verifyKeyPackets, when defined, must be a boolean.");if(t.verifyKeyPackets&&t.metadataOnly)throw new TypeError("options.verifyKeyPackets and options.metadataOnly cannot be enabled together.")},qe=t=>{if(typeof t!="number"||Number.isNaN(t))throw new TypeError("timestamp must be a number.")},gr=(t,e,r)=>r.verifyKeyPackets?e.then(async n=>{if(!n||n.type==="delta")return n;const i=await t.determinePacketType(n);return i&&(n.type=i),n}):e;class Ot{constructor(e){if(!(e instanceof tn))throw new TypeError("track must be an InputTrack.");this._track=e}getFirstPacket(e={}){if(it(e),this._track.input._disposed)throw new ce;return gr(this._track,this._track._backing.getFirstPacket(e),e)}getPacket(e,r={}){if(qe(e),it(r),this._track.input._disposed)throw new ce;return gr(this._track,this._track._backing.getPacket(e,r),r)}getNextPacket(e,r={}){if(!(e instanceof H))throw new TypeError("packet must be an EncodedPacket.");if(it(r),this._track.input._disposed)throw new ce;return gr(this._track,this._track._backing.getNextPacket(e,r),r)}async getKeyPacket(e,r={}){if(qe(e),it(r),this._track.input._disposed)throw new ce;if(!r.verifyKeyPackets)return this._track._backing.getKeyPacket(e,r);const n=await this._track._backing.getKeyPacket(e,r);return!n||n.type==="delta"?n:await this._track.determinePacketType(n)==="delta"?this.getKeyPacket(n.timestamp-1/this._track.timeResolution,r):n}async getNextKeyPacket(e,r={}){if(!(e instanceof H))throw new TypeError("packet must be an EncodedPacket.");if(it(r),this._track.input._disposed)throw new ce;if(!r.verifyKeyPackets)return this._track._backing.getNextKeyPacket(e,r);const n=await this._track._backing.getNextKeyPacket(e,r);return!n||n.type==="delta"?n:await this._track.determinePacketType(n)==="delta"?this.getNextKeyPacket(n,r):n}packets(e,r,n={}){if(e!==void 0&&!(e instanceof H))throw new TypeError("startPacket must be an EncodedPacket.");if(e!==void 0&&e.isMetadataOnly&&!n?.metadataOnly)throw new TypeError("startPacket can only be metadata-only if options.metadataOnly is enabled.");if(r!==void 0&&!(r instanceof H))throw new TypeError("endPacket must be an EncodedPacket.");if(it(n),this._track.input._disposed)throw new ce;const i=[];let{promise:a,resolve:s}=ee(),{promise:o,resolve:c}=ee(),l=!1,u=!1,d=null;const h=[],f=()=>Math.max(2,h.length);(async()=>{let g=e??await this.getFirstPacket(n);for(;g&&!u&&!this._track.input._disposed&&!(r&&g.sequenceNumber>=r?.sequenceNumber);){if(i.length>f()){({promise:o,resolve:c}=ee()),await o;continue}i.push(g),s(),{promise:a,resolve:s}=ee(),g=await this.getNextPacket(g,n)}l=!0,s()})().catch(g=>{d||(d=g,s())});const p=this._track;return{async next(){for(;;){if(p.input._disposed)throw new ce;if(u)return{value:void 0,done:!0};if(d)throw d;if(i.length>0){const g=i.shift(),b=performance.now();for(h.push(b);h.length>0&&b-h[0]>=1e3;)h.shift();return c(),{value:g,done:!1}}else{if(l)return{value:void 0,done:!0};await a}}},async return(){return u=!0,c(),s(),{value:void 0,done:!0}},async throw(g){throw g},[Symbol.asyncIterator](){return this}}}}class en{constructor(e,r){this.onSample=e,this.onError=r}}class Ci{mediaSamplesInRange(e=0,r=1/0){qe(e),qe(r);const n=[];let i=!1,a=null,{promise:s,resolve:o}=ee(),{promise:c,resolve:l}=ee(),u=!1,d=!1,h=!1,f=null;(async()=>{const b=new Error,w=await this._createDecoder(C=>{if(l(),C.timestamp>=r&&(d=!0),d){C.close();return}a&&(C.timestamp>e?(n.push(a),i=!0):a.close()),C.timestamp>=e&&(n.push(C),i=!0),a=i?null:C,n.length>0&&(o(),{promise:s,resolve:o}=ee())},C=>{f||(C.stack=b.stack,f=C,o())}),k=this._createPacketSink(),T=await k.getKeyPacket(e,{verifyKeyPackets:!0})??await k.getFirstPacket();if(!T)return;let y=T,x;if(r<1/0){const C=await k.getPacket(r),F=C?C.type==="key"&&C.timestamp===r?C:await k.getNextKeyPacket(C,{verifyKeyPackets:!0}):null;F&&(x=F)}const _=k.packets(T,x);for(await _.next();y&&!d&&!this._track.input._disposed;){const C=_n(n.length);if(n.length+w.getDecodeQueueSize()>C){({promise:c,resolve:l}=ee()),await c;continue}w.decode(y);const F=await _.next();if(F.done)break;y=F.value}await _.return(),!h&&!this._track.input._disposed&&await w.flush(),w.close(),!i&&a&&n.push(a),u=!0,o()})().catch(b=>{f||(f=b,o())});const p=this._track,g=()=>{a?.close();for(const b of n)b.close()};return{async next(){for(;;){if(p.input._disposed)throw g(),new ce;if(h)return{value:void 0,done:!0};if(f)throw g(),f;if(n.length>0){const b=n.shift();return l(),{value:b,done:!1}}else if(!u)await s;else return{value:void 0,done:!0}}},async return(){return h=!0,d=!0,l(),o(),g(),{value:void 0,done:!0}},async throw(b){throw b},[Symbol.asyncIterator](){return this}}}mediaSamplesAtTimestamps(e){ls(e);const r=cs(e),n=[],i=[];let{promise:a,resolve:s}=ee(),{promise:o,resolve:c}=ee(),l=!1,u=!1,d=null;const h=g=>{i.push(g),s(),{promise:a,resolve:s}=ee()};(async()=>{const g=new Error,b=await this._createDecoder(C=>{if(c(),u){C.close();return}let F=0;for(;n.length>0&&C.timestamp-n[0]>-1e-10;)F++,n.shift();if(F>0)for(let v=0;v<F;v++)h(v<F-1?C.clone():C);else C.close()},C=>{d||(C.stack=g.stack,d=C,s())}),w=this._createPacketSink();let k=null,T=null,y=-1;const x=async()=>{m(T);let C=T;for(b.decode(C);C.sequenceNumber<y;){const F=_n(i.length);for(;i.length+b.getDecodeQueueSize()>F&&!u;)({promise:o,resolve:c}=ee()),await o;if(u)break;const v=await w.getNextPacket(C);m(v),b.decode(v),C=v}y=-1},_=async()=>{await b.flush();for(let C=0;C<n.length;C++)h(null);n.length=0};for await(const C of r){if(qe(C),u||this._track.input._disposed)break;const F=await w.getPacket(C),v=F&&await w.getKeyPacket(C,{verifyKeyPackets:!0});if(!v){y!==-1&&(await x(),await _()),h(null),k=null;continue}k&&(v.sequenceNumber!==T.sequenceNumber||F.timestamp<k.timestamp)&&(await x(),await _()),n.push(F.timestamp),y=Math.max(F.sequenceNumber,y),k=F,T=v}!u&&!this._track.input._disposed&&(y!==-1&&await x(),await _()),b.close(),l=!0,s()})().catch(g=>{d||(d=g,s())});const f=this._track,p=()=>{for(const g of i)g?.close()};return{async next(){for(;;){if(f.input._disposed)throw p(),new ce;if(u)return{value:void 0,done:!0};if(d)throw p(),d;if(i.length>0){const g=i.shift();return m(g!==void 0),c(),{value:g,done:!1}}else if(!l)await a;else return{value:void 0,done:!0}}},async return(){return u=!0,c(),s(),p(),{value:void 0,done:!0}},async throw(g){throw g},[Symbol.asyncIterator](){return this}}}}const _n=t=>t===0?40:8;class Ys extends en{constructor(e,r,n,i,a,s){super(e,r),this.codec=n,this.decoderConfig=i,this.rotation=a,this.timeResolution=s,this.decoder=null,this.customDecoder=null,this.customDecoderCallSerializer=new ur,this.customDecoderQueueSize=0,this.inputTimestamps=[],this.sampleQueue=[],this.currentPacketIndex=0,this.raslSkipped=!1,this.alphaDecoder=null,this.alphaHadKeyframe=!1,this.colorQueue=[],this.alphaQueue=[],this.merger=null,this.mergerCreationFailed=!1,this.decodedAlphaChunkCount=0,this.alphaDecoderQueueSize=0,this.nullAlphaFrameQueue=[],this.currentAlphaPacketIndex=0,this.alphaRaslSkipped=!1;const o=Si.find(c=>c.supports(n,i));if(o)this.customDecoder=new o,this.customDecoder.codec=n,this.customDecoder.config=i,this.customDecoder.onSample=c=>{if(!(c instanceof de))throw new TypeError("The argument passed to onSample must be a VideoSample.");this.finalizeAndEmitSample(c)},this.customDecoderCallSerializer.call(()=>this.customDecoder.init());else{const c=l=>{if(this.alphaQueue.length>0){const u=this.alphaQueue.shift();m(u!==void 0),this.mergeAlpha(l,u)}else this.colorQueue.push(l)};this.decoder=new VideoDecoder({output:l=>{try{c(l)}catch(u){this.onError(u)}},error:r}),this.decoder.configure(i)}}getDecodeQueueSize(){return this.customDecoder?this.customDecoderQueueSize:(m(this.decoder),Math.max(this.decoder.decodeQueueSize,this.alphaDecoder?.decodeQueueSize??0))}decode(e){if(this.codec==="hevc"&&this.currentPacketIndex>0&&!this.raslSkipped){if(this.hasHevcRaslPicture(e.data))return;this.raslSkipped=!0}this.currentPacketIndex++,this.customDecoder?(this.customDecoderQueueSize++,this.customDecoderCallSerializer.call(()=>this.customDecoder.decode(e)).then(()=>this.customDecoderQueueSize--)):(m(this.decoder),fr()||He(this.inputTimestamps,e.timestamp,r=>r),this.decoder.decode(e.toEncodedVideoChunk()),this.decodeAlphaData(e))}decodeAlphaData(e){if(!e.sideData.alpha||this.mergerCreationFailed){this.pushNullAlphaFrame();return}if(!this.merger)try{this.merger=new Zs}catch(n){console.error("Due to an error, only color data will be decoded.",n),this.mergerCreationFailed=!0,this.decodeAlphaData(e);return}if(!this.alphaDecoder){const n=i=>{if(this.alphaDecoderQueueSize--,this.colorQueue.length>0){const a=this.colorQueue.shift();m(a!==void 0),this.mergeAlpha(a,i)}else this.alphaQueue.push(i);for(this.decodedAlphaChunkCount++;this.nullAlphaFrameQueue.length>0&&this.nullAlphaFrameQueue[0]===this.decodedAlphaChunkCount;)if(this.nullAlphaFrameQueue.shift(),this.colorQueue.length>0){const a=this.colorQueue.shift();m(a!==void 0),this.mergeAlpha(a,null)}else this.alphaQueue.push(null)};this.alphaDecoder=new VideoDecoder({output:i=>{try{n(i)}catch(a){this.onError(a)}},error:this.onError}),this.alphaDecoder.configure(this.decoderConfig)}const r=yi(this.codec,this.decoderConfig,e.sideData.alpha);if(this.alphaHadKeyframe||(this.alphaHadKeyframe=r==="key"),this.alphaHadKeyframe){if(this.codec==="hevc"&&this.currentAlphaPacketIndex>0&&!this.alphaRaslSkipped){if(this.hasHevcRaslPicture(e.sideData.alpha)){this.pushNullAlphaFrame();return}this.alphaRaslSkipped=!0}this.currentAlphaPacketIndex++,this.alphaDecoder.decode(e.alphaToEncodedVideoChunk(r??e.type)),this.alphaDecoderQueueSize++}else this.pushNullAlphaFrame()}pushNullAlphaFrame(){this.alphaDecoderQueueSize===0?this.alphaQueue.push(null):this.nullAlphaFrameQueue.push(this.decodedAlphaChunkCount+this.alphaDecoderQueueSize)}hasHevcRaslPicture(e){return pi(e,this.decoderConfig).some(n=>{const i=Oe(n);return i===se.RASL_N||i===se.RASL_R})}sampleHandler(e){if(fr()){if(this.sampleQueue.length>0&&e.timestamp>=$(this.sampleQueue).timestamp){for(const r of this.sampleQueue)this.finalizeAndEmitSample(r);this.sampleQueue.length=0}He(this.sampleQueue,e,r=>r.timestamp)}else{const r=this.inputTimestamps.shift();m(r!==void 0),e.setTimestamp(r),this.finalizeAndEmitSample(e)}}finalizeAndEmitSample(e){e.setTimestamp(Math.round(e.timestamp*this.timeResolution)/this.timeResolution),e.setDuration(Math.round(e.duration*this.timeResolution)/this.timeResolution),e.setRotation(this.rotation),this.onSample(e)}mergeAlpha(e,r){if(!r){const a=new de(e);this.sampleHandler(a);return}m(this.merger),this.merger.update(e,r),e.close(),r.close();const n=new VideoFrame(this.merger.canvas,{timestamp:e.timestamp,duration:e.duration??void 0}),i=new de(n);this.sampleHandler(i)}async flush(){if(this.customDecoder?await this.customDecoderCallSerializer.call(()=>this.customDecoder.flush()):(m(this.decoder),await Promise.all([this.decoder.flush(),this.alphaDecoder?.flush()]),this.colorQueue.forEach(e=>e.close()),this.colorQueue.length=0,this.alphaQueue.forEach(e=>e?.close()),this.alphaQueue.length=0,this.alphaHadKeyframe=!1,this.decodedAlphaChunkCount=0,this.alphaDecoderQueueSize=0,this.nullAlphaFrameQueue.length=0,this.currentAlphaPacketIndex=0,this.alphaRaslSkipped=!1),fr()){for(const e of this.sampleQueue)this.finalizeAndEmitSample(e);this.sampleQueue.length=0}this.currentPacketIndex=0,this.raslSkipped=!1}close(){this.customDecoder?this.customDecoderCallSerializer.call(()=>this.customDecoder.close()):(m(this.decoder),this.decoder.close(),this.alphaDecoder?.close(),this.colorQueue.forEach(e=>e.close()),this.colorQueue.length=0,this.alphaQueue.forEach(e=>e?.close()),this.alphaQueue.length=0,this.merger?.close());for(const e of this.sampleQueue)e.close();this.sampleQueue.length=0}}class Zs{constructor(){typeof OffscreenCanvas<"u"?this.canvas=new OffscreenCanvas(300,150):this.canvas=document.createElement("canvas");const e=this.canvas.getContext("webgl2",{premultipliedAlpha:!1});if(!e)throw new Error("Couldn't acquire WebGL 2 context.");this.gl=e,this.program=this.createProgram(),this.vao=this.createVAO(),this.colorTexture=this.createTexture(),this.alphaTexture=this.createTexture(),this.gl.useProgram(this.program),this.gl.uniform1i(this.gl.getUniformLocation(this.program,"u_colorTexture"),0),this.gl.uniform1i(this.gl.getUniformLocation(this.program,"u_alphaTexture"),1)}createProgram(){const e=this.createShader(this.gl.VERTEX_SHADER,`#version 300 es
			in vec2 a_position;
			in vec2 a_texCoord;
			out vec2 v_texCoord;
			
			void main() {
				gl_Position = vec4(a_position, 0.0, 1.0);
				v_texCoord = a_texCoord;
			}
		`),r=this.createShader(this.gl.FRAGMENT_SHADER,`#version 300 es
			precision highp float;
			
			uniform sampler2D u_colorTexture;
			uniform sampler2D u_alphaTexture;
			in vec2 v_texCoord;
			out vec4 fragColor;
			
			void main() {
				vec3 color = texture(u_colorTexture, v_texCoord).rgb;
				float alpha = texture(u_alphaTexture, v_texCoord).r;
				fragColor = vec4(color, alpha);
			}
		`),n=this.gl.createProgram();return this.gl.attachShader(n,e),this.gl.attachShader(n,r),this.gl.linkProgram(n),n}createShader(e,r){const n=this.gl.createShader(e);return this.gl.shaderSource(n,r),this.gl.compileShader(n),n}createVAO(){const e=this.gl.createVertexArray();this.gl.bindVertexArray(e);const r=new Float32Array([-1,-1,0,1,1,-1,1,1,-1,1,0,0,1,1,1,0]),n=this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER,n),this.gl.bufferData(this.gl.ARRAY_BUFFER,r,this.gl.STATIC_DRAW);const i=this.gl.getAttribLocation(this.program,"a_position"),a=this.gl.getAttribLocation(this.program,"a_texCoord");return this.gl.enableVertexAttribArray(i),this.gl.vertexAttribPointer(i,2,this.gl.FLOAT,!1,16,0),this.gl.enableVertexAttribArray(a),this.gl.vertexAttribPointer(a,2,this.gl.FLOAT,!1,16,8),e}createTexture(){const e=this.gl.createTexture();return this.gl.bindTexture(this.gl.TEXTURE_2D,e),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR),e}update(e,r){(e.displayWidth!==this.canvas.width||e.displayHeight!==this.canvas.height)&&(this.canvas.width=e.displayWidth,this.canvas.height=e.displayHeight),this.gl.activeTexture(this.gl.TEXTURE0),this.gl.bindTexture(this.gl.TEXTURE_2D,this.colorTexture),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,e),this.gl.activeTexture(this.gl.TEXTURE1),this.gl.bindTexture(this.gl.TEXTURE_2D,this.alphaTexture),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,r),this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.gl.bindVertexArray(this.vao),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4)}close(){this.gl.getExtension("WEBGL_lose_context")?.loseContext(),this.gl=null}}class Mr extends Ci{constructor(e){if(!(e instanceof Ht))throw new TypeError("videoTrack must be an InputVideoTrack.");super(),this._track=e}async _createDecoder(e,r){if(!await this._track.canDecode())throw new Error("This video track cannot be decoded by this browser. Make sure to check decodability before using a track.");const n=this._track.codec,i=this._track.rotation,a=await this._track.getDecoderConfig(),s=this._track.timeResolution;return m(n&&a),new Ys(e,r,n,a,i,s)}_createPacketSink(){return new Ot(this._track)}async getSample(e){qe(e);for await(const r of this.mediaSamplesAtTimestamps([e]))return r;throw new Error("Internal error: Iterator returned nothing.")}samples(e=0,r=1/0){return this.mediaSamplesInRange(e,r)}samplesAtTimestamps(e){return this.mediaSamplesAtTimestamps(e)}}class Js{constructor(e,r={}){if(this._nextCanvasIndex=0,!(e instanceof Ht))throw new TypeError("videoTrack must be an InputVideoTrack.");if(r&&typeof r!="object")throw new TypeError("options must be an object.");if(r.alpha!==void 0&&typeof r.alpha!="boolean")throw new TypeError("options.alpha, when provided, must be a boolean.");if(r.width!==void 0&&(!Number.isInteger(r.width)||r.width<=0))throw new TypeError("options.width, when defined, must be a positive integer.");if(r.height!==void 0&&(!Number.isInteger(r.height)||r.height<=0))throw new TypeError("options.height, when defined, must be a positive integer.");if(r.fit!==void 0&&!["fill","contain","cover"].includes(r.fit))throw new TypeError('options.fit, when provided, must be one of "fill", "contain", or "cover".');if(r.width!==void 0&&r.height!==void 0&&r.fit===void 0)throw new TypeError("When both options.width and options.height are provided, options.fit must also be provided.");if(r.rotation!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError("options.rotation, when provided, must be 0, 90, 180 or 270.");if(r.crop!==void 0&&Jr(r.crop,"options."),r.poolSize!==void 0&&(typeof r.poolSize!="number"||!Number.isInteger(r.poolSize)||r.poolSize<0))throw new TypeError("poolSize must be a non-negative integer.");const n=r.rotation??e.rotation,[i,a]=n%180===0?[e.codedWidth,e.codedHeight]:[e.codedHeight,e.codedWidth],s=r.crop;s&&Zr(s,i,a);let[o,c]=s?[s.width,s.height]:[i,a];const l=o/c;r.width!==void 0&&r.height===void 0?(o=r.width,c=Math.round(o/l)):r.width===void 0&&r.height!==void 0?(c=r.height,o=Math.round(c*l)):r.width!==void 0&&r.height!==void 0&&(o=r.width,c=r.height),this._videoTrack=e,this._alpha=r.alpha??!1,this._width=o,this._height=c,this._rotation=n,this._crop=s,this._fit=r.fit??"fill",this._videoSampleSink=new Mr(e),this._canvasPool=Array.from({length:r.poolSize??0},()=>null)}_videoSampleToWrappedCanvas(e){let r=this._canvasPool[this._nextCanvasIndex],n=!1;r||(typeof document<"u"?(r=document.createElement("canvas"),r.width=this._width,r.height=this._height):r=new OffscreenCanvas(this._width,this._height),this._canvasPool.length>0&&(this._canvasPool[this._nextCanvasIndex]=r),n=!0),this._canvasPool.length>0&&(this._nextCanvasIndex=(this._nextCanvasIndex+1)%this._canvasPool.length);const i=r.getContext("2d",{alpha:this._alpha||Mt()});m(i),i.resetTransform(),n||(!this._alpha&&Mt()?(i.fillStyle="black",i.fillRect(0,0,this._width,this._height)):i.clearRect(0,0,this._width,this._height)),e.drawWithFit(i,{fit:this._fit,rotation:this._rotation,crop:this._crop});const a={canvas:r,timestamp:e.timestamp,duration:e.duration};return e.close(),a}async getCanvas(e){qe(e);const r=await this._videoSampleSink.getSample(e);return r&&this._videoSampleToWrappedCanvas(r)}canvases(e=0,r=1/0){return kn(this._videoSampleSink.samples(e,r),n=>this._videoSampleToWrappedCanvas(n))}canvasesAtTimestamps(e){return kn(this._videoSampleSink.samplesAtTimestamps(e),r=>r&&this._videoSampleToWrappedCanvas(r))}}class ea extends en{constructor(e,r,n,i){super(e,r),this.decoder=null,this.customDecoder=null,this.customDecoderCallSerializer=new ur,this.customDecoderQueueSize=0,this.currentTimestamp=null;const a=o=>{(this.currentTimestamp===null||Math.abs(o.timestamp-this.currentTimestamp)>=o.duration)&&(this.currentTimestamp=o.timestamp);const c=this.currentTimestamp;if(this.currentTimestamp+=o.duration,o.numberOfFrames===0){o.close();return}const l=i.sampleRate;o.setTimestamp(Math.round(c*l)/l),e(o)},s=xi.find(o=>o.supports(n,i));s?(this.customDecoder=new s,this.customDecoder.codec=n,this.customDecoder.config=i,this.customDecoder.onSample=o=>{if(!(o instanceof Se))throw new TypeError("The argument passed to onSample must be an AudioSample.");a(o)},this.customDecoderCallSerializer.call(()=>this.customDecoder.init())):(this.decoder=new AudioDecoder({output:o=>{try{a(new Se(o))}catch(c){this.onError(c)}},error:r}),this.decoder.configure(i))}getDecodeQueueSize(){return this.customDecoder?this.customDecoderQueueSize:(m(this.decoder),this.decoder.decodeQueueSize)}decode(e){this.customDecoder?(this.customDecoderQueueSize++,this.customDecoderCallSerializer.call(()=>this.customDecoder.decode(e)).then(()=>this.customDecoderQueueSize--)):(m(this.decoder),this.decoder.decode(e.toEncodedAudioChunk()))}flush(){return this.customDecoder?this.customDecoderCallSerializer.call(()=>this.customDecoder.flush()):(m(this.decoder),this.decoder.flush())}close(){this.customDecoder?this.customDecoderCallSerializer.call(()=>this.customDecoder.close()):(m(this.decoder),this.decoder.close())}}class ta extends en{constructor(e,r,n){super(e,r),this.decoderConfig=n,this.currentTimestamp=null,m(ne.includes(n.codec)),this.codec=n.codec;const{dataType:i,sampleSize:a,littleEndian:s}=Ke(this.codec);switch(this.inputSampleSize=a,a){case 1:i==="unsigned"?this.readInputValue=(o,c)=>o.getUint8(c)-2**7:i==="signed"?this.readInputValue=(o,c)=>o.getInt8(c):i==="ulaw"?this.readInputValue=(o,c)=>js(o.getUint8(c)):i==="alaw"?this.readInputValue=(o,c)=>Qs(o.getUint8(c)):m(!1);break;case 2:i==="unsigned"?this.readInputValue=(o,c)=>o.getUint16(c,s)-2**15:i==="signed"?this.readInputValue=(o,c)=>o.getInt16(c,s):m(!1);break;case 3:i==="unsigned"?this.readInputValue=(o,c)=>lr(o,c,s)-2**23:i==="signed"?this.readInputValue=(o,c)=>us(o,c,s):m(!1);break;case 4:i==="unsigned"?this.readInputValue=(o,c)=>o.getUint32(c,s)-2**31:i==="signed"?this.readInputValue=(o,c)=>o.getInt32(c,s):i==="float"?this.readInputValue=(o,c)=>o.getFloat32(c,s):m(!1);break;case 8:i==="float"?this.readInputValue=(o,c)=>o.getFloat64(c,s):m(!1);break;default:$e(a),m(!1)}switch(a){case 1:i==="ulaw"||i==="alaw"?(this.outputSampleSize=2,this.outputFormat="s16",this.writeOutputValue=(o,c,l)=>o.setInt16(c,l,!0)):(this.outputSampleSize=1,this.outputFormat="u8",this.writeOutputValue=(o,c,l)=>o.setUint8(c,l+2**7));break;case 2:this.outputSampleSize=2,this.outputFormat="s16",this.writeOutputValue=(o,c,l)=>o.setInt16(c,l,!0);break;case 3:this.outputSampleSize=4,this.outputFormat="s32",this.writeOutputValue=(o,c,l)=>o.setInt32(c,l<<8,!0);break;case 4:this.outputSampleSize=4,i==="float"?(this.outputFormat="f32",this.writeOutputValue=(o,c,l)=>o.setFloat32(c,l,!0)):(this.outputFormat="s32",this.writeOutputValue=(o,c,l)=>o.setInt32(c,l,!0));break;case 8:this.outputSampleSize=4,this.outputFormat="f32",this.writeOutputValue=(o,c,l)=>o.setFloat32(c,l,!0);break;default:$e(a),m(!1)}}getDecodeQueueSize(){return 0}decode(e){const r=te(e.data),n=e.byteLength/this.decoderConfig.numberOfChannels/this.inputSampleSize,i=n*this.decoderConfig.numberOfChannels*this.outputSampleSize,a=new ArrayBuffer(i),s=new DataView(a);for(let u=0;u<n*this.decoderConfig.numberOfChannels;u++){const d=u*this.inputSampleSize,h=u*this.outputSampleSize,f=this.readInputValue(r,d);this.writeOutputValue(s,h,f)}const o=n/this.decoderConfig.sampleRate;(this.currentTimestamp===null||Math.abs(e.timestamp-this.currentTimestamp)>=o)&&(this.currentTimestamp=e.timestamp);const c=this.currentTimestamp;this.currentTimestamp+=o;const l=new Se({format:this.outputFormat,data:a,numberOfChannels:this.decoderConfig.numberOfChannels,sampleRate:this.decoderConfig.sampleRate,numberOfFrames:n,timestamp:c});this.onSample(l)}async flush(){}close(){}}class En extends Ci{constructor(e){if(!(e instanceof ze))throw new TypeError("audioTrack must be an InputAudioTrack.");super(),this._track=e}async _createDecoder(e,r){if(!await this._track.canDecode())throw new Error("This audio track cannot be decoded by this browser. Make sure to check decodability before using a track.");const n=this._track.codec,i=await this._track.getDecoderConfig();return m(n&&i),ne.includes(i.codec)?new ta(e,r,i):new ea(e,r,n,i)}_createPacketSink(){return new Ot(this._track)}async getSample(e){qe(e);for await(const r of this.mediaSamplesAtTimestamps([e]))return r;throw new Error("Internal error: Iterator returned nothing.")}samples(e=0,r=1/0){return this.mediaSamplesInRange(e,r)}samplesAtTimestamps(e){return this.mediaSamplesAtTimestamps(e)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class tn{constructor(e,r){this.input=e,this._backing=r}isVideoTrack(){return this instanceof Ht}isAudioTrack(){return this instanceof ze}get id(){return this._backing.getId()}get internalCodecId(){return this._backing.getInternalCodecId()}get languageCode(){return this._backing.getLanguageCode()}get name(){return this._backing.getName()}get timeResolution(){return this._backing.getTimeResolution()}getFirstTimestamp(){return this._backing.getFirstTimestamp()}computeDuration(){return this._backing.computeDuration()}async computePacketStats(e=1/0){const r=new Ot(this);let n=1/0,i=-1/0,a=0,s=0;for await(const o of r.packets(void 0,void 0,{metadataOnly:!0})){if(a>=e&&o.timestamp>=i)break;n=Math.min(n,o.timestamp),i=Math.max(i,o.timestamp+o.duration),a++,s+=o.byteLength}return{packetCount:a,averagePacketRate:a?Number((a/(i-n)).toPrecision(16)):0,averageBitrate:a?Number((8*s/(i-n)).toPrecision(16)):0}}}class Ht extends tn{constructor(e,r){super(e,r),this._backing=r}get type(){return"video"}get codec(){return this._backing.getCodec()}get codedWidth(){return this._backing.getCodedWidth()}get codedHeight(){return this._backing.getCodedHeight()}get rotation(){return this._backing.getRotation()}get displayWidth(){return this._backing.getRotation()%180===0?this._backing.getCodedWidth():this._backing.getCodedHeight()}get displayHeight(){return this._backing.getRotation()%180===0?this._backing.getCodedHeight():this._backing.getCodedWidth()}getColorSpace(){return this._backing.getColorSpace()}async hasHighDynamicRange(){const e=await this._backing.getColorSpace();return e.primaries==="bt2020"||e.primaries==="smpte432"||e.transfer==="pg"||e.transfer==="hlg"||e.matrix==="bt2020-ncl"}canBeTransparent(){return this._backing.canBeTransparent()}getDecoderConfig(){return this._backing.getDecoderConfig()}async getCodecParameterString(){return(await this._backing.getDecoderConfig())?.codec??null}async canDecode(){try{const e=await this._backing.getDecoderConfig();if(!e)return!1;const r=this._backing.getCodec();return m(r!==null),Si.some(i=>i.supports(r,e))?!0:typeof VideoDecoder>"u"?!1:(await VideoDecoder.isConfigSupported(e)).supported===!0}catch(e){return console.error("Error during decodability check:",e),!1}}async determinePacketType(e){if(!(e instanceof H))throw new TypeError("packet must be an EncodedPacket.");if(e.isMetadataOnly)throw new TypeError("packet must not be metadata-only to determine its type.");if(this.codec===null)return null;const r=await this.getDecoderConfig();return m(r),yi(this.codec,r,e.data)}}class ze extends tn{constructor(e,r){super(e,r),this._backing=r}get type(){return"audio"}get codec(){return this._backing.getCodec()}get numberOfChannels(){return this._backing.getNumberOfChannels()}get sampleRate(){return this._backing.getSampleRate()}getDecoderConfig(){return this._backing.getDecoderConfig()}async getCodecParameterString(){return(await this._backing.getDecoderConfig())?.codec??null}async canDecode(){try{const e=await this._backing.getDecoderConfig();if(!e)return!1;const r=this._backing.getCodec();return m(r!==null),xi.some(n=>n.supports(r,e))||e.codec.startsWith("pcm-")?!0:typeof AudioDecoder>"u"?!1:(await AudioDecoder.isConfigSupported(e)).supported===!0}catch(e){return console.error("Error during decodability check:",e),!1}}async determinePacketType(e){if(!(e instanceof H))throw new TypeError("packet must be an EncodedPacket.");return this.codec===null?null:"key"}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Pi=t=>{let r=(t.hasVideo?"video/":t.hasAudio?"audio/":"application/")+(t.isQuickTime?"quicktime":"mp4");if(t.codecStrings.length>0){const n=[...new Set(t.codecStrings)];r+=`; codecs="${n.join(", ")}"`}return r};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const ge=8,Ne=16,_e=t=>{let e=E(t);const r=X(t,4);let n=8;e===1&&(e=pe(t),n=16);const a=e-n;return a<0?null:{name:r,totalSize:e,headerSize:n,contentSize:a}},Xe=t=>Ze(t)/65536,kr=t=>Ze(t)/1073741824,br=t=>{let e=0;for(let r=0;r<4;r++){e<<=7;const n=z(t);if(e|=n&127,(n&128)===0)break}return e},ke=t=>{let e=Z(t);return t.skip(2),e=Math.min(e,t.remainingLength),he.decode(O(t,e))},ra=t=>{const e=_e(t);if(!e||e.name!=="data")return null;const r=E(t);t.skip(4);const n=O(t,e.contentSize-8);switch(r){case 1:return he.decode(n);case 2:return new TextDecoder("utf-16be").decode(n);case 13:return new gt(n,"image/jpeg");case 14:return new gt(n,"image/png");case 27:return new gt(n,"image/bmp");default:return n}};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class na extends tt{constructor(e){super(e),this.moovSlice=null,this.currentTrack=null,this.tracks=[],this.metadataPromise=null,this.movieTimescale=-1,this.movieDurationInTimescale=-1,this.isQuickTime=!1,this.metadataTags={},this.currentMetadataKeys=null,this.isFragmented=!1,this.fragmentTrackDefaults=[],this.fragments=[],this.currentFragment=null,this.fragmentLookupMutex=new je,this.reader=e._reader}async computeDuration(){const e=await this.getTracks(),r=await Promise.all(e.map(n=>n.computeDuration()));return Math.max(0,...r)}async getTracks(){return await this.readMetadata(),this.tracks.map(e=>e.inputTrack)}async getMimeType(){await this.readMetadata();const e=await Promise.all(this.tracks.map(r=>r.inputTrack.getCodecParameterString()));return Pi({isQuickTime:this.isQuickTime,hasVideo:this.tracks.some(r=>r.info?.type==="video"),hasAudio:this.tracks.some(r=>r.info?.type==="audio"),codecStrings:e.filter(Boolean)})}async getMetadataTags(){return await this.readMetadata(),this.metadataTags}readMetadata(){return this.metadataPromise??=(async()=>{let e=0;for(;;){let r=this.reader.requestSliceRange(e,ge,Ne);if(r instanceof Promise&&(r=await r),!r)break;const n=e,i=_e(r);if(!i)break;if(i.name==="ftyp"){const a=X(r,4);this.isQuickTime=a==="qt  "}else if(i.name==="moov"){let a=this.reader.requestSlice(r.filePos,i.contentSize);if(a instanceof Promise&&(a=await a),!a)break;this.moovSlice=a,this.readContiguousBoxes(this.moovSlice);for(const s of this.tracks){const o=s.editListPreviousSegmentDurations/this.movieTimescale;s.editListOffset-=Math.round(o*s.timescale)}break}e=n+i.totalSize}if(this.isFragmented&&this.reader.fileSize!==null){let r=this.reader.requestSlice(this.reader.fileSize-4,4);r instanceof Promise&&(r=await r),m(r);const n=E(r),i=this.reader.fileSize-n;if(i>=0&&i<=this.reader.fileSize-Ne){let a=this.reader.requestSliceRange(i,ge,Ne);if(a instanceof Promise&&(a=await a),a){const s=_e(a);if(s&&s.name==="mfra"){let o=this.reader.requestSlice(a.filePos,s.contentSize);o instanceof Promise&&(o=await o),o&&this.readContiguousBoxes(o)}}}}})()}getSampleTableForTrack(e){if(e.sampleTable)return e.sampleTable;const r={sampleTimingEntries:[],sampleCompositionTimeOffsets:[],sampleSizes:[],keySampleIndices:null,chunkOffsets:[],sampleToChunk:[],presentationTimestamps:null,presentationTimestampIndexMap:null};e.sampleTable=r,m(this.moovSlice);const n=this.moovSlice.slice(e.sampleTableByteOffset);if(this.currentTrack=e,this.traverseBox(n),this.currentTrack=null,e.info?.type==="audio"&&e.info.codec&&ne.includes(e.info.codec)&&r.sampleCompositionTimeOffsets.length===0){m(e.info?.type==="audio");const a=Ke(e.info.codec),s=[],o=[];for(let c=0;c<r.sampleToChunk.length;c++){const l=r.sampleToChunk[c],u=r.sampleToChunk[c+1],d=(u?u.startChunkIndex:r.chunkOffsets.length)-l.startChunkIndex;for(let h=0;h<d;h++){const f=l.startSampleIndex+h*l.samplesPerChunk,p=f+l.samplesPerChunk,g=L(r.sampleTimingEntries,f,F=>F.startIndex),b=r.sampleTimingEntries[g],w=L(r.sampleTimingEntries,p,F=>F.startIndex),k=r.sampleTimingEntries[w],T=b.startDecodeTimestamp+(f-b.startIndex)*b.delta,x=k.startDecodeTimestamp+(p-k.startIndex)*k.delta-T,_=$(s);_&&_.delta===x?_.count++:s.push({startIndex:l.startChunkIndex+h,startDecodeTimestamp:T,count:1,delta:x});const C=l.samplesPerChunk*a.sampleSize*e.info.numberOfChannels;o.push(C)}l.startSampleIndex=l.startChunkIndex,l.samplesPerChunk=1}r.sampleTimingEntries=s,r.sampleSizes=o}if(r.sampleCompositionTimeOffsets.length>0){r.presentationTimestamps=[];for(const a of r.sampleTimingEntries)for(let s=0;s<a.count;s++)r.presentationTimestamps.push({presentationTimestamp:a.startDecodeTimestamp+s*a.delta,sampleIndex:a.startIndex+s});for(const a of r.sampleCompositionTimeOffsets)for(let s=0;s<a.count;s++){const o=a.startIndex+s,c=r.presentationTimestamps[o];c&&(c.presentationTimestamp+=a.offset)}r.presentationTimestamps.sort((a,s)=>a.presentationTimestamp-s.presentationTimestamp),r.presentationTimestampIndexMap=Array(r.presentationTimestamps.length).fill(-1);for(let a=0;a<r.presentationTimestamps.length;a++)r.presentationTimestampIndexMap[r.presentationTimestamps[a].sampleIndex]=a}return r}async readFragment(e){let r=this.reader.requestSliceRange(e,ge,Ne);r instanceof Promise&&(r=await r),m(r);const n=_e(r);m(n?.name==="moof");let i=this.reader.requestSlice(e,n.totalSize);i instanceof Promise&&(i=await i),m(i),this.traverseBox(i);const a=K(this.fragments,e,o=>o.moofOffset);m(a!==-1);const s=this.fragments[a];m(s.moofOffset===e);for(const[o,c]of s.trackData){if(c.startTimestampIsFinal)continue;const l=this.tracks.find(g=>g.id===o);let u=0,d=null,h=null;const f=L(l.fragments,e-1,g=>g.moofOffset);f!==-1&&(d=l.fragments[f],h=d,u=d.moofOffset+d.moofSize);let p=u===0;for(;u<=e-ge;){if(d?.nextFragment)d=d.nextFragment,u=d.moofOffset+d.moofSize;else{let g=this.reader.requestSliceRange(u,ge,Ne);if(g instanceof Promise&&(g=await g),!g)break;const b=u,w=_e(g);if(!w)break;if(w.name==="moof"){const k=K(this.fragments,b,y=>y.moofOffset);let T;k===-1?T=await this.readFragment(b):T=this.fragments[k],d&&(d.nextFragment=T),d=T,p&&(T.isKnownToBeFirstFragment=!0,p=!1)}u=b+w.totalSize}d&&d.trackData.has(o)&&(h=d)}if(h){const g=h.trackData.get(o);m(g.startTimestampIsFinal),Fn(c,g.endTimestamp)}c.startTimestampIsFinal=!0}return s}readContiguousBoxes(e){const r=e.filePos;for(;e.filePos-r<=e.length-ge&&this.traverseBox(e););}*iterateContiguousBoxes(e){const r=e.filePos;for(;e.filePos-r<=e.length-ge;){const n=e.filePos,i=_e(e);if(!i)break;yield{boxInfo:i,slice:e},e.filePos=n+i.totalSize}}traverseBox(e){const r=e.filePos,n=_e(e);if(!n)return!1;const i=e.filePos,a=r+n.totalSize;switch(n.name){case"mdia":case"minf":case"dinf":case"mfra":case"edts":this.readContiguousBoxes(e.slice(i,n.contentSize));break;case"mvhd":{const s=z(e);e.skip(3),s===1?(e.skip(16),this.movieTimescale=E(e),this.movieDurationInTimescale=pe(e)):(e.skip(8),this.movieTimescale=E(e),this.movieDurationInTimescale=E(e))}break;case"trak":{const s={id:-1,demuxer:this,inputTrack:null,info:null,timescale:-1,durationInMovieTimescale:-1,durationInMediaTimescale:-1,rotation:0,internalCodecId:null,name:null,languageCode:ue,sampleTableByteOffset:-1,sampleTable:null,fragmentLookupTable:null,currentFragmentState:null,fragments:[],fragmentsWithKeyFrame:[],editListPreviousSegmentDurations:0,editListOffset:0};if(this.currentTrack=s,this.readContiguousBoxes(e.slice(i,n.contentSize)),s.id!==-1&&s.timescale!==-1&&s.info!==null){if(s.info.type==="video"&&s.info.width!==-1){const o=s;s.inputTrack=new Ht(this.input,new ia(o)),this.tracks.push(s)}else if(s.info.type==="audio"&&s.info.numberOfChannels!==-1){const o=s;s.inputTrack=new ze(this.input,new sa(o)),this.tracks.push(s)}}this.currentTrack=null}break;case"tkhd":{const s=this.currentTrack;if(!s)break;const o=z(e);if(!((dt(e)&1)!==0))break;if(o===0)e.skip(8),s.id=E(e),e.skip(4),s.durationInMovieTimescale=E(e);else if(o===1)e.skip(16),s.id=E(e),e.skip(4),s.durationInMovieTimescale=pe(e);else throw new Error(`Incorrect track header version ${o}.`);e.skip(2*4+2+2+2+2);const u=[Xe(e),Xe(e),kr(e),Xe(e),Xe(e),kr(e),Xe(e),Xe(e),kr(e)],d=Xr(hs(la(u),90));m(d===0||d===90||d===180||d===270),s.rotation=d}break;case"elst":{const s=this.currentTrack;if(!s)break;const o=z(e);e.skip(3);let c=!1,l=0;const u=E(e);for(let d=0;d<u;d++){const h=o===1?pe(e):E(e),f=o===1?wo(e):Ze(e),p=Xe(e);if(h!==0){if(c){console.warn("Unsupported edit list: multiple edits are not currently supported. Only using first edit.");break}if(f===-1){l+=h;continue}if(p!==1){console.warn("Unsupported edit list entry: media rate must be 1.");break}s.editListPreviousSegmentDurations=l,s.editListOffset=f,c=!0}}}break;case"mdhd":{const s=this.currentTrack;if(!s)break;const o=z(e);e.skip(3),o===0?(e.skip(8),s.timescale=E(e),s.durationInMediaTimescale=E(e)):o===1&&(e.skip(16),s.timescale=E(e),s.durationInMediaTimescale=pe(e));let c=Z(e);if(c>0){s.languageCode="";for(let l=0;l<3;l++)s.languageCode=String.fromCharCode(96+(c&31))+s.languageCode,c>>=5;Dt(s.languageCode)||(s.languageCode=ue)}}break;case"hdlr":{const s=this.currentTrack;if(!s)break;e.skip(8);const o=X(e,4);o==="vide"?s.info={type:"video",width:-1,height:-1,codec:null,codecDescription:null,colorSpace:null,avcCodecInfo:null,hevcCodecInfo:null,vp9CodecInfo:null,av1CodecInfo:null}:o==="soun"&&(s.info={type:"audio",numberOfChannels:-1,sampleRate:-1,codec:null,codecDescription:null,aacCodecInfo:null})}break;case"stbl":{const s=this.currentTrack;if(!s)break;s.sampleTableByteOffset=r,this.readContiguousBoxes(e.slice(i,n.contentSize))}break;case"stsd":{const s=this.currentTrack;if(!s||s.info===null||s.sampleTable)break;const o=z(e);e.skip(3);const c=E(e);for(let l=0;l<c;l++){const u=e.filePos,d=_e(e);if(!d)break;s.internalCodecId=d.name;const h=d.name.toLowerCase();if(s.info.type==="video")h==="avc1"?s.info.codec="avc":h==="hvc1"||h==="hev1"?s.info.codec="hevc":h==="vp08"?s.info.codec="vp8":h==="vp09"?s.info.codec="vp9":h==="av01"?s.info.codec="av1":console.warn(`Unsupported video codec (sample entry type '${d.name}').`),e.skip(6*1+2+2+2+3*4),s.info.width=Z(e),s.info.height=Z(e),e.skip(50),this.readContiguousBoxes(e.slice(e.filePos,u+d.totalSize-e.filePos));else{h==="mp4a"||(h==="opus"?s.info.codec="opus":h==="flac"?s.info.codec="flac":h==="twos"||h==="sowt"||h==="raw "||h==="in24"||h==="in32"||h==="fl32"||h==="fl64"||h==="lpcm"||h==="ipcm"||h==="fpcm"||(h==="ulaw"?s.info.codec="ulaw":h==="alaw"?s.info.codec="alaw":console.warn(`Unsupported audio codec (sample entry type '${d.name}').`))),e.skip(6*1+2);const f=Z(e);e.skip(3*2);let p=Z(e),g=Z(e);e.skip(2*2);let b=E(e)/65536;if(o===0&&f>0){if(f===1)e.skip(4),g=8*E(e),e.skip(2*4);else if(f===2){e.skip(4),b=Li(e),p=E(e),e.skip(4),g=E(e);const w=E(e);if(e.skip(2*4),h==="lpcm"){const k=g+7>>3,T=!!(w&1),y=!!(w&2),x=w&4?-1:0;g>0&&g<=64&&(T?g===32&&(s.info.codec=y?"pcm-f32be":"pcm-f32"):x&1<<k-1?k===1?s.info.codec="pcm-s8":k===2?s.info.codec=y?"pcm-s16be":"pcm-s16":k===3?s.info.codec=y?"pcm-s24be":"pcm-s24":k===4&&(s.info.codec=y?"pcm-s32be":"pcm-s32"):k===1&&(s.info.codec="pcm-u8")),s.info.codec===null&&console.warn("Unsupported PCM format.")}}}s.info.codec==="opus"&&(b=dr),s.info.numberOfChannels=p,s.info.sampleRate=b,h==="twos"?g===8?s.info.codec="pcm-s8":g===16?s.info.codec="pcm-s16be":(console.warn(`Unsupported sample size ${g} for codec 'twos'.`),s.info.codec=null):h==="sowt"?g===8?s.info.codec="pcm-s8":g===16?s.info.codec="pcm-s16":(console.warn(`Unsupported sample size ${g} for codec 'sowt'.`),s.info.codec=null):h==="raw "?s.info.codec="pcm-u8":h==="in24"?s.info.codec="pcm-s24be":h==="in32"?s.info.codec="pcm-s32be":h==="fl32"?s.info.codec="pcm-f32be":h==="fl64"?s.info.codec="pcm-f64be":h==="ipcm"?s.info.codec="pcm-s16be":h==="fpcm"&&(s.info.codec="pcm-f32be"),this.readContiguousBoxes(e.slice(e.filePos,u+d.totalSize-e.filePos))}}}break;case"avcC":{const s=this.currentTrack;if(!s)break;m(s.info),s.info.codecDescription=O(e,n.contentSize)}break;case"hvcC":{const s=this.currentTrack;if(!s)break;m(s.info),s.info.codecDescription=O(e,n.contentSize)}break;case"vpcC":{const s=this.currentTrack;if(!s)break;m(s.info?.type==="video"),e.skip(4);const o=z(e),c=z(e),l=z(e),u=l>>4,d=l>>1&7,h=l&1,f=z(e),p=z(e),g=z(e);s.info.vp9CodecInfo={profile:o,level:c,bitDepth:u,chromaSubsampling:d,videoFullRangeFlag:h,colourPrimaries:f,transferCharacteristics:p,matrixCoefficients:g}}break;case"av1C":{const s=this.currentTrack;if(!s)break;m(s.info?.type==="video"),e.skip(1);const o=z(e),c=o>>5,l=o&31,u=z(e),d=u>>7,h=u>>6&1,f=u>>5&1,p=u>>4&1,g=u>>3&1,b=u>>2&1,w=u&3,k=c===2&&h?f?12:10:h?10:8;s.info.av1CodecInfo={profile:c,level:l,tier:d,bitDepth:k,monochrome:p,chromaSubsamplingX:g,chromaSubsamplingY:b,chromaSamplePosition:w}}break;case"colr":{const s=this.currentTrack;if(!s||(m(s.info?.type==="video"),X(e,4)!=="nclx"))break;const c=Z(e),l=Z(e),u=Z(e),d=!!(z(e)&128);s.info.colorSpace={primaries:Zn[c],transfer:Jn[l],matrix:ei[u],fullRange:d}}break;case"wave":this.readContiguousBoxes(e.slice(i,n.contentSize));break;case"esds":{const s=this.currentTrack;if(!s)break;m(s.info?.type==="audio"),e.skip(4);const o=z(e);m(o===3),br(e),e.skip(2);const c=z(e),l=(c&128)!==0,u=(c&64)!==0,d=(c&32)!==0;if(l&&e.skip(2),u){const b=z(e);e.skip(b)}d&&e.skip(2);const h=z(e);m(h===4);const f=br(e),p=e.filePos,g=z(e);if(g===64||g===103?(s.info.codec="aac",s.info.aacCodecInfo={isMpeg2:g===103}):g===105||g===107?s.info.codec="mp3":g===221?s.info.codec="vorbis":console.warn(`Unsupported audio codec (objectTypeIndication ${g}) - discarding track.`),e.skip(12),f>e.filePos-p){const b=z(e);m(b===5);const w=br(e);if(s.info.codecDescription=O(e,w),s.info.codec==="aac"){const k=ui(s.info.codecDescription);k.numberOfChannels!==null&&(s.info.numberOfChannels=k.numberOfChannels),k.sampleRate!==null&&(s.info.sampleRate=k.sampleRate)}}}break;case"enda":{const s=this.currentTrack;if(!s)break;m(s.info?.type==="audio"),Z(e)&255&&(s.info.codec==="pcm-s16be"?s.info.codec="pcm-s16":s.info.codec==="pcm-s24be"?s.info.codec="pcm-s24":s.info.codec==="pcm-s32be"?s.info.codec="pcm-s32":s.info.codec==="pcm-f32be"?s.info.codec="pcm-f32":s.info.codec==="pcm-f64be"&&(s.info.codec="pcm-f64"))}break;case"pcmC":{const s=this.currentTrack;if(!s)break;m(s.info?.type==="audio"),e.skip(4);const c=!!(z(e)&1),l=z(e);s.info.codec==="pcm-s16be"?c?l===16?s.info.codec="pcm-s16":l===24?s.info.codec="pcm-s24":l===32?s.info.codec="pcm-s32":(console.warn(`Invalid ipcm sample size ${l}.`),s.info.codec=null):l===16?s.info.codec="pcm-s16be":l===24?s.info.codec="pcm-s24be":l===32?s.info.codec="pcm-s32be":(console.warn(`Invalid ipcm sample size ${l}.`),s.info.codec=null):s.info.codec==="pcm-f32be"&&(c?l===32?s.info.codec="pcm-f32":l===64?s.info.codec="pcm-f64":(console.warn(`Invalid fpcm sample size ${l}.`),s.info.codec=null):l===32?s.info.codec="pcm-f32be":l===64?s.info.codec="pcm-f64be":(console.warn(`Invalid fpcm sample size ${l}.`),s.info.codec=null));break}case"dOps":{const s=this.currentTrack;if(!s)break;m(s.info?.type==="audio"),e.skip(1);const o=z(e),c=Z(e),l=E(e),u=qr(e),d=z(e);let h;d!==0?h=O(e,2+o):h=new Uint8Array(0);const f=new Uint8Array(19+h.byteLength),p=new DataView(f.buffer);p.setUint32(0,1332770163,!1),p.setUint32(4,1214603620,!1),p.setUint8(8,1),p.setUint8(9,o),p.setUint16(10,c,!0),p.setUint32(12,l,!0),p.setInt16(16,u,!0),p.setUint8(18,d),f.set(h,19),s.info.codecDescription=f,s.info.numberOfChannels=o}break;case"dfLa":{const s=this.currentTrack;if(!s)break;m(s.info?.type==="audio"),e.skip(4);const o=127,c=128,l=e.filePos;for(;e.filePos<a;){const p=z(e),g=dt(e);if((p&o)===bt.STREAMINFO){e.skip(10);const w=E(e),k=w>>>12,T=(w>>9&7)+1;s.info.sampleRate=k,s.info.numberOfChannels=T,e.skip(20)}else e.skip(g);if(p&c)break}const u=e.filePos;e.filePos=l;const d=O(e,u-l),h=new Uint8Array(4+d.byteLength);new DataView(h.buffer).setUint32(0,1716281667,!1),h.set(d,4),s.info.codecDescription=h}break;case"stts":{const s=this.currentTrack;if(!s||!s.sampleTable)break;e.skip(4);const o=E(e);let c=0,l=0;for(let u=0;u<o;u++){const d=E(e),h=E(e);s.sampleTable.sampleTimingEntries.push({startIndex:c,startDecodeTimestamp:l,count:d,delta:h}),c+=d,l+=d*h}}break;case"ctts":{const s=this.currentTrack;if(!s||!s.sampleTable)break;e.skip(4);const o=E(e);let c=0;for(let l=0;l<o;l++){const u=E(e),d=Ze(e);s.sampleTable.sampleCompositionTimeOffsets.push({startIndex:c,count:u,offset:d}),c+=u}}break;case"stsz":{const s=this.currentTrack;if(!s||!s.sampleTable)break;e.skip(4);const o=E(e),c=E(e);if(o===0)for(let l=0;l<c;l++){const u=E(e);s.sampleTable.sampleSizes.push(u)}else s.sampleTable.sampleSizes.push(o)}break;case"stz2":{const s=this.currentTrack;if(!s||!s.sampleTable)break;e.skip(4),e.skip(3);const o=z(e),c=E(e),l=O(e,Math.ceil(c*o/8)),u=new j(l);for(let d=0;d<c;d++){const h=u.readBits(o);s.sampleTable.sampleSizes.push(h)}}break;case"stss":{const s=this.currentTrack;if(!s||!s.sampleTable)break;e.skip(4),s.sampleTable.keySampleIndices=[];const o=E(e);for(let c=0;c<o;c++){const l=E(e)-1;s.sampleTable.keySampleIndices.push(l)}s.sampleTable.keySampleIndices[0]!==0&&s.sampleTable.keySampleIndices.unshift(0)}break;case"stsc":{const s=this.currentTrack;if(!s||!s.sampleTable)break;e.skip(4);const o=E(e);for(let l=0;l<o;l++){const u=E(e)-1,d=E(e),h=E(e);s.sampleTable.sampleToChunk.push({startSampleIndex:-1,startChunkIndex:u,samplesPerChunk:d,sampleDescriptionIndex:h})}let c=0;for(let l=0;l<s.sampleTable.sampleToChunk.length;l++)if(s.sampleTable.sampleToChunk[l].startSampleIndex=c,l<s.sampleTable.sampleToChunk.length-1){const d=s.sampleTable.sampleToChunk[l+1].startChunkIndex-s.sampleTable.sampleToChunk[l].startChunkIndex;c+=d*s.sampleTable.sampleToChunk[l].samplesPerChunk}}break;case"stco":{const s=this.currentTrack;if(!s||!s.sampleTable)break;e.skip(4);const o=E(e);for(let c=0;c<o;c++){const l=E(e);s.sampleTable.chunkOffsets.push(l)}}break;case"co64":{const s=this.currentTrack;if(!s||!s.sampleTable)break;e.skip(4);const o=E(e);for(let c=0;c<o;c++){const l=pe(e);s.sampleTable.chunkOffsets.push(l)}}break;case"mvex":this.isFragmented=!0,this.readContiguousBoxes(e.slice(i,n.contentSize));break;case"mehd":{const s=z(e);e.skip(3);const o=s===1?pe(e):E(e);this.movieDurationInTimescale=o}break;case"trex":{e.skip(4);const s=E(e),o=E(e),c=E(e),l=E(e),u=E(e);this.fragmentTrackDefaults.push({trackId:s,defaultSampleDescriptionIndex:o,defaultSampleDuration:c,defaultSampleSize:l,defaultSampleFlags:u})}break;case"tfra":{const s=z(e);e.skip(3);const o=E(e),c=this.tracks.find(k=>k.id===o);if(!c)break;c.fragmentLookupTable=[];const l=E(e),u=(l&48)>>4,d=(l&12)>>2,h=l&3,f=[z,Z,dt,E],p=f[u],g=f[d],b=f[h],w=E(e);for(let k=0;k<w;k++){const T=s===1?pe(e):E(e),y=s===1?pe(e):E(e);p(e),g(e),b(e),c.fragmentLookupTable.push({timestamp:T,moofOffset:y})}}break;case"moof":{this.currentFragment={moofOffset:r,moofSize:n.totalSize,implicitBaseDataOffset:r,trackData:new Map,dataStart:1/0,dataEnd:0,nextFragment:null,isKnownToBeFirstFragment:!1},this.readContiguousBoxes(e.slice(i,n.contentSize)),He(this.fragments,this.currentFragment,s=>s.moofOffset);for(const[,s]of this.currentFragment.trackData){const o=s.samples[0],c=$(s.samples);this.currentFragment.dataStart=Math.min(this.currentFragment.dataStart,o.byteOffset),this.currentFragment.dataEnd=Math.max(this.currentFragment.dataEnd,c.byteOffset+c.byteSize)}this.currentFragment=null}break;case"traf":if(m(this.currentFragment),this.readContiguousBoxes(e.slice(i,n.contentSize)),this.currentTrack){const s=this.currentFragment.trackData.get(this.currentTrack.id);if(s){He(this.currentTrack.fragments,this.currentFragment,l=>l.moofOffset),s.firstKeyFrameTimestamp!==null&&He(this.currentTrack.fragmentsWithKeyFrame,this.currentFragment,l=>l.moofOffset);const{currentFragmentState:c}=this.currentTrack;m(c),c.startTimestamp!==null&&(Fn(s,c.startTimestamp),s.startTimestampIsFinal=!0)}this.currentTrack.currentFragmentState=null,this.currentTrack=null}break;case"tfhd":{m(this.currentFragment),e.skip(1);const s=dt(e),o=!!(s&1),c=!!(s&2),l=!!(s&8),u=!!(s&16),d=!!(s&32),h=!!(s&65536),f=!!(s&131072),p=E(e),g=this.tracks.find(w=>w.id===p);if(!g)break;const b=this.fragmentTrackDefaults.find(w=>w.trackId===p);this.currentTrack=g,g.currentFragmentState={baseDataOffset:this.currentFragment.implicitBaseDataOffset,sampleDescriptionIndex:b?.defaultSampleDescriptionIndex??null,defaultSampleDuration:b?.defaultSampleDuration??null,defaultSampleSize:b?.defaultSampleSize??null,defaultSampleFlags:b?.defaultSampleFlags??null,startTimestamp:null},o?g.currentFragmentState.baseDataOffset=pe(e):f&&(g.currentFragmentState.baseDataOffset=this.currentFragment.moofOffset),c&&(g.currentFragmentState.sampleDescriptionIndex=E(e)),l&&(g.currentFragmentState.defaultSampleDuration=E(e)),u&&(g.currentFragmentState.defaultSampleSize=E(e)),d&&(g.currentFragmentState.defaultSampleFlags=E(e)),h&&(g.currentFragmentState.defaultSampleDuration=0)}break;case"tfdt":{const s=this.currentTrack;if(!s)break;m(s.currentFragmentState);const o=z(e);e.skip(3);const c=o===0?E(e):pe(e);s.currentFragmentState.startTimestamp=c}break;case"trun":{const s=this.currentTrack;if(!s)break;if(m(this.currentFragment),m(s.currentFragmentState),this.currentFragment.trackData.has(s.id)){console.warn("Can't have two trun boxes for the same track in one fragment. Ignoring...");break}const o=z(e),c=dt(e),l=!!(c&1),u=!!(c&4),d=!!(c&256),h=!!(c&512),f=!!(c&1024),p=!!(c&2048),g=E(e);let b=s.currentFragmentState.baseDataOffset;l&&(b+=Ze(e));let w=null;u&&(w=E(e));let k=b;if(g===0){this.currentFragment.implicitBaseDataOffset=k;break}let T=0;const y={startTimestamp:0,endTimestamp:0,firstKeyFrameTimestamp:null,samples:[],presentationTimestamps:[],startTimestampIsFinal:!1};this.currentFragment.trackData.set(s.id,y);for(let C=0;C<g;C++){let F;d?F=E(e):(m(s.currentFragmentState.defaultSampleDuration!==null),F=s.currentFragmentState.defaultSampleDuration);let v;h?v=E(e):(m(s.currentFragmentState.defaultSampleSize!==null),v=s.currentFragmentState.defaultSampleSize);let I;f?I=E(e):(m(s.currentFragmentState.defaultSampleFlags!==null),I=s.currentFragmentState.defaultSampleFlags),C===0&&w!==null&&(I=w);let A=0;p&&(o===0?A=E(e):A=Ze(e));const M=!(I&65536);y.samples.push({presentationTimestamp:T+A,duration:F,byteOffset:k,byteSize:v,isKeyFrame:M}),k+=v,T+=F}y.presentationTimestamps=y.samples.map((C,F)=>({presentationTimestamp:C.presentationTimestamp,sampleIndex:F})).sort((C,F)=>C.presentationTimestamp-F.presentationTimestamp);for(let C=0;C<y.presentationTimestamps.length;C++){const F=y.presentationTimestamps[C],v=y.samples[F.sampleIndex];if(y.firstKeyFrameTimestamp===null&&v.isKeyFrame&&(y.firstKeyFrameTimestamp=v.presentationTimestamp),C<y.presentationTimestamps.length-1){const I=y.presentationTimestamps[C+1];v.duration=I.presentationTimestamp-F.presentationTimestamp}}const x=y.samples[y.presentationTimestamps[0].sampleIndex],_=y.samples[$(y.presentationTimestamps).sampleIndex];y.startTimestamp=x.presentationTimestamp,y.endTimestamp=_.presentationTimestamp+_.duration,this.currentFragment.implicitBaseDataOffset=k}break;case"udta":{const s=this.iterateContiguousBoxes(e.slice(i,n.contentSize));for(const{boxInfo:o,slice:c}of s){if(o.name!=="meta"&&!this.currentTrack){const l=c.filePos;this.metadataTags.raw??={},o.name[0]===""?this.metadataTags.raw[o.name]??=ke(c):this.metadataTags.raw[o.name]??=O(c,o.contentSize),c.filePos=l}switch(o.name){case"meta":c.skip(-o.headerSize),this.traverseBox(c);break;case"nam":case"name":this.currentTrack?this.currentTrack.name=he.decode(O(c,o.contentSize)):this.metadataTags.title??=ke(c);break;case"des":this.currentTrack||(this.metadataTags.description??=ke(c));break;case"ART":this.currentTrack||(this.metadataTags.artist??=ke(c));break;case"alb":this.currentTrack||(this.metadataTags.album??=ke(c));break;case"albr":this.currentTrack||(this.metadataTags.albumArtist??=ke(c));break;case"gen":this.currentTrack||(this.metadataTags.genre??=ke(c));break;case"day":if(!this.currentTrack){const l=new Date(ke(c));Number.isNaN(l.getTime())||(this.metadataTags.date??=l)}break;case"cmt":this.currentTrack||(this.metadataTags.comment??=ke(c));break;case"lyr":this.currentTrack||(this.metadataTags.lyrics??=ke(c));break}}}break;case"meta":{if(this.currentTrack)break;const o=E(e)!==0;this.currentMetadataKeys=new Map,o?this.readContiguousBoxes(e.slice(i,n.contentSize)):this.readContiguousBoxes(e.slice(i+4,n.contentSize-4)),this.currentMetadataKeys=null}break;case"keys":{if(!this.currentMetadataKeys)break;e.skip(4);const s=E(e);for(let o=0;o<s;o++){const c=E(e);e.skip(4);const l=he.decode(O(e,c-8));this.currentMetadataKeys.set(o+1,l)}}break;case"ilst":{if(!this.currentMetadataKeys)break;const s=this.iterateContiguousBoxes(e.slice(i,n.contentSize));for(const{boxInfo:o,slice:c}of s){let l=o.name;const u=(l.charCodeAt(0)<<24)+(l.charCodeAt(1)<<16)+(l.charCodeAt(2)<<8)+l.charCodeAt(3);this.currentMetadataKeys.has(u)&&(l=this.currentMetadataKeys.get(u));const d=ra(c);switch(this.metadataTags.raw??={},this.metadataTags.raw[l]??=d,l){case"nam":case"titl":case"com.apple.quicktime.title":case"title":typeof d=="string"&&(this.metadataTags.title??=d);break;case"des":case"desc":case"dscp":case"com.apple.quicktime.description":case"description":typeof d=="string"&&(this.metadataTags.description??=d);break;case"ART":case"com.apple.quicktime.artist":case"artist":typeof d=="string"&&(this.metadataTags.artist??=d);break;case"alb":case"albm":case"com.apple.quicktime.album":case"album":typeof d=="string"&&(this.metadataTags.album??=d);break;case"aART":case"album_artist":typeof d=="string"&&(this.metadataTags.albumArtist??=d);break;case"cmt":case"com.apple.quicktime.comment":case"comment":typeof d=="string"&&(this.metadataTags.comment??=d);break;case"gen":case"gnre":case"com.apple.quicktime.genre":case"genre":typeof d=="string"&&(this.metadataTags.genre??=d);break;case"lyr":case"lyrics":typeof d=="string"&&(this.metadataTags.lyrics??=d);break;case"day":case"rldt":case"com.apple.quicktime.creationdate":case"date":if(typeof d=="string"){const h=new Date(d);Number.isNaN(h.getTime())||(this.metadataTags.date??=h)}break;case"covr":case"com.apple.quicktime.artwork":d instanceof gt?(this.metadataTags.images??=[],this.metadataTags.images.push({data:d.data,kind:"coverFront",mimeType:d.mimeType})):d instanceof Uint8Array&&(this.metadataTags.images??=[],this.metadataTags.images.push({data:d,kind:"coverFront",mimeType:"image/*"}));break;case"track":if(typeof d=="string"){const h=d.split("/"),f=Number.parseInt(h[0],10),p=h[1]&&Number.parseInt(h[1],10);Number.isInteger(f)&&f>0&&(this.metadataTags.trackNumber??=f),p&&Number.isInteger(p)&&p>0&&(this.metadataTags.tracksTotal??=p)}break;case"trkn":if(d instanceof Uint8Array&&d.length>=6){const h=te(d),f=h.getUint16(2,!1),p=h.getUint16(4,!1);f>0&&(this.metadataTags.trackNumber??=f),p>0&&(this.metadataTags.tracksTotal??=p)}break;case"disc":case"disk":if(d instanceof Uint8Array&&d.length>=6){const h=te(d),f=h.getUint16(2,!1),p=h.getUint16(4,!1);f>0&&(this.metadataTags.discNumber??=f),p>0&&(this.metadataTags.discsTotal??=p)}break}}}break}return e.filePos=a,!0}}class vi{constructor(e){this.internalTrack=e,this.packetToSampleIndex=new WeakMap,this.packetToFragmentLocation=new WeakMap}getId(){return this.internalTrack.id}getCodec(){throw new Error("Not implemented on base class.")}getInternalCodecId(){return this.internalTrack.internalCodecId}getName(){return this.internalTrack.name}getLanguageCode(){return this.internalTrack.languageCode}getTimeResolution(){return this.internalTrack.timescale}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}async getFirstTimestamp(){return(await this.getFirstPacket({metadataOnly:!0}))?.timestamp??0}async getFirstPacket(e){const r=await this.fetchPacketForSampleIndex(0,e);return r||!this.internalTrack.demuxer.isFragmented?r:this.performFragmentedLookup(()=>{const n=this.internalTrack.demuxer.fragments[0]??null;if(n?.isKnownToBeFirstFragment){let i=n;for(;i;){if(i.trackData.get(this.internalTrack.id))return{fragmentIndex:K(this.internalTrack.fragments,i.moofOffset,s=>s.moofOffset),sampleIndex:0,correctSampleFound:!0};i=i.nextFragment}}return{fragmentIndex:-1,sampleIndex:-1,correctSampleFound:!1}},-1/0,1/0,e)}mapTimestampIntoTimescale(e){return Jt(e*this.internalTrack.timescale,14)+this.internalTrack.editListOffset}async getPacket(e,r){const n=this.mapTimestampIntoTimescale(e),i=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),a=In(i,n),s=await this.fetchPacketForSampleIndex(a,r);return!An(i)||!this.internalTrack.demuxer.isFragmented?s:this.performFragmentedLookup(()=>this.findSampleInFragmentsForTimestamp(n),n,n,r)}async getNextPacket(e,r){const n=this.packetToSampleIndex.get(e);if(n!==void 0)return this.fetchPacketForSampleIndex(n+1,r);const i=this.packetToFragmentLocation.get(e);if(i===void 0)throw new Error("Packet was not created from this track.");const a=i.fragment.trackData.get(this.internalTrack.id),s=K(this.internalTrack.fragments,i.fragment.moofOffset,o=>o.moofOffset);return m(s!==-1),this.performFragmentedLookup(()=>{if(i.sampleIndex+1<a.samples.length)return{fragmentIndex:s,sampleIndex:i.sampleIndex+1,correctSampleFound:!0};{let o=i.fragment;for(;o.nextFragment;)if(o=o.nextFragment,o.trackData.get(this.internalTrack.id)){const l=K(this.internalTrack.fragments,o.moofOffset,u=>u.moofOffset);return m(l!==-1),{fragmentIndex:l,sampleIndex:0,correctSampleFound:!0}}return{fragmentIndex:s,sampleIndex:-1,correctSampleFound:!1}}},-1/0,1/0,r)}async getKeyPacket(e,r){const n=this.mapTimestampIntoTimescale(e),i=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),a=In(i,n),s=a===-1?-1:oa(i,a),o=await this.fetchPacketForSampleIndex(s,r);return!An(i)||!this.internalTrack.demuxer.isFragmented?o:this.performFragmentedLookup(()=>this.findKeySampleInFragmentsForTimestamp(n),n,n,r)}async getNextKeyPacket(e,r){const n=this.packetToSampleIndex.get(e);if(n!==void 0){const o=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),c=ca(o,n);return this.fetchPacketForSampleIndex(c,r)}const i=this.packetToFragmentLocation.get(e);if(i===void 0)throw new Error("Packet was not created from this track.");const a=i.fragment.trackData.get(this.internalTrack.id),s=K(this.internalTrack.fragments,i.fragment.moofOffset,o=>o.moofOffset);return m(s!==-1),this.performFragmentedLookup(()=>{const o=a.samples.findIndex((c,l)=>c.isKeyFrame&&l>i.sampleIndex);if(o!==-1)return{fragmentIndex:s,sampleIndex:o,correctSampleFound:!0};{let c=i.fragment;for(;c.nextFragment;){c=c.nextFragment;const l=c.trackData.get(this.internalTrack.id);if(l&&l.firstKeyFrameTimestamp!==null){const u=K(this.internalTrack.fragments,c.moofOffset,h=>h.moofOffset);m(u!==-1);const d=l.samples.findIndex(h=>h.isKeyFrame);return m(d!==-1),{fragmentIndex:u,sampleIndex:d,correctSampleFound:!0}}}return{fragmentIndex:s,sampleIndex:-1,correctSampleFound:!1}}},-1/0,1/0,r)}async fetchPacketForSampleIndex(e,r){if(e===-1)return null;const n=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),i=aa(n,e);if(!i)return null;let a;if(r.metadataOnly)a=fe;else{let l=this.internalTrack.demuxer.reader.requestSlice(i.sampleOffset,i.sampleSize);l instanceof Promise&&(l=await l),m(l),a=O(l,i.sampleSize)}const s=(i.presentationTimestamp-this.internalTrack.editListOffset)/this.internalTrack.timescale,o=i.duration/this.internalTrack.timescale,c=new H(a,i.isKeyFrame?"key":"delta",s,o,e,i.sampleSize);return this.packetToSampleIndex.set(c,e),c}async fetchPacketInFragment(e,r,n){if(r===-1)return null;const a=e.trackData.get(this.internalTrack.id).samples[r];m(a);let s;if(n.metadataOnly)s=fe;else{let u=this.internalTrack.demuxer.reader.requestSlice(a.byteOffset,a.byteSize);u instanceof Promise&&(u=await u),m(u),s=O(u,a.byteSize)}const o=(a.presentationTimestamp-this.internalTrack.editListOffset)/this.internalTrack.timescale,c=a.duration/this.internalTrack.timescale,l=new H(s,a.isKeyFrame?"key":"delta",o,c,e.moofOffset+r,a.byteSize);return this.packetToFragmentLocation.set(l,{fragment:e,sampleIndex:r}),l}findSampleInFragmentsForTimestamp(e){const r=L(this.internalTrack.fragments,e,a=>a.trackData.get(this.internalTrack.id).startTimestamp);let n=-1,i=!1;if(r!==-1){const s=this.internalTrack.fragments[r].trackData.get(this.internalTrack.id),o=L(s.presentationTimestamps,e,c=>c.presentationTimestamp);m(o!==-1),n=s.presentationTimestamps[o].sampleIndex,i=e<s.endTimestamp}return{fragmentIndex:r,sampleIndex:n,correctSampleFound:i}}findKeySampleInFragmentsForTimestamp(e){const r=L(this.internalTrack.fragmentsWithKeyFrame,e,s=>s.trackData.get(this.internalTrack.id).startTimestamp);let n=-1,i=-1,a=!1;if(r!==-1){const s=this.internalTrack.fragmentsWithKeyFrame[r];n=K(this.internalTrack.fragments,s.moofOffset,u=>u.moofOffset),m(n!==-1);const o=s.trackData.get(this.internalTrack.id),c=ri(o.presentationTimestamps,u=>o.samples[u.sampleIndex].isKeyFrame&&u.presentationTimestamp<=e);m(c!==-1),i=o.presentationTimestamps[c].sampleIndex,a=e<o.endTimestamp}return{fragmentIndex:n,sampleIndex:i,correctSampleFound:a}}async performFragmentedLookup(e,r,n,i){const a=this.internalTrack.demuxer,s=await a.fragmentLookupMutex.acquire();try{const{fragmentIndex:o,sampleIndex:c,correctSampleFound:l}=e();if(l){const k=this.internalTrack.fragments[o];return this.fetchPacketInFragment(k,c,i)}let u=null,d=o,h=c;const f=this.internalTrack.fragmentLookupTable?L(this.internalTrack.fragmentLookupTable,r,k=>k.timestamp):-1,p=f!==-1?this.internalTrack.fragmentLookupTable[f]:null;let g,b=!1;if(o===-1)g=p?.moofOffset??0,b=g===0;else{const k=this.internalTrack.fragments[o];!p||k.moofOffset>=p.moofOffset?(g=k.moofOffset+k.moofSize,u=k):g=p.moofOffset}for(;;){if(u){const x=u.trackData.get(this.internalTrack.id);if(x&&x.startTimestamp>n)break;if(u.nextFragment){g=u.nextFragment.moofOffset+u.nextFragment.moofSize,u=u.nextFragment;continue}}let k=a.reader.requestSliceRange(g,ge,Ne);if(k instanceof Promise&&(k=await k),!k)break;const T=g,y=_e(k);if(!y)break;if(y.name==="moof"){const x=K(a.fragments,T,I=>I.moofOffset);let _;x===-1?_=await a.readFragment(T):_=a.fragments[x],u&&(u.nextFragment=_),u=_,b&&(_.isKnownToBeFirstFragment=!0,b=!1);const{fragmentIndex:C,sampleIndex:F,correctSampleFound:v}=e();if(v){const I=this.internalTrack.fragments[C];return this.fetchPacketInFragment(I,F,i)}C!==-1&&(d=C,h=F)}g=T+y.totalSize}const w=d!==-1?this.internalTrack.fragments[d]:null;if(p&&(!w||w.moofOffset<p.moofOffset)){const T=this.internalTrack.fragmentLookupTable[f-1]?.timestamp??-1/0;return this.performFragmentedLookup(e,T,n,i)}return w?this.fetchPacketInFragment(w,h,i):null}finally{s()}}}class ia extends vi{constructor(e){super(e),this.decoderConfigPromise=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getCodedWidth(){return this.internalTrack.info.width}getCodedHeight(){return this.internalTrack.info.height}getRotation(){return this.internalTrack.rotation}async getColorSpace(){return{primaries:this.internalTrack.info.colorSpace?.primaries,transfer:this.internalTrack.info.colorSpace?.transfer,matrix:this.internalTrack.info.colorSpace?.matrix,fullRange:this.internalTrack.info.colorSpace?.fullRange}}async canBeTransparent(){return!1}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfigPromise??=(async()=>{if(this.internalTrack.info.codec==="vp9"&&!this.internalTrack.info.vp9CodecInfo){const e=await this.getFirstPacket({});this.internalTrack.info.vp9CodecInfo=e&&ki(e.data)}else if(this.internalTrack.info.codec==="av1"&&!this.internalTrack.info.av1CodecInfo){const e=await this.getFirstPacket({});this.internalTrack.info.av1CodecInfo=e&&wi(e.data)}return{codec:oi(this.internalTrack.info),codedWidth:this.internalTrack.info.width,codedHeight:this.internalTrack.info.height,description:this.internalTrack.info.codecDescription??void 0,colorSpace:this.internalTrack.info.colorSpace??void 0}})():null}}class sa extends vi{constructor(e){super(e),this.decoderConfig=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getNumberOfChannels(){return this.internalTrack.info.numberOfChannels}getSampleRate(){return this.internalTrack.info.sampleRate}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfig??={codec:ci(this.internalTrack.info),numberOfChannels:this.internalTrack.info.numberOfChannels,sampleRate:this.internalTrack.info.sampleRate,description:this.internalTrack.info.codecDescription??void 0}:null}}const In=(t,e)=>{if(t.presentationTimestamps){const r=L(t.presentationTimestamps,e,n=>n.presentationTimestamp);return r===-1?-1:t.presentationTimestamps[r].sampleIndex}else{const r=L(t.sampleTimingEntries,e,i=>i.startDecodeTimestamp);if(r===-1)return-1;const n=t.sampleTimingEntries[r];return n.startIndex+Math.min(Math.floor((e-n.startDecodeTimestamp)/n.delta),n.count-1)}},aa=(t,e)=>{const r=L(t.sampleTimingEntries,e,w=>w.startIndex),n=t.sampleTimingEntries[r];if(!n||n.startIndex+n.count<=e)return null;let a=n.startDecodeTimestamp+(e-n.startIndex)*n.delta;const s=L(t.sampleCompositionTimeOffsets,e,w=>w.startIndex),o=t.sampleCompositionTimeOffsets[s];o&&e-o.startIndex<o.count&&(a+=o.offset);const c=t.sampleSizes[Math.min(e,t.sampleSizes.length-1)],l=L(t.sampleToChunk,e,w=>w.startSampleIndex),u=t.sampleToChunk[l];m(u);const d=u.startChunkIndex+Math.floor((e-u.startSampleIndex)/u.samplesPerChunk),h=t.chunkOffsets[d],f=u.startSampleIndex+(d-u.startChunkIndex)*u.samplesPerChunk;let p=0,g=h;if(t.sampleSizes.length===1)g+=c*(e-f),p+=c*u.samplesPerChunk;else for(let w=f;w<f+u.samplesPerChunk;w++){const k=t.sampleSizes[w];w<e&&(g+=k),p+=k}let b=n.delta;if(t.presentationTimestamps){const w=t.presentationTimestampIndexMap[e];m(w!==void 0),w<t.presentationTimestamps.length-1&&(b=t.presentationTimestamps[w+1].presentationTimestamp-a)}return{presentationTimestamp:a,duration:b,sampleOffset:g,sampleSize:c,chunkOffset:h,chunkSize:p,isKeyFrame:t.keySampleIndices?K(t.keySampleIndices,e,w=>w)!==-1:!0}},oa=(t,e)=>{if(!t.keySampleIndices)return e;const r=L(t.keySampleIndices,e,n=>n);return t.keySampleIndices[r]??-1},ca=(t,e)=>{if(!t.keySampleIndices)return e+1;const r=L(t.keySampleIndices,e,n=>n);return t.keySampleIndices[r+1]??-1},Fn=(t,e)=>{t.startTimestamp+=e,t.endTimestamp+=e;for(const r of t.samples)r.presentationTimestamp+=e;for(const r of t.presentationTimestamps)r.presentationTimestamp+=e},la=t=>{const[e,,,r]=t,n=Math.hypot(e,r),i=e/n,a=r/n,s=-Math.atan2(a,i)*(180/Math.PI);return Number.isFinite(s)?s:0},An=t=>t.sampleSizes.length===0;/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */var S;(function(t){t[t.EBML=440786851]="EBML",t[t.EBMLVersion=17030]="EBMLVersion",t[t.EBMLReadVersion=17143]="EBMLReadVersion",t[t.EBMLMaxIDLength=17138]="EBMLMaxIDLength",t[t.EBMLMaxSizeLength=17139]="EBMLMaxSizeLength",t[t.DocType=17026]="DocType",t[t.DocTypeVersion=17031]="DocTypeVersion",t[t.DocTypeReadVersion=17029]="DocTypeReadVersion",t[t.Void=236]="Void",t[t.Segment=408125543]="Segment",t[t.SeekHead=290298740]="SeekHead",t[t.Seek=19899]="Seek",t[t.SeekID=21419]="SeekID",t[t.SeekPosition=21420]="SeekPosition",t[t.Duration=17545]="Duration",t[t.Info=357149030]="Info",t[t.TimestampScale=2807729]="TimestampScale",t[t.MuxingApp=19840]="MuxingApp",t[t.WritingApp=22337]="WritingApp",t[t.Tracks=374648427]="Tracks",t[t.TrackEntry=174]="TrackEntry",t[t.TrackNumber=215]="TrackNumber",t[t.TrackUID=29637]="TrackUID",t[t.TrackType=131]="TrackType",t[t.FlagEnabled=185]="FlagEnabled",t[t.FlagDefault=136]="FlagDefault",t[t.FlagForced=21930]="FlagForced",t[t.FlagLacing=156]="FlagLacing",t[t.Name=21358]="Name",t[t.Language=2274716]="Language",t[t.LanguageBCP47=2274717]="LanguageBCP47",t[t.CodecID=134]="CodecID",t[t.CodecPrivate=25506]="CodecPrivate",t[t.CodecDelay=22186]="CodecDelay",t[t.SeekPreRoll=22203]="SeekPreRoll",t[t.DefaultDuration=2352003]="DefaultDuration",t[t.Video=224]="Video",t[t.PixelWidth=176]="PixelWidth",t[t.PixelHeight=186]="PixelHeight",t[t.AlphaMode=21440]="AlphaMode",t[t.Audio=225]="Audio",t[t.SamplingFrequency=181]="SamplingFrequency",t[t.Channels=159]="Channels",t[t.BitDepth=25188]="BitDepth",t[t.SimpleBlock=163]="SimpleBlock",t[t.BlockGroup=160]="BlockGroup",t[t.Block=161]="Block",t[t.BlockAdditions=30113]="BlockAdditions",t[t.BlockMore=166]="BlockMore",t[t.BlockAdditional=165]="BlockAdditional",t[t.BlockAddID=238]="BlockAddID",t[t.BlockDuration=155]="BlockDuration",t[t.ReferenceBlock=251]="ReferenceBlock",t[t.Cluster=524531317]="Cluster",t[t.Timestamp=231]="Timestamp",t[t.Cues=475249515]="Cues",t[t.CuePoint=187]="CuePoint",t[t.CueTime=179]="CueTime",t[t.CueTrackPositions=183]="CueTrackPositions",t[t.CueTrack=247]="CueTrack",t[t.CueClusterPosition=241]="CueClusterPosition",t[t.Colour=21936]="Colour",t[t.MatrixCoefficients=21937]="MatrixCoefficients",t[t.TransferCharacteristics=21946]="TransferCharacteristics",t[t.Primaries=21947]="Primaries",t[t.Range=21945]="Range",t[t.Projection=30320]="Projection",t[t.ProjectionType=30321]="ProjectionType",t[t.ProjectionPoseRoll=30325]="ProjectionPoseRoll",t[t.Attachments=423732329]="Attachments",t[t.AttachedFile=24999]="AttachedFile",t[t.FileDescription=18046]="FileDescription",t[t.FileName=18030]="FileName",t[t.FileMediaType=18016]="FileMediaType",t[t.FileData=18012]="FileData",t[t.FileUID=18094]="FileUID",t[t.Chapters=272869232]="Chapters",t[t.Tags=307544935]="Tags",t[t.Tag=29555]="Tag",t[t.Targets=25536]="Targets",t[t.TargetTypeValue=26826]="TargetTypeValue",t[t.TargetType=25546]="TargetType",t[t.TagTrackUID=25541]="TagTrackUID",t[t.TagEditionUID=25545]="TagEditionUID",t[t.TagChapterUID=25540]="TagChapterUID",t[t.TagAttachmentUID=25542]="TagAttachmentUID",t[t.SimpleTag=26568]="SimpleTag",t[t.TagName=17827]="TagName",t[t.TagLanguage=17530]="TagLanguage",t[t.TagString=17543]="TagString",t[t.TagBinary=17541]="TagBinary",t[t.ContentEncodings=28032]="ContentEncodings",t[t.ContentEncoding=25152]="ContentEncoding",t[t.ContentEncodingOrder=20529]="ContentEncodingOrder",t[t.ContentEncodingScope=20530]="ContentEncodingScope",t[t.ContentCompression=20532]="ContentCompression",t[t.ContentCompAlgo=16980]="ContentCompAlgo",t[t.ContentCompSettings=16981]="ContentCompSettings",t[t.ContentEncryption=20533]="ContentEncryption"})(S||(S={}));const ua=[S.EBML,S.Segment],Nt=[S.SeekHead,S.Info,S.Cluster,S.Tracks,S.Cues,S.Attachments,S.Chapters,S.Tags],Or=[...ua,...Nt],Nr=8,le=2,Be=2*Nr,_i=t=>{const e=z(t);if(t.skip(-1),e===0)return null;let r=1,n=128;for(;(e&n)===0;)r++,n>>=1;return r},It=t=>{const e=z(t);if(e===0)return null;let r=1,n=128;for(;(e&n)===0;)r++,n>>=1;let i=e&n-1;for(let a=1;a<r;a++)i*=256,i+=z(t);return i},V=(t,e)=>{if(e<1||e>8)throw new Error("Bad unsigned int size "+e);let r=0;for(let n=0;n<e;n++)r*=256,r+=z(t);return r},da=(t,e)=>{if(e<1)throw new Error("Bad unsigned int size "+e);let r=0n;for(let n=0;n<e;n++)r<<=8n,r+=BigInt(z(t));return r},ha=(t,e)=>{let r=V(t,e);return r&1<<e*8-1&&(r-=2**(e*8)),r},rn=t=>{const e=_i(t);return e===null?null:V(t,e)},Ei=t=>{let e=z(t);return e===255?e=null:(t.skip(-1),e=It(t),e===72057594037927940&&(e=null)),e},Fe=t=>{const e=rn(t);if(e===null)return null;const r=Ei(t);return{id:e,size:r}},ut=(t,e)=>{const r=O(t,e);let n=0;for(;n<e&&r[n]!==0;)n+=1;return String.fromCharCode(...r.subarray(0,n))},Pt=(t,e)=>{const r=O(t,e);let n=0;for(;n<e&&r[n]!==0;)n+=1;return he.decode(r.subarray(0,n))},wr=(t,e)=>{if(e===0)return 0;if(e!==4&&e!==8)throw new Error("Bad float size "+e);return e===4?yo(t):Li(t)},Vr=async(t,e,r,n)=>{const i=new Set(r);let a=e;for(;n===null||a<n;){let s=t.requestSliceRange(a,le,Be);if(s instanceof Promise&&(s=await s),!s)break;const o=Fe(s);if(!o)break;if(i.has(o.id))return{pos:a,found:!0};Me(o.size),a=s.filePos+o.size}return{pos:n!==null&&n>a?n:a,found:!1}},Ii=async(t,e,r,n)=>{const a=new Set(r);let s=e;for(;s<n;){let o=t.requestSliceRange(s,0,Math.min(65536,n-s));if(o instanceof Promise&&(o=await o),!o||o.length<Nr)break;for(let c=0;c<o.length-Nr;c++){o.filePos=s;const l=rn(o);if(l!==null&&a.has(l))return s;s++}}return null},be={avc:"V_MPEG4/ISO/AVC",hevc:"V_MPEGH/ISO/HEVC",vp8:"V_VP8",vp9:"V_VP9",av1:"V_AV1",aac:"A_AAC",mp3:"A_MPEG/L3",opus:"A_OPUS",vorbis:"A_VORBIS",flac:"A_FLAC"};function Me(t){if(t===null)throw new Error("Undefined element size is used in a place where it is not supported.")}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const fa=t=>{let r=(t.hasVideo?"video/":t.hasAudio?"audio/":"application/")+(t.isWebM?"webm":"x-matroska");if(t.codecStrings.length>0){const n=[...new Set(t.codecStrings.filter(Boolean))];r+=`; codecs="${n.join(", ")}"`}return r};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */var Ee;(function(t){t[t.None=0]="None",t[t.Xiph=1]="Xiph",t[t.FixedSize=2]="FixedSize",t[t.Ebml=3]="Ebml"})(Ee||(Ee={}));var rr;(function(t){t[t.Block=1]="Block",t[t.Private=2]="Private",t[t.Next=4]="Next"})(rr||(rr={}));var Bt;(function(t){t[t.Zlib=0]="Zlib",t[t.Bzlib=1]="Bzlib",t[t.lzo1x=2]="lzo1x",t[t.HeaderStripping=3]="HeaderStripping"})(Bt||(Bt={}));const Tr=[{id:S.SeekHead,flag:"seekHeadSeen"},{id:S.Info,flag:"infoSeen"},{id:S.Tracks,flag:"tracksSeen"},{id:S.Cues,flag:"cuesSeen"}],Fi=10*2**20;class ma extends tt{constructor(e){super(e),this.readMetadataPromise=null,this.segments=[],this.currentSegment=null,this.currentTrack=null,this.currentCluster=null,this.currentBlock=null,this.currentBlockAdditional=null,this.currentCueTime=null,this.currentDecodingInstruction=null,this.currentTagTargetIsMovie=!0,this.currentSimpleTagName=null,this.currentAttachedFile=null,this.isWebM=!1,this.reader=e._reader}async computeDuration(){const e=await this.getTracks(),r=await Promise.all(e.map(n=>n.computeDuration()));return Math.max(0,...r)}async getTracks(){return await this.readMetadata(),this.segments.flatMap(e=>e.tracks.map(r=>r.inputTrack))}async getMimeType(){await this.readMetadata();const e=await this.getTracks(),r=await Promise.all(e.map(n=>n.getCodecParameterString()));return fa({isWebM:this.isWebM,hasVideo:this.segments.some(n=>n.tracks.some(i=>i.info?.type==="video")),hasAudio:this.segments.some(n=>n.tracks.some(i=>i.info?.type==="audio")),codecStrings:r.filter(Boolean)})}async getMetadataTags(){await this.readMetadata();for(const r of this.segments)r.metadataTagsCollected||(this.reader.fileSize!==null&&await this.loadSegmentMetadata(r),r.metadataTagsCollected=!0);let e={};for(const r of this.segments)e={...e,...r.metadataTags};return e}readMetadata(){return this.readMetadataPromise??=(async()=>{let e=0;for(;;){let r=this.reader.requestSliceRange(e,le,Be);if(r instanceof Promise&&(r=await r),!r)break;const n=Fe(r);if(!n)break;const i=n.id;let a=n.size;const s=r.filePos;if(i===S.EBML){Me(a);let o=this.reader.requestSlice(s,a);if(o instanceof Promise&&(o=await o),!o)break;this.readContiguousElements(o)}else if(i===S.Segment){if(await this.readSegment(s,a),a===null||this.reader.fileSize===null)break}else if(i===S.Cluster){if(this.reader.fileSize===null)break;a===null&&(a=(await Vr(this.reader,s,Or,this.reader.fileSize)).pos-s);const o=$(this.segments);o&&(o.elementEndPos=s+a)}Me(a),e=s+a}})()}async readSegment(e,r){this.currentSegment={seekHeadSeen:!1,infoSeen:!1,tracksSeen:!1,cuesSeen:!1,tagsSeen:!1,attachmentsSeen:!1,timestampScale:-1,timestampFactor:-1,duration:-1,seekEntries:[],tracks:[],cuePoints:[],dataStartPos:e,elementEndPos:r===null?null:e+r,clusterSeekStartPos:e,clusters:[],clusterLookupMutex:new je,metadataTags:{},metadataTagsCollected:!1},this.segments.push(this.currentSegment);let n=e;for(;this.currentSegment.elementEndPos===null||n<this.currentSegment.elementEndPos;){let c=this.reader.requestSliceRange(n,le,Be);if(c instanceof Promise&&(c=await c),!c)break;const l=n,u=Fe(c);if(!u||!Nt.includes(u.id)&&u.id!==S.Void){const g=await Ii(this.reader,l,Nt,Math.min(this.currentSegment.elementEndPos??1/0,l+Fi));if(g){n=g;continue}else break}const{id:d,size:h}=u,f=c.filePos,p=Tr.findIndex(g=>g.id===d);if(p!==-1){const g=Tr[p].flag;this.currentSegment[g]=!0,Me(h);let b=this.reader.requestSlice(f,h);b instanceof Promise&&(b=await b),b&&this.readContiguousElements(b)}else if(d===S.Tags||d===S.Attachments){d===S.Tags?this.currentSegment.tagsSeen=!0:this.currentSegment.attachmentsSeen=!0,Me(h);let g=this.reader.requestSlice(f,h);g instanceof Promise&&(g=await g),g&&this.readContiguousElements(g)}else if(d===S.Cluster){this.currentSegment.clusterSeekStartPos=l;break}if(h===null)break;n=f+h}if(this.currentSegment.seekEntries.sort((c,l)=>c.segmentPosition-l.segmentPosition),this.reader.fileSize!==null)for(const c of this.currentSegment.seekEntries){const l=Tr.find(g=>g.id===c.id);if(!l||this.currentSegment[l.flag])continue;let u=this.reader.requestSliceRange(e+c.segmentPosition,le,Be);if(u instanceof Promise&&(u=await u),!u)continue;const d=Fe(u);if(!d)continue;const{id:h,size:f}=d;if(h!==l.id)continue;Me(f),this.currentSegment[l.flag]=!0;let p=this.reader.requestSlice(u.filePos,f);p instanceof Promise&&(p=await p),p&&this.readContiguousElements(p)}this.currentSegment.timestampScale===-1&&(this.currentSegment.timestampScale=1e6,this.currentSegment.timestampFactor=1e9/1e6),this.currentSegment.tracks.sort((c,l)=>Number(l.isDefault)-Number(c.isDefault)),this.currentSegment.cuePoints.sort((c,l)=>c.clusterPosition-l.clusterPosition);const i=this.currentSegment.tracks.map(c=>c.id),a=new Set;let s=null,o=null;for(const c of this.currentSegment.cuePoints){if(c.clusterPosition!==s){for(const u of a)m(o),this.currentSegment.tracks.find(h=>h.id===u).cuePoints.push(o);for(const u of i)a.add(u)}if(o=c,!a.has(c.trackId))continue;this.currentSegment.tracks.find(u=>u.id===c.trackId).cuePoints.push(c),a.delete(c.trackId),s=c.clusterPosition}for(const c of a)m(o),this.currentSegment.tracks.find(u=>u.id===c).cuePoints.push(o);for(const c of this.currentSegment.tracks)c.cuePoints.sort((l,u)=>l.time-u.time);this.currentSegment=null}async readCluster(e,r){let n=this.reader.requestSliceRange(e,le,Be);n instanceof Promise&&(n=await n),m(n);const i=e,a=Fe(n);m(a);const s=a.id;let o=a.size;const c=n.filePos;o===null&&(o=(await Vr(this.reader,c,Or,r.elementEndPos)).pos-c),m(s===S.Cluster);let l=this.reader.requestSlice(c,o);l instanceof Promise&&(l=await l);const u={segment:r,elementStartPos:i,elementEndPos:c+o,dataStartPos:c,timestamp:-1,trackData:new Map,nextCluster:null,isKnownToBeFirstCluster:!1};this.currentCluster=u,l&&this.readContiguousElements(l);for(const[,d]of u.trackData){const h=d.track;m(d.blocks.length>0);let f=!1,p=!1;for(let k=0;k<d.blocks.length;k++){const T=d.blocks[k];T.timestamp+=u.timestamp,f||=T.referencedTimestamps.length>0,p||=T.lacing!==Ee.None}f&&(d.blocks=ka(d.blocks)),d.presentationTimestamps=d.blocks.map((k,T)=>({timestamp:k.timestamp,blockIndex:T})).sort((k,T)=>k.timestamp-T.timestamp);for(let k=0;k<d.presentationTimestamps.length;k++){const T=d.presentationTimestamps[k],y=d.blocks[T.blockIndex];if(d.firstKeyFrameTimestamp===null&&y.isKeyFrame&&(d.firstKeyFrameTimestamp=y.timestamp),k<d.presentationTimestamps.length-1){const x=d.presentationTimestamps[k+1];y.duration=x.timestamp-y.timestamp}else y.duration===0&&h.defaultDuration!=null&&y.lacing===Ee.None&&(y.duration=h.defaultDuration)}p&&(this.expandLacedBlocks(d.blocks,h),d.presentationTimestamps=d.blocks.map((k,T)=>({timestamp:k.timestamp,blockIndex:T})).sort((k,T)=>k.timestamp-T.timestamp));const g=d.blocks[d.presentationTimestamps[0].blockIndex],b=d.blocks[$(d.presentationTimestamps).blockIndex];d.startTimestamp=g.timestamp,d.endTimestamp=b.timestamp+b.duration,He(h.clusters,u,k=>k.elementStartPos),d.firstKeyFrameTimestamp!==null&&He(h.clustersWithKeyFrame,u,k=>k.elementStartPos)}return He(r.clusters,u,d=>d.elementStartPos),this.currentCluster=null,u}getTrackDataInCluster(e,r){let n=e.trackData.get(r);if(!n){const i=e.segment.tracks.find(a=>a.id===r);if(!i)return null;n={track:i,startTimestamp:0,endTimestamp:0,firstKeyFrameTimestamp:null,blocks:[],presentationTimestamps:[]},e.trackData.set(r,n)}return n}expandLacedBlocks(e,r){for(let n=0;n<e.length;n++){const i=e[n];if(i.lacing===Ee.None)continue;i.decoded||(i.data=this.decodeBlockData(r,i.data),i.decoded=!0);const a=yt.tempFromBytes(i.data),s=[],o=z(a)+1;switch(i.lacing){case Ee.Xiph:{let c=0;for(let l=0;l<o-1;l++){let u=0;for(;a.bufferPos<a.length;){const d=z(a);if(u+=d,d<255){s.push(u),c+=u;break}}}s.push(a.length-(a.bufferPos+c))}break;case Ee.FixedSize:{const c=a.length-1,l=Math.floor(c/o);for(let u=0;u<o;u++)s.push(l)}break;case Ee.Ebml:{const c=It(a);m(c!==null);let l=c;s.push(l);let u=l;for(let d=1;d<o-1;d++){const h=a.bufferPos,f=It(a);m(f!==null);const p=f,b=(1<<(a.bufferPos-h)*7-1)-1,w=p-b;l+=w,s.push(l),u+=l}s.push(a.length-(a.bufferPos+u))}break;default:m(!1)}m(s.length===o),e.splice(n,1);for(let c=0;c<o;c++){const l=s[c],u=O(a,l),d=i.duration||o*(r.defaultDuration??0),h=i.timestamp+d*c/o,f=d/o;e.splice(n+c,0,{timestamp:h,duration:f,isKeyFrame:i.isKeyFrame,referencedTimestamps:i.referencedTimestamps,data:u,lacing:Ee.None,decoded:!0,mainAdditional:i.mainAdditional})}n+=o,n--}}async loadSegmentMetadata(e){for(const r of e.seekEntries){if(!(r.id===S.Tags&&!e.tagsSeen)){if(!(r.id===S.Attachments&&!e.attachmentsSeen))continue}let n=this.reader.requestSliceRange(e.dataStartPos+r.segmentPosition,le,Be);if(n instanceof Promise&&(n=await n),!n)continue;const i=Fe(n);if(!i||i.id!==r.id)continue;const{size:a}=i;Me(a),m(!this.currentSegment),this.currentSegment=e;let s=this.reader.requestSlice(n.filePos,a);s instanceof Promise&&(s=await s),s&&this.readContiguousElements(s),this.currentSegment=null,r.id===S.Tags?e.tagsSeen=!0:r.id===S.Attachments&&(e.attachmentsSeen=!0)}}readContiguousElements(e){const r=e.filePos;for(;e.filePos-r<=e.length-le&&this.traverseElement(e););}traverseElement(e){const r=Fe(e);if(!r)return!1;const{id:n,size:i}=r,a=e.filePos;switch(Me(i),n){case S.DocType:this.isWebM=ut(e,i)==="webm";break;case S.Seek:{if(!this.currentSegment)break;const s={id:-1,segmentPosition:-1};this.currentSegment.seekEntries.push(s),this.readContiguousElements(e.slice(a,i)),(s.id===-1||s.segmentPosition===-1)&&this.currentSegment.seekEntries.pop()}break;case S.SeekID:{const s=this.currentSegment?.seekEntries[this.currentSegment.seekEntries.length-1];if(!s)break;s.id=V(e,i)}break;case S.SeekPosition:{const s=this.currentSegment?.seekEntries[this.currentSegment.seekEntries.length-1];if(!s)break;s.segmentPosition=V(e,i)}break;case S.TimestampScale:{if(!this.currentSegment)break;this.currentSegment.timestampScale=V(e,i),this.currentSegment.timestampFactor=1e9/this.currentSegment.timestampScale}break;case S.Duration:{if(!this.currentSegment)break;this.currentSegment.duration=wr(e,i)}break;case S.TrackEntry:{if(!this.currentSegment)break;if(this.currentTrack={id:-1,segment:this.currentSegment,demuxer:this,clusters:[],clustersWithKeyFrame:[],cuePoints:[],isDefault:!1,inputTrack:null,codecId:null,codecPrivate:null,defaultDuration:null,name:null,languageCode:ue,decodingInstructions:[],info:null},this.readContiguousElements(e.slice(a,i)),this.currentTrack.decodingInstructions.some(s=>s.data?.type!=="decompress"||s.scope!==rr.Block||s.data.algorithm!==Bt.HeaderStripping)&&(console.warn(`Track #${this.currentTrack.id} has an unsupported content encoding; dropping.`),this.currentTrack=null),this.currentTrack&&this.currentTrack.id!==-1&&this.currentTrack.codecId&&this.currentTrack.info){const s=this.currentTrack.codecId.indexOf("/"),o=s===-1?this.currentTrack.codecId:this.currentTrack.codecId.slice(0,s);if(this.currentTrack.info.type==="video"&&this.currentTrack.info.width!==-1&&this.currentTrack.info.height!==-1){this.currentTrack.codecId===be.avc?(this.currentTrack.info.codec="avc",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):this.currentTrack.codecId===be.hevc?(this.currentTrack.info.codec="hevc",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):o===be.vp8?this.currentTrack.info.codec="vp8":o===be.vp9?this.currentTrack.info.codec="vp9":o===be.av1&&(this.currentTrack.info.codec="av1");const c=this.currentTrack,l=new Ht(this.input,new pa(c));this.currentTrack.inputTrack=l,this.currentSegment.tracks.push(this.currentTrack)}else if(this.currentTrack.info.type==="audio"&&this.currentTrack.info.numberOfChannels!==-1&&this.currentTrack.info.sampleRate!==-1){o===be.aac?(this.currentTrack.info.codec="aac",this.currentTrack.info.aacCodecInfo={isMpeg2:this.currentTrack.codecId.includes("MPEG2")},this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):this.currentTrack.codecId===be.mp3?this.currentTrack.info.codec="mp3":o===be.opus?(this.currentTrack.info.codec="opus",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate,this.currentTrack.info.sampleRate=dr):o===be.vorbis?(this.currentTrack.info.codec="vorbis",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):o===be.flac?(this.currentTrack.info.codec="flac",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):this.currentTrack.codecId==="A_PCM/INT/LIT"?this.currentTrack.info.bitDepth===8?this.currentTrack.info.codec="pcm-u8":this.currentTrack.info.bitDepth===16?this.currentTrack.info.codec="pcm-s16":this.currentTrack.info.bitDepth===24?this.currentTrack.info.codec="pcm-s24":this.currentTrack.info.bitDepth===32&&(this.currentTrack.info.codec="pcm-s32"):this.currentTrack.codecId==="A_PCM/INT/BIG"?this.currentTrack.info.bitDepth===8?this.currentTrack.info.codec="pcm-u8":this.currentTrack.info.bitDepth===16?this.currentTrack.info.codec="pcm-s16be":this.currentTrack.info.bitDepth===24?this.currentTrack.info.codec="pcm-s24be":this.currentTrack.info.bitDepth===32&&(this.currentTrack.info.codec="pcm-s32be"):this.currentTrack.codecId==="A_PCM/FLOAT/IEEE"&&(this.currentTrack.info.bitDepth===32?this.currentTrack.info.codec="pcm-f32":this.currentTrack.info.bitDepth===64&&(this.currentTrack.info.codec="pcm-f64"));const c=this.currentTrack,l=new ze(this.input,new ga(c));this.currentTrack.inputTrack=l,this.currentSegment.tracks.push(this.currentTrack)}}this.currentTrack=null}break;case S.TrackNumber:{if(!this.currentTrack)break;this.currentTrack.id=V(e,i)}break;case S.TrackType:{if(!this.currentTrack)break;const s=V(e,i);s===1?this.currentTrack.info={type:"video",width:-1,height:-1,rotation:0,codec:null,codecDescription:null,colorSpace:null,alphaMode:!1}:s===2&&(this.currentTrack.info={type:"audio",numberOfChannels:-1,sampleRate:-1,bitDepth:-1,codec:null,codecDescription:null,aacCodecInfo:null})}break;case S.FlagEnabled:{if(!this.currentTrack)break;V(e,i)||(this.currentSegment.tracks.pop(),this.currentTrack=null)}break;case S.FlagDefault:{if(!this.currentTrack)break;this.currentTrack.isDefault=!!V(e,i)}break;case S.CodecID:{if(!this.currentTrack)break;this.currentTrack.codecId=ut(e,i)}break;case S.CodecPrivate:{if(!this.currentTrack)break;this.currentTrack.codecPrivate=O(e,i)}break;case S.DefaultDuration:{if(!this.currentTrack)break;this.currentTrack.defaultDuration=this.currentTrack.segment.timestampFactor*V(e,i)/1e9}break;case S.Name:{if(!this.currentTrack)break;this.currentTrack.name=Pt(e,i)}break;case S.Language:{if(!this.currentTrack||this.currentTrack.languageCode!==ue)break;this.currentTrack.languageCode=ut(e,i),Dt(this.currentTrack.languageCode)||(this.currentTrack.languageCode=ue)}break;case S.LanguageBCP47:{if(!this.currentTrack)break;const o=ut(e,i).split("-")[0];o?this.currentTrack.languageCode=o:this.currentTrack.languageCode=ue}break;case S.Video:{if(this.currentTrack?.info?.type!=="video")break;this.readContiguousElements(e.slice(a,i))}break;case S.PixelWidth:{if(this.currentTrack?.info?.type!=="video")break;this.currentTrack.info.width=V(e,i)}break;case S.PixelHeight:{if(this.currentTrack?.info?.type!=="video")break;this.currentTrack.info.height=V(e,i)}break;case S.AlphaMode:{if(this.currentTrack?.info?.type!=="video")break;this.currentTrack.info.alphaMode=V(e,i)===1}break;case S.Colour:{if(this.currentTrack?.info?.type!=="video")break;this.currentTrack.info.colorSpace={},this.readContiguousElements(e.slice(a,i))}break;case S.MatrixCoefficients:{if(this.currentTrack?.info?.type!=="video"||!this.currentTrack.info.colorSpace)break;const s=V(e,i),o=ei[s]??null;this.currentTrack.info.colorSpace.matrix=o}break;case S.Range:{if(this.currentTrack?.info?.type!=="video"||!this.currentTrack.info.colorSpace)break;this.currentTrack.info.colorSpace.fullRange=V(e,i)===2}break;case S.TransferCharacteristics:{if(this.currentTrack?.info?.type!=="video"||!this.currentTrack.info.colorSpace)break;const s=V(e,i),o=Jn[s]??null;this.currentTrack.info.colorSpace.transfer=o}break;case S.Primaries:{if(this.currentTrack?.info?.type!=="video"||!this.currentTrack.info.colorSpace)break;const s=V(e,i),o=Zn[s]??null;this.currentTrack.info.colorSpace.primaries=o}break;case S.Projection:{if(this.currentTrack?.info?.type!=="video")break;this.readContiguousElements(e.slice(a,i))}break;case S.ProjectionPoseRoll:{if(this.currentTrack?.info?.type!=="video")break;const o=-wr(e,i);try{this.currentTrack.info.rotation=Xr(o)}catch{}}break;case S.Audio:{if(this.currentTrack?.info?.type!=="audio")break;this.readContiguousElements(e.slice(a,i))}break;case S.SamplingFrequency:{if(this.currentTrack?.info?.type!=="audio")break;this.currentTrack.info.sampleRate=wr(e,i)}break;case S.Channels:{if(this.currentTrack?.info?.type!=="audio")break;this.currentTrack.info.numberOfChannels=V(e,i)}break;case S.BitDepth:{if(this.currentTrack?.info?.type!=="audio")break;this.currentTrack.info.bitDepth=V(e,i)}break;case S.CuePoint:{if(!this.currentSegment)break;this.readContiguousElements(e.slice(a,i)),this.currentCueTime=null}break;case S.CueTime:this.currentCueTime=V(e,i);break;case S.CueTrackPositions:{if(this.currentCueTime===null)break;m(this.currentSegment);const s={time:this.currentCueTime,trackId:-1,clusterPosition:-1};this.currentSegment.cuePoints.push(s),this.readContiguousElements(e.slice(a,i)),(s.trackId===-1||s.clusterPosition===-1)&&this.currentSegment.cuePoints.pop()}break;case S.CueTrack:{const s=this.currentSegment?.cuePoints[this.currentSegment.cuePoints.length-1];if(!s)break;s.trackId=V(e,i)}break;case S.CueClusterPosition:{const s=this.currentSegment?.cuePoints[this.currentSegment.cuePoints.length-1];if(!s)break;m(this.currentSegment),s.clusterPosition=this.currentSegment.dataStartPos+V(e,i)}break;case S.Timestamp:{if(!this.currentCluster)break;this.currentCluster.timestamp=V(e,i)}break;case S.SimpleBlock:{if(!this.currentCluster)break;const s=It(e);if(s===null)break;const o=this.getTrackDataInCluster(this.currentCluster,s);if(!o)break;const c=qr(e),l=z(e),u=!!(l&128),d=l>>1&3,h=O(e,i-(e.filePos-a)),f=o.track.decodingInstructions.length>0;o.blocks.push({timestamp:c,duration:0,isKeyFrame:u,referencedTimestamps:[],data:h,lacing:d,decoded:!f,mainAdditional:null})}break;case S.BlockGroup:{if(!this.currentCluster)break;if(this.readContiguousElements(e.slice(a,i)),this.currentBlock){for(let s=0;s<this.currentBlock.referencedTimestamps.length;s++)this.currentBlock.referencedTimestamps[s]+=this.currentBlock.timestamp;this.currentBlock=null}}break;case S.Block:{if(!this.currentCluster)break;const s=It(e);if(s===null)break;const o=this.getTrackDataInCluster(this.currentCluster,s);if(!o)break;const c=qr(e),u=z(e)>>1&3,d=O(e,i-(e.filePos-a)),h=o.track.decodingInstructions.length>0;this.currentBlock={timestamp:c,duration:0,isKeyFrame:!0,referencedTimestamps:[],data:d,lacing:u,decoded:!h,mainAdditional:null},o.blocks.push(this.currentBlock)}break;case S.BlockAdditions:this.readContiguousElements(e.slice(a,i));break;case S.BlockMore:{if(!this.currentBlock)break;this.currentBlockAdditional={addId:1,data:null},this.readContiguousElements(e.slice(a,i)),this.currentBlockAdditional.data&&this.currentBlockAdditional.addId===1&&(this.currentBlock.mainAdditional=this.currentBlockAdditional.data),this.currentBlockAdditional=null}break;case S.BlockAdditional:{if(!this.currentBlockAdditional)break;this.currentBlockAdditional.data=O(e,i)}break;case S.BlockAddID:{if(!this.currentBlockAdditional)break;this.currentBlockAdditional.addId=V(e,i)}break;case S.BlockDuration:{if(!this.currentBlock)break;this.currentBlock.duration=V(e,i)}break;case S.ReferenceBlock:{if(!this.currentBlock)break;this.currentBlock.isKeyFrame=!1;const s=ha(e,i);this.currentBlock.referencedTimestamps.push(s)}break;case S.Tag:this.currentTagTargetIsMovie=!0,this.readContiguousElements(e.slice(a,i));break;case S.Targets:this.readContiguousElements(e.slice(a,i));break;case S.TargetTypeValue:V(e,i)!==50&&(this.currentTagTargetIsMovie=!1);break;case S.TagTrackUID:case S.TagEditionUID:case S.TagChapterUID:case S.TagAttachmentUID:this.currentTagTargetIsMovie=!1;break;case S.SimpleTag:{if(!this.currentTagTargetIsMovie)break;this.currentSimpleTagName=null,this.readContiguousElements(e.slice(a,i))}break;case S.TagName:this.currentSimpleTagName=Pt(e,i);break;case S.TagString:{if(!this.currentSimpleTagName)break;const s=Pt(e,i);this.processTagValue(this.currentSimpleTagName,s)}break;case S.TagBinary:{if(!this.currentSimpleTagName)break;const s=O(e,i);this.processTagValue(this.currentSimpleTagName,s)}break;case S.AttachedFile:{if(!this.currentSegment)break;this.currentAttachedFile={fileUid:null,fileName:null,fileMediaType:null,fileData:null,fileDescription:null},this.readContiguousElements(e.slice(a,i));const s=this.currentSegment.metadataTags;if(this.currentAttachedFile.fileUid&&this.currentAttachedFile.fileData&&(s.raw??={},s.raw[this.currentAttachedFile.fileUid.toString()]=new ai(this.currentAttachedFile.fileData,this.currentAttachedFile.fileMediaType??void 0,this.currentAttachedFile.fileName??void 0,this.currentAttachedFile.fileDescription??void 0)),this.currentAttachedFile.fileMediaType?.startsWith("image/")&&this.currentAttachedFile.fileData){const o=this.currentAttachedFile.fileName;let c="unknown";if(o){const l=o.toLowerCase();l.startsWith("cover.")?c="coverFront":l.startsWith("back.")&&(c="coverBack")}s.images??=[],s.images.push({data:this.currentAttachedFile.fileData,mimeType:this.currentAttachedFile.fileMediaType,kind:c,name:this.currentAttachedFile.fileName??void 0,description:this.currentAttachedFile.fileDescription??void 0})}this.currentAttachedFile=null}break;case S.FileUID:{if(!this.currentAttachedFile)break;this.currentAttachedFile.fileUid=da(e,i)}break;case S.FileName:{if(!this.currentAttachedFile)break;this.currentAttachedFile.fileName=Pt(e,i)}break;case S.FileMediaType:{if(!this.currentAttachedFile)break;this.currentAttachedFile.fileMediaType=ut(e,i)}break;case S.FileData:{if(!this.currentAttachedFile)break;this.currentAttachedFile.fileData=O(e,i)}break;case S.FileDescription:{if(!this.currentAttachedFile)break;this.currentAttachedFile.fileDescription=Pt(e,i)}break;case S.ContentEncodings:{if(!this.currentTrack)break;this.readContiguousElements(e.slice(a,i)),this.currentTrack.decodingInstructions.sort((s,o)=>o.order-s.order)}break;case S.ContentEncoding:this.currentDecodingInstruction={order:0,scope:rr.Block,data:null},this.readContiguousElements(e.slice(a,i)),this.currentDecodingInstruction.data&&this.currentTrack.decodingInstructions.push(this.currentDecodingInstruction),this.currentDecodingInstruction=null;break;case S.ContentEncodingOrder:{if(!this.currentDecodingInstruction)break;this.currentDecodingInstruction.order=V(e,i)}break;case S.ContentEncodingScope:{if(!this.currentDecodingInstruction)break;this.currentDecodingInstruction.scope=V(e,i)}break;case S.ContentCompression:{if(!this.currentDecodingInstruction)break;this.currentDecodingInstruction.data={type:"decompress",algorithm:Bt.Zlib,settings:null},this.readContiguousElements(e.slice(a,i))}break;case S.ContentCompAlgo:{if(this.currentDecodingInstruction?.data?.type!=="decompress")break;this.currentDecodingInstruction.data.algorithm=V(e,i)}break;case S.ContentCompSettings:{if(this.currentDecodingInstruction?.data?.type!=="decompress")break;this.currentDecodingInstruction.data.settings=O(e,i)}break;case S.ContentEncryption:{if(!this.currentDecodingInstruction)break;this.currentDecodingInstruction.data={type:"decrypt"}}break}return e.filePos=a+i,!0}decodeBlockData(e,r){m(e.decodingInstructions.length>0);let n=r;for(const i of e.decodingInstructions)switch(m(i.data),i.data.type){case"decompress":switch(i.data.algorithm){case Bt.HeaderStripping:if(i.data.settings&&i.data.settings.length>0){const a=i.data.settings,s=new Uint8Array(a.length+n.length);s.set(a,0),s.set(n,a.length),n=s}break}break}return n}processTagValue(e,r){if(!this.currentSegment?.metadataTags)return;const n=this.currentSegment.metadataTags;if(n.raw??={},n.raw[e]??=r,typeof r=="string")switch(e.toLowerCase()){case"title":n.title??=r;break;case"description":n.description??=r;break;case"artist":n.artist??=r;break;case"album":n.album??=r;break;case"album_artist":n.albumArtist??=r;break;case"genre":n.genre??=r;break;case"comment":n.comment??=r;break;case"lyrics":n.lyrics??=r;break;case"date":{const i=new Date(r);Number.isNaN(i.getTime())||(n.date??=i)}break;case"track_number":case"part_number":{const i=r.split("/"),a=Number.parseInt(i[0],10),s=i[1]&&Number.parseInt(i[1],10);Number.isInteger(a)&&a>0&&(n.trackNumber??=a),s&&Number.isInteger(s)&&s>0&&(n.tracksTotal??=s)}break;case"disc_number":case"disc":{const i=r.split("/"),a=Number.parseInt(i[0],10),s=i[1]&&Number.parseInt(i[1],10);Number.isInteger(a)&&a>0&&(n.discNumber??=a),s&&Number.isInteger(s)&&s>0&&(n.discsTotal??=s)}break}}}class Ai{constructor(e){this.internalTrack=e,this.packetToClusterLocation=new WeakMap}getId(){return this.internalTrack.id}getCodec(){throw new Error("Not implemented on base class.")}getInternalCodecId(){return this.internalTrack.codecId}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}getName(){return this.internalTrack.name}getLanguageCode(){return this.internalTrack.languageCode}async getFirstTimestamp(){return(await this.getFirstPacket({metadataOnly:!0}))?.timestamp??0}getTimeResolution(){return this.internalTrack.segment.timestampFactor}async getFirstPacket(e){return this.performClusterLookup(()=>{const r=this.internalTrack.segment.clusters[0]??null;if(r?.isKnownToBeFirstCluster){let n=r;for(;n;){if(n.trackData.get(this.internalTrack.id))return{clusterIndex:K(this.internalTrack.clusters,n.elementStartPos,a=>a.elementStartPos),blockIndex:0,correctBlockFound:!0};n=n.nextCluster}}return{clusterIndex:-1,blockIndex:-1,correctBlockFound:!1}},-1/0,1/0,e)}intoTimescale(e){return Jt(e*this.internalTrack.segment.timestampFactor,14)}async getPacket(e,r){const n=this.intoTimescale(e);return this.performClusterLookup(()=>this.findBlockInClustersForTimestamp(n),n,n,r)}async getNextPacket(e,r){const n=this.packetToClusterLocation.get(e);if(n===void 0)throw new Error("Packet was not created from this track.");const i=n.cluster.trackData.get(this.internalTrack.id),a=K(this.internalTrack.clusters,n.cluster.elementStartPos,s=>s.elementStartPos);return m(a!==-1),this.performClusterLookup(()=>{if(n.blockIndex+1<i.blocks.length)return{clusterIndex:a,blockIndex:n.blockIndex+1,correctBlockFound:!0};{let s=n.cluster;for(;s.nextCluster;)if(s=s.nextCluster,s.trackData.get(this.internalTrack.id)){const c=K(this.internalTrack.clusters,s.elementStartPos,l=>l.elementStartPos);return m(c!==-1),{clusterIndex:c,blockIndex:0,correctBlockFound:!0}}return{clusterIndex:a,blockIndex:-1,correctBlockFound:!1}}},-1/0,1/0,r)}async getKeyPacket(e,r){const n=this.intoTimescale(e);return this.performClusterLookup(()=>this.findKeyBlockInClustersForTimestamp(n),n,n,r)}async getNextKeyPacket(e,r){const n=this.packetToClusterLocation.get(e);if(n===void 0)throw new Error("Packet was not created from this track.");const i=n.cluster.trackData.get(this.internalTrack.id),a=K(this.internalTrack.clusters,n.cluster.elementStartPos,s=>s.elementStartPos);return m(a!==-1),this.performClusterLookup(()=>{const s=i.blocks.findIndex((o,c)=>o.isKeyFrame&&c>n.blockIndex);if(s!==-1)return{clusterIndex:a,blockIndex:s,correctBlockFound:!0};{let o=n.cluster;for(;o.nextCluster;){o=o.nextCluster;const c=o.trackData.get(this.internalTrack.id);if(c&&c.firstKeyFrameTimestamp!==null){const l=K(this.internalTrack.clusters,o.elementStartPos,d=>d.elementStartPos);m(l!==-1);const u=c.blocks.findIndex(d=>d.isKeyFrame);return m(u!==-1),{clusterIndex:l,blockIndex:u,correctBlockFound:!0}}}return{clusterIndex:a,blockIndex:-1,correctBlockFound:!1}}},-1/0,1/0,r)}async fetchPacketInCluster(e,r,n){if(r===-1)return null;const a=e.trackData.get(this.internalTrack.id).blocks[r];m(a),a.decoded||(a.data=this.internalTrack.demuxer.decodeBlockData(this.internalTrack,a.data),a.decoded=!0);const s=n.metadataOnly?fe:a.data,o=a.timestamp/this.internalTrack.segment.timestampFactor,c=a.duration/this.internalTrack.segment.timestampFactor,l={};a.mainAdditional&&this.internalTrack.info?.type==="video"&&this.internalTrack.info.alphaMode&&(l.alpha=n.metadataOnly?fe:a.mainAdditional,l.alphaByteLength=a.mainAdditional.byteLength);const u=new H(s,a.isKeyFrame?"key":"delta",o,c,e.dataStartPos+r,a.data.byteLength,l);return this.packetToClusterLocation.set(u,{cluster:e,blockIndex:r}),u}findBlockInClustersForTimestamp(e){const r=L(this.internalTrack.clusters,e,a=>a.trackData.get(this.internalTrack.id).startTimestamp);let n=-1,i=!1;if(r!==-1){const s=this.internalTrack.clusters[r].trackData.get(this.internalTrack.id),o=L(s.presentationTimestamps,e,c=>c.timestamp);m(o!==-1),n=s.presentationTimestamps[o].blockIndex,i=e<s.endTimestamp}return{clusterIndex:r,blockIndex:n,correctBlockFound:i}}findKeyBlockInClustersForTimestamp(e){const r=L(this.internalTrack.clustersWithKeyFrame,e,s=>s.trackData.get(this.internalTrack.id).firstKeyFrameTimestamp);let n=-1,i=-1,a=!1;if(r!==-1){const s=this.internalTrack.clustersWithKeyFrame[r];n=K(this.internalTrack.clusters,s.elementStartPos,u=>u.elementStartPos),m(n!==-1);const o=s.trackData.get(this.internalTrack.id),c=ri(o.presentationTimestamps,u=>o.blocks[u.blockIndex].isKeyFrame&&u.timestamp<=e);m(c!==-1),i=o.presentationTimestamps[c].blockIndex,a=e<o.endTimestamp}return{clusterIndex:n,blockIndex:i,correctBlockFound:a}}async performClusterLookup(e,r,n,i){const{demuxer:a,segment:s}=this.internalTrack,o=await s.clusterLookupMutex.acquire();try{const{clusterIndex:c,blockIndex:l,correctBlockFound:u}=e();if(u){const T=this.internalTrack.clusters[c];return this.fetchPacketInCluster(T,l,i)}let d=null,h=c,f=l;const p=L(this.internalTrack.cuePoints,r,T=>T.time),g=p!==-1?this.internalTrack.cuePoints[p]:null;let b,w=!1;if(c===-1)b=g?.clusterPosition??s.clusterSeekStartPos,w=b===s.clusterSeekStartPos;else{const T=this.internalTrack.clusters[c];!g||T.elementStartPos>=g.clusterPosition?(b=T.elementEndPos,d=T):b=g.clusterPosition}for(;s.elementEndPos===null||b<=s.elementEndPos-le;){if(d){const v=d.trackData.get(this.internalTrack.id);if(v&&v.startTimestamp>n)break;if(d.nextCluster){b=d.nextCluster.elementEndPos,d=d.nextCluster;continue}}let T=a.reader.requestSliceRange(b,le,Be);if(T instanceof Promise&&(T=await T),!T)break;const y=b,x=Fe(T);if(!x||!Nt.includes(x.id)&&x.id!==S.Void){const v=await Ii(a.reader,y,Nt,Math.min(s.elementEndPos??1/0,y+Fi));if(v){b=v;continue}else break}const _=x.id;let C=x.size;const F=T.filePos;if(_===S.Cluster){const v=K(s.clusters,y,Y=>Y.elementStartPos);let I;v===-1?I=await a.readCluster(y,s):I=s.clusters[v],d&&(d.nextCluster=I),d=I,w&&(I.isKnownToBeFirstCluster=!0,w=!1);const{clusterIndex:A,blockIndex:M,correctBlockFound:W}=e();if(W){const Y=this.internalTrack.clusters[A];return this.fetchPacketInCluster(Y,M,i)}A!==-1&&(h=A,f=M)}if(C===null){_===S.Cluster?(m(d),C=d.elementEndPos-F):C=(await Vr(a.reader,F,Or,s.elementEndPos)).pos-F;const v=F+C;if(s.elementEndPos!==null&&v>s.elementEndPos-le)break;{let I=a.reader.requestSliceRange(v,le,Be);if(I instanceof Promise&&(I=await I),!I)break;if(rn(I)===S.Segment){s.elementEndPos=v;break}}}b=F+C}const k=h!==-1?this.internalTrack.clusters[h]:null;if(g&&(!k||k.elementStartPos<g.clusterPosition)){const y=this.internalTrack.cuePoints[p-1]?.time??-1/0;return this.performClusterLookup(e,y,n,i)}return k?this.fetchPacketInCluster(k,f,i):null}finally{o()}}}class pa extends Ai{constructor(e){super(e),this.decoderConfigPromise=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getCodedWidth(){return this.internalTrack.info.width}getCodedHeight(){return this.internalTrack.info.height}getRotation(){return this.internalTrack.info.rotation}async getColorSpace(){return{primaries:this.internalTrack.info.colorSpace?.primaries,transfer:this.internalTrack.info.colorSpace?.transfer,matrix:this.internalTrack.info.colorSpace?.matrix,fullRange:this.internalTrack.info.colorSpace?.fullRange}}async canBeTransparent(){return this.internalTrack.info.alphaMode}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfigPromise??=(async()=>{let e=null;return(this.internalTrack.info.codec==="vp9"||this.internalTrack.info.codec==="av1"||this.internalTrack.info.codec==="avc"&&!this.internalTrack.info.codecDescription||this.internalTrack.info.codec==="hevc"&&!this.internalTrack.info.codecDescription)&&(e=await this.getFirstPacket({})),{codec:oi({width:this.internalTrack.info.width,height:this.internalTrack.info.height,codec:this.internalTrack.info.codec,codecDescription:this.internalTrack.info.codecDescription,colorSpace:this.internalTrack.info.colorSpace,avcCodecInfo:this.internalTrack.info.codec==="avc"&&e?mi(e.data):null,hevcCodecInfo:this.internalTrack.info.codec==="hevc"&&e?gi(e.data):null,vp9CodecInfo:this.internalTrack.info.codec==="vp9"&&e?ki(e.data):null,av1CodecInfo:this.internalTrack.info.codec==="av1"&&e?wi(e.data):null}),codedWidth:this.internalTrack.info.width,codedHeight:this.internalTrack.info.height,description:this.internalTrack.info.codecDescription??void 0,colorSpace:this.internalTrack.info.colorSpace??void 0}})():null}}class ga extends Ai{constructor(e){super(e),this.decoderConfig=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getNumberOfChannels(){return this.internalTrack.info.numberOfChannels}getSampleRate(){return this.internalTrack.info.sampleRate}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfig??={codec:ci({codec:this.internalTrack.info.codec,codecDescription:this.internalTrack.info.codecDescription,aacCodecInfo:this.internalTrack.info.aacCodecInfo}),numberOfChannels:this.internalTrack.info.numberOfChannels,sampleRate:this.internalTrack.info.sampleRate,description:this.internalTrack.info.codecDescription??void 0}:null}}const ka=t=>{const e=new Map;for(let a=0;a<t.length;a++){const s=t[a];e.set(s.timestamp,s)}const r=new Set,n=[],i=a=>{if(!r.has(a)){r.add(a);for(let s=0;s<a.referencedTimestamps.length;s++){const o=a.referencedTimestamps[s],c=e.get(o);c&&i(c)}n.push(a)}};for(let a=0;a<t.length;a++)i(t[a]);return n};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Bi=4,ba=[44100,48e3,32e3],wa=[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,32,40,48,56,64,80,96,112,128,160,192,224,256,320,-1,-1,32,48,56,64,80,96,112,128,160,192,224,256,320,384,-1,-1,32,64,96,128,160,192,224,256,288,320,352,384,416,448,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,16,24,32,40,48,56,64,80,96,112,128,144,160,-1,-1,8,16,24,32,40,48,56,64,80,96,112,128,144,160,-1,-1,32,48,56,64,80,96,112,128,144,160,176,192,224,256,-1],Ta=1483304551,ya=1231971951,Sa=(t,e,r,n,i)=>e===0?0:e===1?Math.floor(144*r/(n<<t))+i:e===2?Math.floor(144*r/n)+i:(Math.floor(12*r/n)+i)*4,xa=(t,e)=>t===3?e===3?21:36:e===3?13:21,Ca=(t,e)=>{const r=t>>>24,n=t>>>16&255,i=t>>>8&255,a=t&255;if(r!==255&&n!==255&&i!==255&&a!==255)return{header:null,bytesAdvanced:4};if(r!==255)return{header:null,bytesAdvanced:1};if((n&224)!==224)return{header:null,bytesAdvanced:1};let s=0,o=0;n&16?s=n&8?0:1:(s=1,o=1);const c=n>>3&3,l=n>>1&3,u=i>>4&15,d=(i>>2&3)%3,h=i>>1&1,f=a>>6&3,p=a>>4&3,g=a>>3&1,b=a>>2&1,w=a&3,k=wa[s*16*4+l*16+u];if(k===-1)return{header:null,bytesAdvanced:1};const T=k*1e3,y=ba[d]>>s+o,x=Sa(s,l,T,y,h);if(e!==null&&e<x)return{header:null,bytesAdvanced:1};let _;return c===3?_=l===3?384:1152:l===3?_=384:l===2?_=1152:_=576,{header:{totalSize:x,mpegVersionId:c,layer:l,bitrate:T,frequencyIndex:d,sampleRate:y,channel:f,modeExtension:p,copyright:g,original:b,emphasis:w,audioSamplesInFrame:_},bytesAdvanced:1}},Ur=t=>{let e=2130706432,r=0;for(;e!==0;)r>>=1,r|=t&e,e>>=8;return r};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */var ht;(function(t){t[t.Unsynchronisation=128]="Unsynchronisation",t[t.ExtendedHeader=64]="ExtendedHeader",t[t.ExperimentalIndicator=32]="ExperimentalIndicator",t[t.Footer=16]="Footer"})(ht||(ht={}));var ft;(function(t){t[t.ISO_8859_1=0]="ISO_8859_1",t[t.UTF_16_WITH_BOM=1]="UTF_16_WITH_BOM",t[t.UTF_16_BE_NO_BOM=2]="UTF_16_BE_NO_BOM",t[t.UTF_8=3]="UTF_8"})(ft||(ft={}));const Zt=128,nr=10,mt=["Blues","Classic rock","Country","Dance","Disco","Funk","Grunge","Hip-hop","Jazz","Metal","New age","Oldies","Other","Pop","Rhythm and blues","Rap","Reggae","Rock","Techno","Industrial","Alternative","Ska","Death metal","Pranks","Soundtrack","Euro-techno","Ambient","Trip-hop","Vocal","Jazz & funk","Fusion","Trance","Classical","Instrumental","Acid","House","Game","Sound clip","Gospel","Noise","Alternative rock","Bass","Soul","Punk","Space","Meditative","Instrumental pop","Instrumental rock","Ethnic","Gothic","Darkwave","Techno-industrial","Electronic","Pop-folk","Eurodance","Dream","Southern rock","Comedy","Cult","Gangsta","Top 40","Christian rap","Pop/funk","Jungle music","Native US","Cabaret","New wave","Psychedelic","Rave","Showtunes","Trailer","Lo-fi","Tribal","Acid punk","Acid jazz","Polka","Retro","Musical","Rock 'n' roll","Hard rock","Folk","Folk rock","National folk","Swing","Fast fusion","Bebop","Latin","Revival","Celtic","Bluegrass","Avantgarde","Gothic rock","Progressive rock","Psychedelic rock","Symphonic rock","Slow rock","Big band","Chorus","Easy listening","Acoustic","Humour","Speech","Chanson","Opera","Chamber music","Sonata","Symphony","Booty bass","Primus","Porn groove","Satire","Slow jam","Club","Tango","Samba","Folklore","Ballad","Power ballad","Rhythmic Soul","Freestyle","Duet","Punk rock","Drum solo","A cappella","Euro-house","Dance hall","Goa music","Drum & bass","Club-house","Hardcore techno","Terror","Indie","Britpop","Negerpunk","Polsk punk","Beat","Christian gangsta rap","Heavy metal","Black metal","Crossover","Contemporary Christian","Christian rock","Merengue","Salsa","Thrash metal","Anime","Jpop","Synthpop","Christmas","Art rock","Baroque","Bhangra","Big beat","Breakbeat","Chillout","Downtempo","Dub","EBM","Eclectic","Electro","Electroclash","Emo","Experimental","Garage","Global","IDM","Illbient","Industro-Goth","Jam Band","Krautrock","Leftfield","Lounge","Math rock","New romantic","Nu-breakz","Post-punk","Post-rock","Psytrance","Shoegaze","Space rock","Trop rock","World music","Neoclassical","Audiobook","Audio theatre","Neue Deutsche Welle","Podcast","Indie rock","G-Funk","Dubstep","Garage rock","Psybient"],Pa=(t,e)=>{const r=t.filePos;e.raw??={},e.raw.TAG??=O(t,Zt-3),t.filePos=r;const n=st(t,30);n&&(e.title??=n);const i=st(t,30);i&&(e.artist??=i);const a=st(t,30);a&&(e.album??=a);const s=st(t,4),o=Number.parseInt(s,10);Number.isInteger(o)&&o>0&&(e.date??=new Date(o,0,1));const c=O(t,30);let l;if(c[28]===0&&c[29]!==0){const d=c[29];d>0&&(e.trackNumber??=d),t.skip(-30),l=st(t,28),t.skip(2)}else t.skip(-30),l=st(t,30);l&&(e.comment??=l);const u=z(t);u<mt.length&&(e.genre??=mt[u])},st=(t,e)=>{const r=O(t,e),n=lt(r.indexOf(0),r.length),i=r.subarray(0,n);let a="";for(let s=0;s<i.length;s++)a+=String.fromCharCode(i[s]);return a.trimEnd()},ir=t=>{const e=t.filePos,r=X(t,3),n=z(t),i=z(t),a=z(t),s=E(t);if(r!=="ID3"||n===255||i===255||(s&2155905152)!==0)return t.filePos=e,null;const o=Ur(s);return{majorVersion:n,revision:i,flags:a,size:o}},zi=(t,e,r)=>{if(![2,3,4].includes(e.majorVersion)){console.warn(`Unsupported ID3v2 major version: ${e.majorVersion}`);return}const n=O(t,e.size),i=new va(e,n);if(e.flags&ht.Footer&&i.removeFooter(),e.flags&ht.Unsynchronisation&&e.majorVersion===3&&i.ununsynchronizeAll(),e.flags&ht.ExtendedHeader){const a=i.readU32();e.majorVersion===3?i.pos+=a:i.pos+=a-4}for(;i.pos<=i.bytes.length-i.frameHeaderSize();){const a=i.readId3V2Frame();if(!a)break;const s=i.pos,o=i.pos+a.size;let c=!1,l=!1,u=!1;if(e.majorVersion===3?(c=!!(a.flags&64),l=!!(a.flags&128)):e.majorVersion===4&&(c=!!(a.flags&4),l=!!(a.flags&8),u=!!(a.flags&2)||!!(e.flags&ht.Unsynchronisation)),c){console.warn(`Skipping encrypted ID3v2 frame ${a.id}`),i.pos=o;continue}if(l){console.warn(`Skipping compressed ID3v2 frame ${a.id}`),i.pos=o;continue}switch(u&&i.ununsynchronizeRegion(i.pos,o),r.raw??={},a.id[0]==="T"?r.raw[a.id]??=i.readId3V2EncodingAndText(o):r.raw[a.id]??=i.readBytes(a.size),i.pos=s,a.id){case"TIT2":case"TT2":r.title??=i.readId3V2EncodingAndText(o);break;case"TIT3":case"TT3":r.description??=i.readId3V2EncodingAndText(o);break;case"TPE1":case"TP1":r.artist??=i.readId3V2EncodingAndText(o);break;case"TALB":case"TAL":r.album??=i.readId3V2EncodingAndText(o);break;case"TPE2":case"TP2":r.albumArtist??=i.readId3V2EncodingAndText(o);break;case"TRCK":case"TRK":{const h=i.readId3V2EncodingAndText(o).split("/"),f=Number.parseInt(h[0],10),p=h[1]&&Number.parseInt(h[1],10);Number.isInteger(f)&&f>0&&(r.trackNumber??=f),p&&Number.isInteger(p)&&p>0&&(r.tracksTotal??=p)}break;case"TPOS":case"TPA":{const h=i.readId3V2EncodingAndText(o).split("/"),f=Number.parseInt(h[0],10),p=h[1]&&Number.parseInt(h[1],10);Number.isInteger(f)&&f>0&&(r.discNumber??=f),p&&Number.isInteger(p)&&p>0&&(r.discsTotal??=p)}break;case"TCON":case"TCO":{const d=i.readId3V2EncodingAndText(o);let h=/^\((\d+)\)/.exec(d);if(h){const f=Number.parseInt(h[1]);if(mt[f]!==void 0){r.genre??=mt[f];break}}if(h=/^\d+$/.exec(d),h){const f=Number.parseInt(h[0]);if(mt[f]!==void 0){r.genre??=mt[f];break}}r.genre??=d}break;case"TDRC":case"TDAT":{const d=i.readId3V2EncodingAndText(o),h=new Date(d);Number.isNaN(h.getTime())||(r.date??=h)}break;case"TYER":case"TYE":{const d=i.readId3V2EncodingAndText(o),h=Number.parseInt(d,10);Number.isInteger(h)&&(r.date??=new Date(h,0,1))}break;case"USLT":case"ULT":{const d=i.readU8();i.pos+=3,i.readId3V2Text(d,o),r.lyrics??=i.readId3V2Text(d,o)}break;case"COMM":case"COM":{const d=i.readU8();i.pos+=3,i.readId3V2Text(d,o),r.comment??=i.readId3V2Text(d,o)}break;case"APIC":case"PIC":{const d=i.readId3V2TextEncoding();let h;if(e.majorVersion===2){const b=i.readAscii(3);h=b==="PNG"?"image/png":b==="JPG"?"image/jpeg":"image/*"}else h=i.readId3V2Text(d,o);const f=i.readU8(),p=i.readId3V2Text(d,o).trimEnd(),g=o-i.pos;if(g>=0){const b=i.readBytes(g);r.images||(r.images=[]),r.images.push({data:b,mimeType:h,kind:f===3?"coverFront":f===4?"coverBack":"unknown",description:p})}}break;default:i.pos+=a.size;break}i.pos=o}};class va{constructor(e,r){this.header=e,this.bytes=r,this.pos=0,this.view=new DataView(r.buffer,r.byteOffset,r.byteLength)}frameHeaderSize(){return this.header.majorVersion===2?6:10}ununsynchronizeAll(){const e=[];for(let r=0;r<this.bytes.length;r++){const n=this.bytes[r];e.push(n),n===255&&r!==this.bytes.length-1&&this.bytes[r]===0&&r++}this.bytes=new Uint8Array(e),this.view=new DataView(this.bytes.buffer)}ununsynchronizeRegion(e,r){const n=[];for(let s=e;s<r;s++){const o=this.bytes[s];n.push(o),o===255&&s!==r-1&&this.bytes[s+1]===0&&s++}const i=this.bytes.subarray(0,e),a=this.bytes.subarray(r);this.bytes=new Uint8Array(i.length+n.length+a.length),this.bytes.set(i,0),this.bytes.set(n,i.length),this.bytes.set(a,i.length+n.length),this.view=new DataView(this.bytes.buffer)}removeFooter(){this.bytes=this.bytes.subarray(0,this.bytes.length-nr),this.view=new DataView(this.bytes.buffer)}readBytes(e){const r=this.bytes.subarray(this.pos,this.pos+e);return this.pos+=e,r}readU8(){const e=this.view.getUint8(this.pos);return this.pos+=1,e}readU16(){const e=this.view.getUint16(this.pos,!1);return this.pos+=2,e}readU24(){const e=this.view.getUint16(this.pos,!1),r=this.view.getUint8(this.pos+1);return this.pos+=3,e*256+r}readU32(){const e=this.view.getUint32(this.pos,!1);return this.pos+=4,e}readAscii(e){let r="";for(let n=0;n<e;n++)r+=String.fromCharCode(this.view.getUint8(this.pos+n));return this.pos+=e,r}readId3V2Frame(){if(this.header.majorVersion===2){const e=this.readAscii(3);if(e==="\0\0\0")return null;const r=this.readU24();return{id:e,size:r,flags:0}}else{const e=this.readAscii(4);if(e==="\0\0\0\0")return null;const r=this.readU32();let n=this.header.majorVersion===4?Ur(r):r;const i=this.readU16(),a=this.pos,s=o=>{const c=this.pos+o;if(c>this.bytes.length)return!1;if(c<=this.bytes.length-this.frameHeaderSize()){this.pos+=o;const l=this.readAscii(4);if(l!=="\0\0\0\0"&&!/[0-9A-Z]{4}/.test(l))return!1}return!0};if(!s(n)){const o=this.header.majorVersion===4?r:Ur(r);s(o)&&(n=o)}return this.pos=a,{id:e,size:n,flags:i}}}readId3V2TextEncoding(){const e=this.readU8();if(e>3)throw new Error(`Unsupported text encoding: ${e}`);return e}readId3V2Text(e,r){const n=this.pos,i=this.readBytes(r-this.pos);switch(e){case ft.ISO_8859_1:{let a="";for(let s=0;s<i.length;s++){const o=i[s];if(o===0){this.pos=n+s+1;break}a+=String.fromCharCode(o)}return a}case ft.UTF_16_WITH_BOM:if(i[0]===255&&i[1]===254){const a=new TextDecoder("utf-16le"),s=lt(i.findIndex((o,c)=>o===0&&i[c+1]===0&&c%2===0),i.length);return this.pos=n+Math.min(s+2,i.length),a.decode(i.subarray(2,s))}else if(i[0]===254&&i[1]===255){const a=new TextDecoder("utf-16be"),s=lt(i.findIndex((o,c)=>o===0&&i[c+1]===0&&c%2===0),i.length);return this.pos=n+Math.min(s+2,i.length),a.decode(i.subarray(2,s))}else{const a=lt(i.findIndex(s=>s===0),i.length);return this.pos=n+Math.min(a+1,i.length),he.decode(i.subarray(0,a))}case ft.UTF_16_BE_NO_BOM:{const a=new TextDecoder("utf-16be"),s=lt(i.findIndex((o,c)=>o===0&&i[c+1]===0&&c%2===0),i.length);return this.pos=n+Math.min(s+2,i.length),a.decode(i.subarray(0,s))}case ft.UTF_8:{const a=lt(i.findIndex(s=>s===0),i.length);return this.pos=n+Math.min(a+1,i.length),he.decode(i.subarray(0,a))}}}readId3V2EncodingAndText(e){if(this.pos>=e)return"";const r=this.readId3V2TextEncoding();return this.readId3V2Text(r,e)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Wr=async(t,e,r)=>{let n=e;for(;r===null||n<r;){let i=t.requestSlice(n,Bi);if(i instanceof Promise&&(i=await i),!i)break;const a=E(i),s=Ca(a,t.fileSize!==null?t.fileSize-n:null);if(s.header)return{header:s.header,startPos:n};n+=s.bytesAdvanced}return null};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class _a extends tt{constructor(e){super(e),this.metadataPromise=null,this.firstFrameHeader=null,this.loadedSamples=[],this.metadataTags=null,this.tracks=[],this.readingMutex=new je,this.lastSampleLoaded=!1,this.lastLoadedPos=0,this.nextTimestampInSamples=0,this.reader=e._reader}async readMetadata(){return this.metadataPromise??=(async()=>{for(;!this.firstFrameHeader&&!this.lastSampleLoaded;)await this.advanceReader();if(!this.firstFrameHeader)throw new Error("No valid MP3 frame found.");this.tracks=[new ze(this.input,new Ea(this))]})()}async advanceReader(){if(this.lastLoadedPos===0)for(;;){let o=this.reader.requestSlice(this.lastLoadedPos,nr);if(o instanceof Promise&&(o=await o),!o){this.lastSampleLoaded=!0;return}const c=ir(o);if(!c)break;this.lastLoadedPos=o.filePos+c.size}const e=await Wr(this.reader,this.lastLoadedPos,this.reader.fileSize);if(!e){this.lastSampleLoaded=!0;return}const r=e.header;this.lastLoadedPos=e.startPos+r.totalSize-1;const n=xa(r.mpegVersionId,r.channel);let i=this.reader.requestSlice(e.startPos+n,4);if(i instanceof Promise&&(i=await i),i){const o=E(i);if(o===Ta||o===ya)return}this.firstFrameHeader||(this.firstFrameHeader=r),r.sampleRate!==this.firstFrameHeader.sampleRate&&console.warn(`MP3 changed sample rate mid-file: ${this.firstFrameHeader.sampleRate} Hz to ${r.sampleRate} Hz. Might be a bug, so please report this file.`);const a=r.audioSamplesInFrame/this.firstFrameHeader.sampleRate,s={timestamp:this.nextTimestampInSamples/this.firstFrameHeader.sampleRate,duration:a,dataStart:e.startPos,dataSize:r.totalSize};this.loadedSamples.push(s),this.nextTimestampInSamples+=r.audioSamplesInFrame}async getMimeType(){return"audio/mpeg"}async getTracks(){return await this.readMetadata(),this.tracks}async computeDuration(){await this.readMetadata();const e=this.tracks[0];return m(e),e.computeDuration()}async getMetadataTags(){const e=await this.readingMutex.acquire();try{if(await this.readMetadata(),this.metadataTags)return this.metadataTags;this.metadataTags={};let r=0,n=!1;for(;;){let i=this.reader.requestSlice(r,nr);if(i instanceof Promise&&(i=await i),!i)break;const a=ir(i);if(!a)break;n=!0;let s=this.reader.requestSlice(i.filePos,a.size);if(s instanceof Promise&&(s=await s),!s)break;zi(s,a,this.metadataTags),r=i.filePos+a.size}if(!n&&this.reader.fileSize!==null&&this.reader.fileSize>=Zt){let i=this.reader.requestSlice(this.reader.fileSize-Zt,Zt);i instanceof Promise&&(i=await i),m(i),X(i,3)==="TAG"&&Pa(i,this.metadataTags)}return this.metadataTags}finally{e()}}}class Ea{constructor(e){this.demuxer=e}getId(){return 1}async getFirstTimestamp(){return 0}getTimeResolution(){return m(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.sampleRate/this.demuxer.firstFrameHeader.audioSamplesInFrame}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}getName(){return null}getLanguageCode(){return ue}getCodec(){return"mp3"}getInternalCodecId(){return null}getNumberOfChannels(){return m(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.channel===3?1:2}getSampleRate(){return m(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.sampleRate}async getDecoderConfig(){return m(this.demuxer.firstFrameHeader),{codec:"mp3",numberOfChannels:this.demuxer.firstFrameHeader.channel===3?1:2,sampleRate:this.demuxer.firstFrameHeader.sampleRate}}async getPacketAtIndex(e,r){if(e===-1)return null;const n=this.demuxer.loadedSamples[e];if(!n)return null;let i;if(r.metadataOnly)i=fe;else{let a=this.demuxer.reader.requestSlice(n.dataStart,n.dataSize);if(a instanceof Promise&&(a=await a),!a)return null;i=O(a,n.dataSize)}return new H(i,"key",n.timestamp,n.duration,e,n.dataSize)}getFirstPacket(e){return this.getPacketAtIndex(0,e)}async getNextPacket(e,r){const n=await this.demuxer.readingMutex.acquire();try{const i=K(this.demuxer.loadedSamples,e.timestamp,s=>s.timestamp);if(i===-1)throw new Error("Packet was not created from this track.");const a=i+1;for(;a>=this.demuxer.loadedSamples.length&&!this.demuxer.lastSampleLoaded;)await this.demuxer.advanceReader();return this.getPacketAtIndex(a,r)}finally{n()}}async getPacket(e,r){const n=await this.demuxer.readingMutex.acquire();try{for(;;){const i=L(this.demuxer.loadedSamples,e,a=>a.timestamp);if(i===-1&&this.demuxer.loadedSamples.length>0)return null;if(this.demuxer.lastSampleLoaded)return this.getPacketAtIndex(i,r);if(i>=0&&i+1<this.demuxer.loadedSamples.length)return this.getPacketAtIndex(i,r);await this.demuxer.advanceReader()}}finally{n()}}getKeyPacket(e,r){return this.getPacket(e,r)}getNextKeyPacket(e,r){return this.getNextPacket(e,r)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Ri=1399285583,Ia=79764919,Di=new Uint32Array(256);for(let t=0;t<256;t++){let e=t<<24;for(let r=0;r<8;r++)e=e&2147483648?e<<1^Ia:e<<1;Di[t]=e>>>0&4294967295}const Fa=t=>{const e=te(t),r=e.getUint32(22,!0);e.setUint32(22,0,!0);let n=0;for(let i=0;i<t.length;i++){const a=t[i];n=(n<<8^Di[n>>>24^a])>>>0}return e.setUint32(22,r,!0),n},Aa=(t,e,r)=>{let n=0,i=null;if(t.length>0)if(e.codec==="vorbis"){m(e.vorbisInfo);const a=e.vorbisInfo.modeBlockflags.length,o=(1<<fs(a-1))-1<<1,c=(t[0]&o)>>1;if(c>=e.vorbisInfo.modeBlockflags.length)throw new Error("Invalid mode number.");let l=r;const u=e.vorbisInfo.modeBlockflags[c];if(i=e.vorbisInfo.blocksizes[u],u===1){const d=(o|1)+1,h=t[0]&d?1:0;l=e.vorbisInfo.blocksizes[h]}n=l!==null?l+i>>2:0}else e.codec==="opus"&&(n=Hs(t).durationInSamples);return{durationInSamples:n,vorbisBlockSize:i}},Ba=t=>{let e="audio/ogg";if(t.codecStrings){const r=[...new Set(t.codecStrings)];e+=`; codecs="${r.join(", ")}"`}return e};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Ye=27,wt=282,za=wt+255*255,zt=t=>{const e=t.filePos;if(pt(t)!==Ri)return null;t.skip(1);const n=z(t),i=To(t),a=pt(t),s=pt(t),o=pt(t),c=z(t),l=new Uint8Array(c);for(let f=0;f<c;f++)l[f]=z(t);const u=27+c,d=l.reduce((f,p)=>f+p,0),h=u+d;return{headerStartPos:e,totalSize:h,dataStartPos:e+u,dataSize:d,headerType:n,granulePosition:i,serialNumber:a,sequenceNumber:s,checksum:o,lacingValues:l}},Ra=(t,e)=>{for(;t.filePos<e-3;){const r=pt(t),n=r&255,i=r>>>8&255,a=r>>>16&255,s=r>>>24&255,o=79;if(!(n!==o&&i!==o&&a!==o&&s!==o)){if(t.skip(-4),r===Ri)return!0;t.skip(1)}}return!1};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Da extends tt{constructor(e){super(e),this.metadataPromise=null,this.bitstreams=[],this.tracks=[],this.metadataTags={},this.reader=e._reader}async readMetadata(){return this.metadataPromise??=(async()=>{let e=0;for(;;){let r=this.reader.requestSliceRange(e,Ye,wt);if(r instanceof Promise&&(r=await r),!r)break;const n=zt(r);if(!n||!!!(n.headerType&2))break;this.bitstreams.push({serialNumber:n.serialNumber,bosPage:n,description:null,numberOfChannels:-1,sampleRate:-1,codecInfo:{codec:null,vorbisInfo:null,opusInfo:null},lastMetadataPacket:null}),e=n.headerStartPos+n.totalSize}for(const r of this.bitstreams){const n=await this.readPacket(r.bosPage,0);n&&(n.data.byteLength>=7&&n.data[0]===1&&n.data[1]===118&&n.data[2]===111&&n.data[3]===114&&n.data[4]===98&&n.data[5]===105&&n.data[6]===115?await this.readVorbisMetadata(n,r):n.data.byteLength>=8&&n.data[0]===79&&n.data[1]===112&&n.data[2]===117&&n.data[3]===115&&n.data[4]===72&&n.data[5]===101&&n.data[6]===97&&n.data[7]===100&&await this.readOpusMetadata(n,r),r.codecInfo.codec!==null&&this.tracks.push(new ze(this.input,new Ma(r,this))))}})()}async readVorbisMetadata(e,r){let n=await this.findNextPacketStart(e);if(!n)return;const i=await this.readPacket(n.startPage,n.startSegmentIndex);if(!i||(n=await this.findNextPacketStart(i),!n))return;const a=await this.readPacket(n.startPage,n.startSegmentIndex);if(!a||i.data[0]!==3||a.data[0]!==5)return;const s=[],o=d=>{for(;s.push(Math.min(255,d)),!(d<255);)d-=255};o(e.data.length),o(i.data.length);const c=new Uint8Array(1+s.length+e.data.length+i.data.length+a.data.length);c[0]=2,c.set(s,1),c.set(e.data,1+s.length),c.set(i.data,1+s.length+e.data.length),c.set(a.data,1+s.length+e.data.length+i.data.length),r.codecInfo.codec="vorbis",r.description=c,r.lastMetadataPacket=a;const l=te(e.data);r.numberOfChannels=l.getUint8(11),r.sampleRate=l.getUint32(12,!0);const u=l.getUint8(28);r.codecInfo.vorbisInfo={blocksizes:[1<<(u&15),1<<(u>>4)],modeBlockflags:qs(a.data).modeBlockflags},zr(i.data.subarray(7),this.metadataTags)}async readOpusMetadata(e,r){const n=await this.findNextPacketStart(e);if(!n)return;const i=await this.readPacket(n.startPage,n.startSegmentIndex);if(!i)return;r.codecInfo.codec="opus",r.description=e.data,r.lastMetadataPacket=i;const a=Ti(e.data);r.numberOfChannels=a.outputChannelCount,r.sampleRate=dr,r.codecInfo.opusInfo={preSkip:a.preSkip},zr(i.data.subarray(8),this.metadataTags)}async readPacket(e,r){m(r<e.lacingValues.length);let n=0;for(let d=0;d<r;d++)n+=e.lacingValues[d];let i=e,a=n,s=r;const o=[];e:for(;;){let d=this.reader.requestSlice(i.dataStartPos,i.dataSize);d instanceof Promise&&(d=await d),m(d);const h=O(d,i.dataSize);for(;;){if(s===i.lacingValues.length){o.push(h.subarray(n,a));break}const p=i.lacingValues[s];if(a+=p,p<255){o.push(h.subarray(n,a));break e}s++}let f=i.headerStartPos+i.totalSize;for(;;){let p=this.reader.requestSliceRange(f,Ye,wt);if(p instanceof Promise&&(p=await p),!p)return null;const g=zt(p);if(!g)return null;if(i=g,i.serialNumber===e.serialNumber)break;f=i.headerStartPos+i.totalSize}n=0,a=0,s=0}const c=o.reduce((d,h)=>d+h.length,0),l=new Uint8Array(c);let u=0;for(let d=0;d<o.length;d++){const h=o[d];l.set(h,u),u+=h.length}return{data:l,endPage:i,endSegmentIndex:s}}async findNextPacketStart(e){if(e.endSegmentIndex<e.endPage.lacingValues.length-1)return{startPage:e.endPage,startSegmentIndex:e.endSegmentIndex+1};if(!!(e.endPage.headerType&4))return null;let n=e.endPage.headerStartPos+e.endPage.totalSize;for(;;){let i=this.reader.requestSliceRange(n,Ye,wt);if(i instanceof Promise&&(i=await i),!i)return null;const a=zt(i);if(!a)return null;if(a.serialNumber===e.endPage.serialNumber)return{startPage:a,startSegmentIndex:0};n=a.headerStartPos+a.totalSize}}async getMimeType(){await this.readMetadata();const e=await Promise.all(this.tracks.map(r=>r.getCodecParameterString()));return Ba({codecStrings:e.filter(Boolean)})}async getTracks(){return await this.readMetadata(),this.tracks}async computeDuration(){const e=await this.getTracks(),r=await Promise.all(e.map(n=>n.computeDuration()));return Math.max(0,...r)}async getMetadataTags(){return await this.readMetadata(),this.metadataTags}}class Ma{constructor(e,r){this.bitstream=e,this.demuxer=r,this.encodedPacketToMetadata=new WeakMap,this.sequentialScanCache=[],this.sequentialScanMutex=new je,this.internalSampleRate=e.codecInfo.codec==="opus"?dr:e.sampleRate}getId(){return this.bitstream.serialNumber}getNumberOfChannels(){return this.bitstream.numberOfChannels}getSampleRate(){return this.bitstream.sampleRate}getTimeResolution(){return this.bitstream.sampleRate}getCodec(){return this.bitstream.codecInfo.codec}getInternalCodecId(){return null}async getDecoderConfig(){return m(this.bitstream.codecInfo.codec),{codec:this.bitstream.codecInfo.codec,numberOfChannels:this.bitstream.numberOfChannels,sampleRate:this.bitstream.sampleRate,description:this.bitstream.description??void 0}}getName(){return null}getLanguageCode(){return ue}async getFirstTimestamp(){return 0}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}granulePositionToTimestampInSamples(e){return this.bitstream.codecInfo.codec==="opus"?(m(this.bitstream.codecInfo.opusInfo),e-this.bitstream.codecInfo.opusInfo.preSkip):e}createEncodedPacketFromOggPacket(e,r,n){if(!e)return null;const{durationInSamples:i,vorbisBlockSize:a}=Aa(e.data,this.bitstream.codecInfo,r.vorbisLastBlocksize),s=new H(n.metadataOnly?fe:e.data,"key",Math.max(0,r.timestampInSamples)/this.internalSampleRate,i/this.internalSampleRate,e.endPage.headerStartPos+e.endSegmentIndex,e.data.byteLength);return this.encodedPacketToMetadata.set(s,{packet:e,timestampInSamples:r.timestampInSamples,durationInSamples:i,vorbisLastBlockSize:r.vorbisLastBlocksize,vorbisBlockSize:a}),s}async getFirstPacket(e){m(this.bitstream.lastMetadataPacket);const r=await this.demuxer.findNextPacketStart(this.bitstream.lastMetadataPacket);if(!r)return null;let n=0;this.bitstream.codecInfo.codec==="opus"&&(m(this.bitstream.codecInfo.opusInfo),n-=this.bitstream.codecInfo.opusInfo.preSkip);const i=await this.demuxer.readPacket(r.startPage,r.startSegmentIndex);return this.createEncodedPacketFromOggPacket(i,{timestampInSamples:n,vorbisLastBlocksize:null},e)}async getNextPacket(e,r){const n=this.encodedPacketToMetadata.get(e);if(!n)throw new Error("Packet was not created from this track.");const i=await this.demuxer.findNextPacketStart(n.packet);if(!i)return null;const a=n.timestampInSamples+n.durationInSamples,s=await this.demuxer.readPacket(i.startPage,i.startSegmentIndex);return this.createEncodedPacketFromOggPacket(s,{timestampInSamples:a,vorbisLastBlocksize:n.vorbisBlockSize},r)}async getPacket(e,r){if(this.demuxer.reader.fileSize===null)return this.getPacketSequential(e,r);const n=Jt(e*this.internalSampleRate,14);if(n===0)return this.getFirstPacket(r);if(n<0)return null;m(this.bitstream.lastMetadataPacket);const i=await this.demuxer.findNextPacketStart(this.bitstream.lastMetadataPacket);if(!i)return null;let a=i.startPage,s=this.demuxer.reader.fileSize;const o=[a];e:for(;a.headerStartPos+a.totalSize<s;){const k=a.headerStartPos,T=Math.floor((k+s)/2);let y=T;for(;;){const x=Math.min(y+za,s-Ye);let _=this.demuxer.reader.requestSlice(y,x-y);if(_ instanceof Promise&&(_=await _),m(_),!Ra(_,x)){s=T+Ye;continue e}let F=this.demuxer.reader.requestSliceRange(_.filePos,Ye,wt);F instanceof Promise&&(F=await F),m(F);const v=zt(F);m(v);let I=!1;if(v.serialNumber===this.bitstream.serialNumber)I=!0;else{let M=this.demuxer.reader.requestSlice(v.headerStartPos,v.totalSize);M instanceof Promise&&(M=await M),m(M);const W=O(M,v.totalSize);I=Fa(W)===v.checksum}if(!I){y=v.headerStartPos+4;continue}if(I&&v.serialNumber!==this.bitstream.serialNumber){y=v.headerStartPos+v.totalSize;continue}if(v.granulePosition===-1){y=v.headerStartPos+v.totalSize;continue}this.granulePositionToTimestampInSamples(v.granulePosition)>n?s=v.headerStartPos:(a=v,o.push(v));continue e}}let c=i.startPage;for(const k of o){if(k.granulePosition===a.granulePosition)break;(!c||k.headerStartPos>c.headerStartPos)&&(c=k)}let l=c;const u=[l];for(;!(l.serialNumber===this.bitstream.serialNumber&&l.granulePosition===a.granulePosition);){const k=l.headerStartPos+l.totalSize;let T=this.demuxer.reader.requestSliceRange(k,Ye,wt);T instanceof Promise&&(T=await T),m(T);const y=zt(T);m(y),l=y,l.serialNumber===this.bitstream.serialNumber&&u.push(l)}m(l.granulePosition!==-1);let d=null,h,f,p=l,g=0;if(l.headerStartPos===i.startPage.headerStartPos)h=this.granulePositionToTimestampInSamples(0),f=!0,d=0;else{h=0,f=!1;for(let y=l.lacingValues.length-1;y>=0;y--)if(l.lacingValues[y]<255){d=y+1;break}if(d===null)throw new Error("Invalid page with granule position: no packets end on this page.");g=d-1;const k={data:fe,endPage:p,endSegmentIndex:g};if(await this.demuxer.findNextPacketStart(k)){const y=zn(u,l,d);m(y);const x=Bn(u,y.page,y.segmentIndex);x&&(l=x.page,d=x.segmentIndex)}else for(;;){const y=zn(u,l,d);if(!y)break;const x=Bn(u,y.page,y.segmentIndex);if(!x)break;if(l=x.page,d=x.segmentIndex,y.page.headerStartPos!==p.headerStartPos){p=y.page,g=y.segmentIndex;break}}}let b=null,w=null;for(;l!==null;){m(d!==null);const k=await this.demuxer.readPacket(l,d);if(!k)break;if(!(l.headerStartPos===i.startPage.headerStartPos&&d<i.startSegmentIndex)){let x=this.createEncodedPacketFromOggPacket(k,{timestampInSamples:h,vorbisLastBlocksize:w?.vorbisBlockSize??null},r);m(x);let _=this.encodedPacketToMetadata.get(x);if(m(_),!f&&k.endPage.headerStartPos===p.headerStartPos&&k.endSegmentIndex===g?(h=this.granulePositionToTimestampInSamples(l.granulePosition),f=!0,x=this.createEncodedPacketFromOggPacket(k,{timestampInSamples:h-_.durationInSamples,vorbisLastBlocksize:w?.vorbisBlockSize??null},r),m(x),_=this.encodedPacketToMetadata.get(x),m(_)):h+=_.durationInSamples,b=x,w=_,f&&(Math.max(h,0)>n||Math.max(_.timestampInSamples,0)===n))break}const y=await this.demuxer.findNextPacketStart(k);if(!y)break;l=y.startPage,d=y.startSegmentIndex}return b}async getPacketSequential(e,r){const n=await this.sequentialScanMutex.acquire();try{const i=Jt(e*this.internalSampleRate,14);e=i/this.internalSampleRate;const a=L(this.sequentialScanCache,i,c=>c.timestampInSamples);let s;if(a!==-1){const c=this.sequentialScanCache[a];s=this.createEncodedPacketFromOggPacket(c.packet,{timestampInSamples:c.timestampInSamples,vorbisLastBlocksize:c.vorbisLastBlockSize},r)}else s=await this.getFirstPacket(r);let o=0;for(;s&&s.timestamp<e;){const c=await this.getNextPacket(s,r);if(!c||c.timestamp>e)break;if(s=c,o++,o===100){o=0;const l=this.encodedPacketToMetadata.get(s);m(l),this.sequentialScanCache.length>0&&m($(this.sequentialScanCache).timestampInSamples<=l.timestampInSamples),this.sequentialScanCache.push(l)}}return s}finally{n()}}getKeyPacket(e,r){return this.getPacket(e,r)}getNextKeyPacket(e,r){return this.getNextPacket(e,r)}}const Bn=(t,e,r)=>{let n=e,i=r;e:for(;;){for(i--,i;i>=0;i--)if(n.lacingValues[i]<255){i++;break e}if(m(i===-1),!(n.headerType&1)){i=0;break}const s=ti(t,o=>o.headerStartPos<n.headerStartPos);if(!s)return null;n=s,i=n.lacingValues.length}if(m(i!==-1),i===n.lacingValues.length){const a=t[t.indexOf(n)+1];m(a),n=a,i=0}return{page:n,segmentIndex:i}},zn=(t,e,r)=>{if(r>0)return{page:e,segmentIndex:r-1};const n=ti(t,i=>i.headerStartPos<e.headerStartPos);return n?{page:n,segmentIndex:n.lacingValues.length-1}:null};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */var Ie;(function(t){t[t.PCM=1]="PCM",t[t.IEEE_FLOAT=3]="IEEE_FLOAT",t[t.ALAW=6]="ALAW",t[t.MULAW=7]="MULAW",t[t.EXTENSIBLE=65534]="EXTENSIBLE"})(Ie||(Ie={}));class Oa extends tt{constructor(e){super(e),this.metadataPromise=null,this.dataStart=-1,this.dataSize=-1,this.audioInfo=null,this.tracks=[],this.lastKnownPacketIndex=0,this.metadataTags={},this.reader=e._reader}async readMetadata(){return this.metadataPromise??=(async()=>{let e=this.reader.requestSlice(0,12);e instanceof Promise&&(e=await e),m(e);const r=X(e,4),n=r!=="RIFX",i=r==="RF64",a=Le(e,n);let s=i?this.reader.fileSize:Math.min(a+8,this.reader.fileSize??1/0);if(X(e,4)!=="WAVE")throw new Error("Invalid WAVE file - wrong format");let c=0,l=null,u=e.filePos;for(;s===null||u<s;){let h=this.reader.requestSlice(u,8);if(h instanceof Promise&&(h=await h),!h)break;const f=X(h,4),p=Le(h,n),g=h.filePos;if(i&&c===0&&f!=="ds64")throw new Error('Invalid RF64 file: First chunk must be "ds64".');if(f==="fmt ")await this.parseFmtChunk(g,p,n);else if(f==="data"){if(l??=p,this.dataStart=h.filePos,this.dataSize=Math.min(l,(s??1/0)-this.dataStart),this.reader.fileSize===null)break}else if(f==="ds64"){let b=this.reader.requestSlice(g,p);if(b instanceof Promise&&(b=await b),!b)break;const w=Rn(b,n);l=Rn(b,n),s=Math.min(w+8,this.reader.fileSize??1/0)}else f==="LIST"?await this.parseListChunk(g,p,n):(f==="ID3 "||f==="id3 ")&&await this.parseId3Chunk(g,p);u=g+p+(p&1),c++}if(!this.audioInfo)throw new Error('Invalid WAVE file - missing "fmt " chunk');if(this.dataStart===-1)throw new Error('Invalid WAVE file - missing "data" chunk');const d=this.audioInfo.blockSizeInBytes;this.dataSize=Math.floor(this.dataSize/d)*d,this.tracks.push(new ze(this.input,new Na(this)))})()}async parseFmtChunk(e,r,n){let i=this.reader.requestSlice(e,r);if(i instanceof Promise&&(i=await i),!i)return;let a=vt(i,n);const s=vt(i,n),o=Le(i,n);i.skip(4);const c=vt(i,n);let l;if(r===14?l=8:l=vt(i,n),r>=18&&a!==357){const u=vt(i,n),d=r-18;if(Math.min(d,u)>=22&&a===Ie.EXTENSIBLE){i.skip(6);const f=O(i,16);a=f[0]|f[1]<<8}}(a===Ie.MULAW||a===Ie.ALAW)&&(l=8),this.audioInfo={format:a,numberOfChannels:s,sampleRate:o,sampleSizeInBytes:Math.ceil(l/8),blockSizeInBytes:c}}async parseListChunk(e,r,n){let i=this.reader.requestSlice(e,r);if(i instanceof Promise&&(i=await i),!i)return;const a=X(i,4);if(a!=="INFO"&&a!=="INF0")return;let s=i.filePos;for(;s<=e+r-8;){i.filePos=s;const o=X(i,4),c=Le(i,n),l=O(i,c);let u=0;for(let h=0;h<l.length&&l[h]!==0;h++)u++;const d=String.fromCharCode(...l.subarray(0,u));switch(this.metadataTags.raw??={},this.metadataTags.raw[o]=d,o){case"INAM":case"TITL":this.metadataTags.title??=d;break;case"TIT3":this.metadataTags.description??=d;break;case"IART":this.metadataTags.artist??=d;break;case"IPRD":this.metadataTags.album??=d;break;case"IPRT":case"ITRK":case"TRCK":{const h=d.split("/"),f=Number.parseInt(h[0],10),p=h[1]&&Number.parseInt(h[1],10);Number.isInteger(f)&&f>0&&(this.metadataTags.trackNumber??=f),p&&Number.isInteger(p)&&p>0&&(this.metadataTags.tracksTotal??=p)}break;case"ICRD":case"IDIT":{const h=new Date(d);Number.isNaN(h.getTime())||(this.metadataTags.date??=h)}break;case"YEAR":{const h=Number.parseInt(d,10);Number.isInteger(h)&&h>0&&(this.metadataTags.date??=new Date(h,0,1))}break;case"IGNR":case"GENR":this.metadataTags.genre??=d;break;case"ICMT":case"CMNT":case"COMM":this.metadataTags.comment??=d;break}s+=8+c+(c&1)}}async parseId3Chunk(e,r){let n=this.reader.requestSlice(e,r);if(n instanceof Promise&&(n=await n),!n)return;const i=ir(n);if(i){const a=n.slice(e+10,i.size);zi(a,i,this.metadataTags)}}getCodec(){if(m(this.audioInfo),this.audioInfo.format===Ie.MULAW)return"ulaw";if(this.audioInfo.format===Ie.ALAW)return"alaw";if(this.audioInfo.format===Ie.PCM){if(this.audioInfo.sampleSizeInBytes===1)return"pcm-u8";if(this.audioInfo.sampleSizeInBytes===2)return"pcm-s16";if(this.audioInfo.sampleSizeInBytes===3)return"pcm-s24";if(this.audioInfo.sampleSizeInBytes===4)return"pcm-s32"}return this.audioInfo.format===Ie.IEEE_FLOAT&&this.audioInfo.sampleSizeInBytes===4?"pcm-f32":null}async getMimeType(){return"audio/wav"}async computeDuration(){await this.readMetadata();const e=this.tracks[0];return m(e),e.computeDuration()}async getTracks(){return await this.readMetadata(),this.tracks}async getMetadataTags(){return await this.readMetadata(),this.metadataTags}}const at=2048;class Na{constructor(e){this.demuxer=e}getId(){return 1}getCodec(){return this.demuxer.getCodec()}getInternalCodecId(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.format}async getDecoderConfig(){const e=this.demuxer.getCodec();return e?(m(this.demuxer.audioInfo),{codec:e,numberOfChannels:this.demuxer.audioInfo.numberOfChannels,sampleRate:this.demuxer.audioInfo.sampleRate}):null}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}getNumberOfChannels(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.numberOfChannels}getSampleRate(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}getTimeResolution(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}getName(){return null}getLanguageCode(){return ue}async getFirstTimestamp(){return 0}async getPacketAtIndex(e,r){m(this.demuxer.audioInfo);const n=e*at*this.demuxer.audioInfo.blockSizeInBytes;if(n>=this.demuxer.dataSize)return null;const i=Math.min(at*this.demuxer.audioInfo.blockSizeInBytes,this.demuxer.dataSize-n);if(this.demuxer.reader.fileSize===null){let c=this.demuxer.reader.requestSlice(this.demuxer.dataStart+n,i);if(c instanceof Promise&&(c=await c),!c)return null}let a;if(r.metadataOnly)a=fe;else{let c=this.demuxer.reader.requestSlice(this.demuxer.dataStart+n,i);c instanceof Promise&&(c=await c),m(c),a=O(c,i)}const s=e*at/this.demuxer.audioInfo.sampleRate,o=i/this.demuxer.audioInfo.blockSizeInBytes/this.demuxer.audioInfo.sampleRate;return this.demuxer.lastKnownPacketIndex=Math.max(e,s),new H(a,"key",s,o,e,i)}getFirstPacket(e){return this.getPacketAtIndex(0,e)}async getPacket(e,r){m(this.demuxer.audioInfo);const n=Math.floor(Math.min(e*this.demuxer.audioInfo.sampleRate/at,(this.demuxer.dataSize-1)/(at*this.demuxer.audioInfo.blockSizeInBytes))),i=await this.getPacketAtIndex(n,r);if(i)return i;if(n===0)return null;m(this.demuxer.reader.fileSize===null);let a=await this.getPacketAtIndex(this.demuxer.lastKnownPacketIndex,r);for(;a;){const s=await this.getNextPacket(a,r);if(!s)break;a=s}return a}getNextPacket(e,r){m(this.demuxer.audioInfo);const n=Math.round(e.timestamp*this.demuxer.audioInfo.sampleRate/at);return this.getPacketAtIndex(n+1,r)}getKeyPacket(e,r){return this.getPacket(e,r)}getNextKeyPacket(e,r){return this.getNextPacket(e,r)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const sr=7,ar=9,Lr=t=>{const e=t.filePos,r=O(t,9),n=new j(r);if(n.readBits(12)!==4095||(n.skipBits(1),n.readBits(2)!==0))return null;const s=n.readBits(1),o=n.readBits(2)+1,c=n.readBits(4);if(c===15)return null;n.skipBits(1);const l=n.readBits(3);if(l===0)throw new Error("ADTS frames with channel configuration 0 are not supported.");n.skipBits(1),n.skipBits(1),n.skipBits(1),n.skipBits(1);const u=n.readBits(13);n.skipBits(11);const d=n.readBits(2)+1;if(d!==1)throw new Error("ADTS frames with more than one AAC frame are not supported.");let h=null;return s===1?t.filePos-=2:h=n.readBits(16),{objectType:o,samplingFrequencyIndex:c,channelConfiguration:l,frameLength:u,numberOfAacFrames:d,crcCheck:h,startPos:e}};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Hr=1024;class Va extends tt{constructor(e){super(e),this.metadataPromise=null,this.firstFrameHeader=null,this.loadedSamples=[],this.tracks=[],this.readingMutex=new je,this.lastSampleLoaded=!1,this.lastLoadedPos=0,this.nextTimestampInSamples=0,this.reader=e._reader}async readMetadata(){return this.metadataPromise??=(async()=>{for(;!this.firstFrameHeader&&!this.lastSampleLoaded;)await this.advanceReader();m(this.firstFrameHeader),this.tracks=[new ze(this.input,new Ua(this))]})()}async advanceReader(){let e=this.reader.requestSliceRange(this.lastLoadedPos,sr,ar);if(e instanceof Promise&&(e=await e),!e){this.lastSampleLoaded=!0;return}const r=Lr(e);if(!r){this.lastSampleLoaded=!0;return}if(this.reader.fileSize!==null&&r.startPos+r.frameLength>this.reader.fileSize){this.lastSampleLoaded=!0;return}this.firstFrameHeader||(this.firstFrameHeader=r);const n=tr[r.samplingFrequencyIndex];m(n!==void 0);const i=Hr/n,a=r.crcCheck?ar:sr,s={timestamp:this.nextTimestampInSamples/n,duration:i,dataStart:r.startPos+a,dataSize:r.frameLength-a};this.loadedSamples.push(s),this.nextTimestampInSamples+=Hr,this.lastLoadedPos=r.startPos+r.frameLength}async getMimeType(){return"audio/aac"}async getTracks(){return await this.readMetadata(),this.tracks}async computeDuration(){await this.readMetadata();const e=this.tracks[0];return m(e),e.computeDuration()}async getMetadataTags(){return{}}}class Ua{constructor(e){this.demuxer=e}getId(){return 1}async getFirstTimestamp(){return 0}getTimeResolution(){return this.getSampleRate()/Hr}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}getName(){return null}getLanguageCode(){return ue}getCodec(){return"aac"}getInternalCodecId(){return m(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.objectType}getNumberOfChannels(){m(this.demuxer.firstFrameHeader);const e=li[this.demuxer.firstFrameHeader.channelConfiguration];return m(e!==void 0),e}getSampleRate(){m(this.demuxer.firstFrameHeader);const e=tr[this.demuxer.firstFrameHeader.samplingFrequencyIndex];return m(e!==void 0),e}async getDecoderConfig(){m(this.demuxer.firstFrameHeader);const e=new Uint8Array(3),r=new j(e),{objectType:n,samplingFrequencyIndex:i,channelConfiguration:a}=this.demuxer.firstFrameHeader;return n>31?(r.writeBits(5,31),r.writeBits(6,n-32)):r.writeBits(5,n),r.writeBits(4,i),r.writeBits(4,a),{codec:`mp4a.40.${this.demuxer.firstFrameHeader.objectType}`,numberOfChannels:this.getNumberOfChannels(),sampleRate:this.getSampleRate(),description:e.subarray(0,Math.ceil((r.pos-1)/8))}}async getPacketAtIndex(e,r){if(e===-1)return null;const n=this.demuxer.loadedSamples[e];if(!n)return null;let i;if(r.metadataOnly)i=fe;else{let a=this.demuxer.reader.requestSlice(n.dataStart,n.dataSize);if(a instanceof Promise&&(a=await a),!a)return null;i=O(a,n.dataSize)}return new H(i,"key",n.timestamp,n.duration,e,n.dataSize)}getFirstPacket(e){return this.getPacketAtIndex(0,e)}async getNextPacket(e,r){const n=await this.demuxer.readingMutex.acquire();try{const i=K(this.demuxer.loadedSamples,e.timestamp,s=>s.timestamp);if(i===-1)throw new Error("Packet was not created from this track.");const a=i+1;for(;a>=this.demuxer.loadedSamples.length&&!this.demuxer.lastSampleLoaded;)await this.demuxer.advanceReader();return this.getPacketAtIndex(a,r)}finally{n()}}async getPacket(e,r){const n=await this.demuxer.readingMutex.acquire();try{for(;;){const i=L(this.demuxer.loadedSamples,e,a=>a.timestamp);if(i===-1&&this.demuxer.loadedSamples.length>0)return null;if(this.demuxer.lastSampleLoaded)return this.getPacketAtIndex(i,r);if(i>=0&&i+1<this.demuxer.loadedSamples.length)return this.getPacketAtIndex(i,r);await this.demuxer.advanceReader()}}finally{n()}}getKeyPacket(e,r){return this.getPacket(e,r)}getNextKeyPacket(e,r){return this.getNextPacket(e,r)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Wa=t=>t===0?null:t===1?192:t>=2&&t<=5?144*2**t:t===6?"uncommon-u8":t===7?"uncommon-u16":t>=8&&t<=15?2**t:null,La=(t,e)=>{switch(t){case 0:return e;case 1:return 88200;case 2:return 176400;case 3:return 192e3;case 4:return 8e3;case 5:return 16e3;case 6:return 22050;case 7:return 24e3;case 8:return 32e3;case 9:return 44100;case 10:return 48e3;case 11:return 96e3;case 12:return"uncommon-u8";case 13:return"uncommon-u16";case 14:return"uncommon-u16-10";default:return null}},Ha=t=>{let e=0;const r=new j(O(t,1));for(;r.readBits(1)===1;)e++;if(e===0)return r.readBits(7);const n=[],i=e-1,a=new j(O(t,i)),s=8-e-1;for(let c=0;c<s;c++)n.unshift(r.readBits(1));for(let c=0;c<i;c++)for(let l=0;l<8;l++){const u=a.readBits(1);l<2||n.unshift(u)}return n.reduce((c,l,u)=>c|l<<u,0)},qa=(t,e)=>{if(e==="uncommon-u16")return Z(t)+1;if(e==="uncommon-u8")return z(t)+1;if(typeof e=="number")return e;$e(e),m(!1)},$a=(t,e)=>e==="uncommon-u16"?Z(t):e==="uncommon-u16-10"?Z(t)*10:e==="uncommon-u8"?z(t):typeof e=="number"?e:null,ja=t=>{let r=0;for(const n of t){r^=n;for(let i=0;i<8;i++)(r&128)!==0?r=r<<1^7:r<<=1,r&=255}return r};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Ka extends tt{constructor(e){super(e),this.loadedSamples=[],this.metadataPromise=null,this.track=null,this.metadataTags={},this.audioInfo=null,this.lastLoadedPos=null,this.blockingBit=null,this.readingMutex=new je,this.lastSampleLoaded=!1,this.reader=e._reader}async computeDuration(){return await this.readMetadata(),m(this.track),this.track.computeDuration()}async getMetadataTags(){return await this.readMetadata(),this.metadataTags}async getTracks(){return await this.readMetadata(),m(this.track),[this.track]}async getMimeType(){return"audio/flac"}async readMetadata(){let e=4;return this.metadataPromise??=(async()=>{for(;this.reader.fileSize===null||e<this.reader.fileSize;){let r=this.reader.requestSlice(e,4);if(r instanceof Promise&&(r=await r),e+=4,r===null)throw new Error(`Metadata block at position ${e} is too small! Corrupted file.`);m(r);const n=z(r),i=dt(r),a=(n&128)!==0;switch(n&127){case bt.STREAMINFO:{let o=this.reader.requestSlice(e,i);if(o instanceof Promise&&(o=await o),m(o),o===null)throw new Error(`StreamInfo block at position ${e} is too small! Corrupted file.`);const c=O(o,34),l=new j(c),u=l.readBits(16),d=l.readBits(16),h=l.readBits(24),f=l.readBits(24),p=l.readBits(20),g=l.readBits(3)+1;l.readBits(5);const b=l.readBits(36);l.skipBits(16*8);const w=new Uint8Array(42);w.set(new Uint8Array([102,76,97,67]),0),w.set(new Uint8Array([128,0,0,34]),4),w.set(c,8),this.audioInfo={numberOfChannels:g,sampleRate:p,totalSamples:b,minimumBlockSize:u,maximumBlockSize:d,minimumFrameSize:h,maximumFrameSize:f,description:w},this.track=new ze(this.input,new Qa(this));break}case bt.VORBIS_COMMENT:{let o=this.reader.requestSlice(e,i);o instanceof Promise&&(o=await o),m(o),zr(O(o,i),this.metadataTags);break}case bt.PICTURE:{let o=this.reader.requestSlice(e,i);o instanceof Promise&&(o=await o),m(o);const c=E(o),l=E(o),u=he.decode(O(o,l)),d=E(o),h=he.decode(O(o,d));o.skip(16);const f=E(o),p=O(o,f);this.metadataTags.images??=[],this.metadataTags.images.push({data:p,mimeType:u,kind:c===3?"coverFront":c===4?"coverBack":"unknown",description:h});break}}if(e+=i,a){this.lastLoadedPos=e;break}}})()}async readNextFlacFrame({startPos:e,isFirstPacket:r}){m(this.audioInfo);const n=6,a=this.audioInfo.maximumFrameSize+16,s=await this.reader.requestSliceRange(e,this.audioInfo.minimumFrameSize,a);if(!s)return null;const o=this.readFlacFrameHeader({slice:s,isFirstPacket:r});if(!o)return null;for(s.filePos=e+this.audioInfo.minimumFrameSize;;){if(s.filePos>s.end-n)return{num:o.num,blockSize:o.blockSize,sampleRate:o.sampleRate,size:s.end-e,isLastFrame:!0};if(z(s)===255){const l=z(s),u=this.blockingBit===1?249:248;if(l!==u){s.skip(-1);continue}s.skip(-2);const d=s.filePos-e;if(!this.readFlacFrameHeader({slice:s,isFirstPacket:!1})){s.skip(-1);continue}return{num:o.num,blockSize:o.blockSize,sampleRate:o.sampleRate,size:d,isLastFrame:!1}}}}readFlacFrameHeader({slice:e,isFirstPacket:r}){const n=e.filePos,i=O(e,4),a=new j(i);if(a.readBits(15)!==32764)return null;if(this.blockingBit===null){m(r);const b=a.readBits(1);this.blockingBit=b}else if(this.blockingBit===1){if(m(!r),a.readBits(1)!==1)return null}else if(this.blockingBit===0){if(m(!r),a.readBits(1)!==0)return null}else throw new Error("Invalid blocking bit");const o=Wa(a.readBits(4));if(!o)return null;m(this.audioInfo);const c=La(a.readBits(4),this.audioInfo.sampleRate);if(!c||(a.readBits(4),a.readBits(3),a.readBits(1)!==0))return null;const u=Ha(e),d=qa(e,o),h=$a(e,c);if(h===null)return null;const f=e.filePos-n,p=z(e);e.skip(-f),e.skip(-1);const g=ja(O(e,f));return p!==g?null:{num:u,blockSize:d,sampleRate:h}}async advanceReader(){await this.readMetadata(),m(this.lastLoadedPos!==null),m(this.audioInfo);const e=this.lastLoadedPos,r=await this.readNextFlacFrame({startPos:e,isFirstPacket:this.loadedSamples.length===0});if(!r){this.lastSampleLoaded=!0;return}const n=this.loadedSamples[this.loadedSamples.length-1],a={blockOffset:n?n.blockOffset+n.blockSize:0,blockSize:r.blockSize,byteOffset:e,byteSize:r.size};if(this.lastLoadedPos=this.lastLoadedPos+r.size,this.loadedSamples.push(a),r.isLastFrame){this.lastSampleLoaded=!0;return}}}class Qa{constructor(e){this.demuxer=e}getId(){return 1}getCodec(){return"flac"}getInternalCodecId(){return null}getNumberOfChannels(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.numberOfChannels}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}getSampleRate(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}getName(){return null}getLanguageCode(){return ue}getTimeResolution(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}async getFirstTimestamp(){return 0}async getDecoderConfig(){return m(this.demuxer.audioInfo),{codec:"flac",numberOfChannels:this.demuxer.audioInfo.numberOfChannels,sampleRate:this.demuxer.audioInfo.sampleRate,description:this.demuxer.audioInfo.description}}async getPacket(e,r){if(m(this.demuxer.audioInfo),e<0)throw new Error("Timestamp cannot be negative");const n=await this.demuxer.readingMutex.acquire();try{for(;;){const i=L(this.demuxer.loadedSamples,e,c=>c.blockOffset/this.demuxer.audioInfo.sampleRate);if(i===-1){await this.demuxer.advanceReader();continue}const a=this.demuxer.loadedSamples[i],s=a.blockOffset/this.demuxer.audioInfo.sampleRate,o=a.blockSize/this.demuxer.audioInfo.sampleRate;if(s+o<=e){if(this.demuxer.lastSampleLoaded)return this.getPacketAtIndex(this.demuxer.loadedSamples.length-1,r);await this.demuxer.advanceReader();continue}return this.getPacketAtIndex(i,r)}}finally{n()}}async getNextPacket(e,r){const n=await this.demuxer.readingMutex.acquire();try{const i=e.sequenceNumber+1;if(this.demuxer.lastSampleLoaded&&i>=this.demuxer.loadedSamples.length)return null;for(;i>=this.demuxer.loadedSamples.length&&!this.demuxer.lastSampleLoaded;)await this.demuxer.advanceReader();return this.getPacketAtIndex(i,r)}finally{n()}}getKeyPacket(e,r){return this.getPacket(e,r)}getNextKeyPacket(e,r){return this.getNextPacket(e,r)}async getPacketAtIndex(e,r){const n=this.demuxer.loadedSamples[e];if(!n)return null;let i;if(r.metadataOnly)i=fe;else{let o=this.demuxer.reader.requestSlice(n.byteOffset,n.byteSize);if(o instanceof Promise&&(o=await o),!o)return null;i=O(o,n.byteSize)}m(this.demuxer.audioInfo);const a=n.blockOffset/this.demuxer.audioInfo.sampleRate,s=n.blockSize/this.demuxer.audioInfo.sampleRate;return new H(i,"key",a,s,e,n.byteSize)}async getFirstPacket(e){for(;this.demuxer.loadedSamples.length===0&&!this.demuxer.lastSampleLoaded;)await this.demuxer.advanceReader();return this.getPacketAtIndex(0,e)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Qe{}class Mi extends Qe{async _getMajorBrand(e){let r=e._reader.requestSlice(0,12);return r instanceof Promise&&(r=await r),!r||(r.skip(4),X(r,4)!=="ftyp")?null:X(r,4)}_createDemuxer(e){return new na(e)}}class Ga extends Mi{async _canReadInput(e){const r=await this._getMajorBrand(e);return!!r&&r!=="qt  "}get name(){return"MP4"}get mimeType(){return"video/mp4"}}class Xa extends Mi{async _canReadInput(e){return await this._getMajorBrand(e)==="qt  "}get name(){return"QuickTime File Format"}get mimeType(){return"video/quicktime"}}class Oi extends Qe{async isSupportedEBMLOfDocType(e,r){let n=e._reader.requestSlice(0,Be);if(n instanceof Promise&&(n=await n),!n)return!1;const i=_i(n);if(i===null||i<1||i>8||V(n,i)!==S.EBML)return!1;const s=Ei(n);if(s===null)return!1;let o=e._reader.requestSlice(n.filePos,s);if(o instanceof Promise&&(o=await o),!o)return!1;const c=n.filePos;for(;o.filePos<=c+s-le;){const l=Fe(o);if(!l)break;const{id:u,size:d}=l,h=o.filePos;if(d===null)return!1;switch(u){case S.EBMLVersion:if(V(o,d)!==1)return!1;break;case S.EBMLReadVersion:if(V(o,d)!==1)return!1;break;case S.DocType:if(ut(o,d)!==r)return!1;break;case S.DocTypeVersion:if(V(o,d)>4)return!1;break}o.filePos=h+d}return!0}_canReadInput(e){return this.isSupportedEBMLOfDocType(e,"matroska")}_createDemuxer(e){return new ma(e)}get name(){return"Matroska"}get mimeType(){return"video/x-matroska"}}class Ya extends Oi{_canReadInput(e){return this.isSupportedEBMLOfDocType(e,"webm")}get name(){return"WebM"}get mimeType(){return"video/webm"}}class Za extends Qe{async _canReadInput(e){let r=e._reader.requestSlice(0,10);if(r instanceof Promise&&(r=await r),!r)return!1;let n=0,i=!1;for(;;){let l=e._reader.requestSlice(n,nr);if(l instanceof Promise&&(l=await l),!l)break;const u=ir(l);if(!u)break;i=!0,n=l.filePos+u.size}const a=await Wr(e._reader,n,n+4096);if(!a)return!1;if(i)return!0;n=a.startPos+a.header.totalSize;const s=await Wr(e._reader,n,n+Bi);if(!s)return!1;const o=a.header,c=s.header;return!(o.channel!==c.channel||o.sampleRate!==c.sampleRate)}_createDemuxer(e){return new _a(e)}get name(){return"MP3"}get mimeType(){return"audio/mpeg"}}class Ja extends Qe{async _canReadInput(e){let r=e._reader.requestSlice(0,12);if(r instanceof Promise&&(r=await r),!r)return!1;const n=X(r,4);return n!=="RIFF"&&n!=="RIFX"&&n!=="RF64"?!1:(r.skip(4),X(r,4)==="WAVE")}_createDemuxer(e){return new Oa(e)}get name(){return"WAVE"}get mimeType(){return"audio/wav"}}class eo extends Qe{async _canReadInput(e){let r=e._reader.requestSlice(0,4);return r instanceof Promise&&(r=await r),r?X(r,4)==="OggS":!1}_createDemuxer(e){return new Da(e)}get name(){return"Ogg"}get mimeType(){return"application/ogg"}}class to extends Qe{async _canReadInput(e){let r=e._reader.requestSlice(0,4);return r instanceof Promise&&(r=await r),r?X(r,4)==="fLaC":!1}get name(){return"FLAC"}get mimeType(){return"audio/flac"}_createDemuxer(e){return new Ka(e)}}class ro extends Qe{async _canReadInput(e){let r=e._reader.requestSliceRange(0,sr,ar);if(r instanceof Promise&&(r=await r),!r)return!1;const n=Lr(r);if(!n||(r=e._reader.requestSliceRange(n.frameLength,sr,ar),r instanceof Promise&&(r=await r),!r))return!1;const i=Lr(r);return i?n.objectType===i.objectType&&n.samplingFrequencyIndex===i.samplingFrequencyIndex&&n.channelConfiguration===i.channelConfiguration:!1}_createDemuxer(e){return new Va(e)}get name(){return"ADTS"}get mimeType(){return"audio/aac"}}const no=new Ga,io=new Xa,so=new Oi,ao=new Ya,oo=new Za,co=new Ja,lo=new eo,uo=new ro,ho=new to,fo=[no,io,so,ao,co,lo,ho,oo,uo];/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class nn{constructor(){this._disposed=!1,this._sizePromise=null,this.onread=null}async getSizeOrNull(){if(this._disposed)throw new ce;return this._sizePromise??=Promise.resolve(this._retrieveSize())}async getSize(){if(this._disposed)throw new ce;const e=await this.getSizeOrNull();if(e===null)throw new Error("Cannot determine the size of an unsized source.");return e}}class mo extends nn{constructor(e,r={}){if(!(e instanceof Blob))throw new TypeError("blob must be a Blob.");if(!r||typeof r!="object")throw new TypeError("options must be an object.");if(r.maxCacheSize!==void 0&&(!Number.isInteger(r.maxCacheSize)||r.maxCacheSize<0))throw new TypeError("options.maxCacheSize, when provided, must be a non-negative integer.");super(),this._readers=new WeakMap,this._blob=e,this._orchestrator=new Ui({maxCacheSize:r.maxCacheSize??8*2**20,maxWorkerCount:4,runWorker:this._runWorker.bind(this),prefetchProfile:Vi.fileSystem})}_retrieveSize(){const e=this._blob.size;return this._orchestrator.fileSize=e,e}_read(e,r){return this._orchestrator.read(e,r)}async _runWorker(e){let r=this._readers.get(e);for(r===void 0&&("stream"in this._blob?r=this._blob.slice(e.currentPos).stream().getReader():r=null,this._readers.set(e,r));e.currentPos<e.targetPos&&!e.aborted;)if(r){const{done:n,value:i}=await r.read();if(n){if(this._orchestrator.forgetWorker(e),e.currentPos<e.targetPos)throw new Error("Blob reader stopped unexpectedly before all requested data was read.");break}this.onread?.(e.currentPos,e.currentPos+i.length),this._orchestrator.supplyWorkerData(e,i)}else{const n=await this._blob.slice(e.currentPos,e.targetPos).arrayBuffer();this.onread?.(e.currentPos,e.currentPos+n.byteLength),this._orchestrator.supplyWorkerData(e,new Uint8Array(n))}e.running=!1}_dispose(){this._orchestrator.dispose()}}const Ni=.5*2**20,po=t=>Math.min(2**(t-2),16);class go extends nn{constructor(e,r={}){if(typeof e!="string"&&!(e instanceof URL)&&!(typeof Request<"u"&&e instanceof Request))throw new TypeError("url must be a string, URL or Request.");if(!r||typeof r!="object")throw new TypeError("options must be an object.");if(r.requestInit!==void 0&&(!r.requestInit||typeof r.requestInit!="object"))throw new TypeError("options.requestInit, when provided, must be an object.");if(r.getRetryDelay!==void 0&&typeof r.getRetryDelay!="function")throw new TypeError("options.getRetryDelay, when provided, must be a function.");if(r.maxCacheSize!==void 0&&(!Number.isInteger(r.maxCacheSize)||r.maxCacheSize<0))throw new TypeError("options.maxCacheSize, when provided, must be a non-negative integer.");if(r.fetchFn!==void 0&&typeof r.fetchFn!="function")throw new TypeError("options.fetchFn, when provided, must be a function.");super(),this._existingResponses=new WeakMap,this._url=e,this._options=r,this._getRetryDelay=r.getRetryDelay??po,this._orchestrator=new Ui({maxCacheSize:r.maxCacheSize??64*2**20,maxWorkerCount:2,runWorker:this._runWorker.bind(this),prefetchProfile:Vi.network})}async _retrieveSize(){const e=new AbortController,r=await Tn(this._options.fetchFn??fetch,this._url,bn(this._options.requestInit??{},{headers:{Range:"bytes=0-"},signal:e.signal}),this._getRetryDelay);if(!r.ok)throw new Error(`Error fetching ${String(this._url)}: ${r.status} ${r.statusText}`);let n,i;if(r.status===206)i=this._getPartialLengthFromRangeResponse(r),n=this._orchestrator.createWorker(0,Math.min(i,Ni));else{const a=r.headers.get("Content-Length");if(a)i=Number(a),n=this._orchestrator.createWorker(0,i),this._orchestrator.options.maxCacheSize=1/0,console.warn("HTTP server did not respond with 206 Partial Content, meaning the entire remote resource now has to be downloaded. For efficient media file streaming across a network, please make sure your server supports range requests.");else throw new Error(`HTTP response (status ${r.status}) must surface Content-Length header.`)}return this._orchestrator.fileSize=i,this._existingResponses.set(n,{response:r,abortController:e}),this._orchestrator.runWorker(n),i}_read(e,r){return this._orchestrator.read(e,r)}async _runWorker(e){for(;!e.aborted;){const r=this._existingResponses.get(e);this._existingResponses.delete(e);let n=r?.abortController,i=r?.response;if(n||(n=new AbortController,i=await Tn(this._options.fetchFn??fetch,this._url,bn(this._options.requestInit??{},{headers:{Range:`bytes=${e.currentPos}-`},signal:n.signal}),this._getRetryDelay)),m(i),!i.ok)throw new Error(`Error fetching ${String(this._url)}: ${i.status} ${i.statusText}`);if(e.currentPos>0&&i.status!==206)throw new Error("HTTP server did not respond with 206 Partial Content to a range request. To enable efficient media file streaming across a network, please make sure your server supports range requests.");const a=this._getPartialLengthFromRangeResponse(i),s=e.targetPos-e.currentPos;if(a<s)throw new Error(`HTTP response unexpectedly too short: Needed at least ${s} bytes, got only ${a}.`);if(!i.body)throw new Error("Missing HTTP response body stream. The used fetch function must provide the response body as a ReadableStream.");const o=i.body.getReader();for(;;){if(e.currentPos>=e.targetPos||e.aborted){n.abort(),e.running=!1;return}let c;try{c=await o.read()}catch(d){const h=this._getRetryDelay(1,d);if(h!==null){console.error("Error while reading response stream. Attempting to resume.",d),await new Promise(f=>setTimeout(f,1e3*h));break}else throw d}const{done:l,value:u}=c;if(l){if(this._orchestrator.forgetWorker(e),e.currentPos<e.targetPos)throw new Error("Response stream reader stopped unexpectedly before all requested data was read.");e.running=!1;return}this.onread?.(e.currentPos,e.currentPos+u.length),this._orchestrator.supplyWorkerData(e,u)}}e.running=!1}_getPartialLengthFromRangeResponse(e){const r=e.headers.get("Content-Range");if(r){const n=/\/(\d+)/.exec(r);if(n)return Number(n[1]);throw new Error(`Invalid Content-Range header: ${r}`)}else{const n=e.headers.get("Content-Length");if(n)return Number(n);throw new Error("Partial HTTP response (status 206) must surface either Content-Range or Content-Length header.")}}_dispose(){this._orchestrator.dispose()}}const Vi={fileSystem:(t,e)=>(t=Math.floor((t-65536)/65536)*65536,e=Math.ceil((e+65536)/65536)*65536,{start:t,end:e}),network:(t,e,r)=>{t=Math.max(0,Math.floor((t-65536)/65536)*65536);for(const i of r){const s=Math.max((i.startPos+i.targetPos)/2,i.targetPos-8388608);if(Fr(t,e,s,i.targetPos)){const o=i.targetPos-i.startPos,c=Math.ceil((o+1)/8388608)*8388608,l=2**Math.ceil(Math.log2(o+1)),u=Math.min(l,c);e=Math.max(e,i.startPos+u)}}return e=Math.max(e,t+Ni),{start:t,end:e}}};class Ui{constructor(e){this.options=e,this.fileSize=null,this.nextAge=0,this.workers=[],this.cache=[],this.currentCacheSize=0}read(e,r){m(this.fileSize!==null);const n=this.options.prefetchProfile(e,r,this.workers),i=Math.max(n.start,0),a=Math.min(n.end,this.fileSize);m(i<=e&&r<=a);let s=null;const o=L(this.cache,e,k=>k.start),c=o!==-1?this.cache[o]:null;c&&c.start<=e&&r<=c.end&&(c.age=this.nextAge++,s={bytes:c.bytes,view:c.view,offset:c.start});const l=L(this.cache,i,k=>k.start),u=s?null:new Uint8Array(r-e);let d=0,h=i;const f=[];if(l!==-1){for(let k=l;k<this.cache.length;k++){const T=this.cache[k];if(T.start>=a)break;if(T.end<=i)continue;const y=Math.max(i,T.start),x=Math.min(a,T.end);if(m(y<=x),h<y&&f.push({start:h,end:y}),h=x,u){const _=Math.max(e,T.start),C=Math.min(r,T.end);if(_<C){const F=_-e;u.set(T.bytes.subarray(_-T.start,C-T.start),F),F===d&&(d=C-e)}}T.age=this.nextAge++}h<a&&f.push({start:h,end:a})}else f.push({start:i,end:a});if(u&&d>=u.length&&(s={bytes:u,view:te(u),offset:e}),f.length===0)return m(s),s;const{promise:p,resolve:g,reject:b}=ee(),w=[];for(const k of f){const T=Math.max(e,k.start),y=Math.min(r,k.end);T===k.start&&y===k.end?w.push(k):T<y&&w.push({start:T,end:y})}for(const k of f){const T=u&&{start:e,bytes:u,holes:w,resolve:g,reject:b};let y=!1;for(const x of this.workers)if(Fr(k.start-131072,k.start,x.currentPos,x.targetPos)){x.targetPos=Math.max(x.targetPos,k.end),y=!0,T&&!x.pendingSlices.includes(T)&&x.pendingSlices.push(T),x.running||this.runWorker(x);break}if(!y){const x=this.createWorker(k.start,k.end);T&&(x.pendingSlices=[T]),this.runWorker(x)}}return s||(m(u),s=p.then(k=>({bytes:k,view:te(k),offset:e}))),s}createWorker(e,r){const n={startPos:e,currentPos:e,targetPos:r,running:!1,aborted:!1,pendingSlices:[],age:this.nextAge++};for(this.workers.push(n);this.workers.length>this.options.maxWorkerCount;){let i=0,a=this.workers[0];for(let s=1;s<this.workers.length;s++){const o=this.workers[s];o.age<a.age&&(i=s,a=o)}if(a.running&&a.pendingSlices.length>0)break;a.aborted=!0,this.workers.splice(i,1)}return n}runWorker(e){m(!e.running),m(e.currentPos<e.targetPos),e.running=!0,e.age=this.nextAge++,this.options.runWorker(e).catch(r=>{if(e.running=!1,e.pendingSlices.length>0)e.pendingSlices.forEach(n=>n.reject(r)),e.pendingSlices.length=0;else throw r})}supplyWorkerData(e,r){const n=e.currentPos,i=n+r.length;this.insertIntoCache({start:n,end:i,bytes:r,view:te(r),age:this.nextAge++}),e.currentPos+=r.length,e.targetPos=Math.max(e.targetPos,e.currentPos);for(let a=0;a<e.pendingSlices.length;a++){const s=e.pendingSlices[a],o=Math.max(n,s.start),c=Math.min(i,s.start+s.bytes.length);o<c&&s.bytes.set(r.subarray(o-n,c-n),o-s.start);for(let l=0;l<s.holes.length;l++){const u=s.holes[l];n<=u.start&&i>u.start&&(u.start=i),u.end<=u.start&&(s.holes.splice(l,1),l--)}s.holes.length===0&&(s.resolve(s.bytes),e.pendingSlices.splice(a,1),a--)}for(let a=0;a<this.workers.length;a++){const s=this.workers[a];e===s||s.running||Fr(n,i,s.currentPos,s.targetPos)&&(this.workers.splice(a,1),a--)}}forgetWorker(e){const r=this.workers.indexOf(e);m(r!==-1),this.workers.splice(r,1)}insertIntoCache(e){if(this.options.maxCacheSize===0)return;let r=L(this.cache,e.start,n=>n.start)+1;if(r>0){const n=this.cache[r-1];if(n.end>=e.end)return;if(n.end>e.start){const i=new Uint8Array(e.end-n.start);i.set(n.bytes,0),i.set(e.bytes,e.start-n.start),this.currentCacheSize+=e.end-n.end,n.bytes=i,n.view=te(i),n.end=e.end,r--,e=n}else this.cache.splice(r,0,e),this.currentCacheSize+=e.bytes.length}else this.cache.splice(r,0,e),this.currentCacheSize+=e.bytes.length;for(let n=r+1;n<this.cache.length;n++){const i=this.cache[n];if(e.end<=i.start)break;if(e.end>=i.end){this.cache.splice(n,1),this.currentCacheSize-=i.bytes.length,n--;continue}const a=new Uint8Array(i.end-e.start);a.set(e.bytes,0),a.set(i.bytes,i.start-e.start),this.currentCacheSize-=e.end-i.start,e.bytes=a,e.view=te(a),e.end=i.end,this.cache.splice(n,1);break}for(;this.currentCacheSize>this.options.maxCacheSize;){let n=0,i=this.cache[0];for(let a=1;a<this.cache.length;a++){const s=this.cache[a];s.age<i.age&&(n=a,i=s)}if(this.currentCacheSize-i.bytes.length<=this.options.maxCacheSize)break;this.cache.splice(n,1),this.currentCacheSize-=i.bytes.length}}dispose(){for(const e of this.workers)e.aborted=!0;this.workers.length=0,this.cache.length=0}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */si();class Wi{get disposed(){return this._disposed}constructor(e){if(this._demuxerPromise=null,this._format=null,this._disposed=!1,!e||typeof e!="object")throw new TypeError("options must be an object.");if(!Array.isArray(e.formats)||e.formats.some(r=>!(r instanceof Qe)))throw new TypeError("options.formats must be an array of InputFormat.");if(!(e.source instanceof nn))throw new TypeError("options.source must be a Source.");if(e.source._disposed)throw new Error("options.source must not be disposed.");this._formats=e.formats,this._source=e.source,this._reader=new ko(e.source)}_getDemuxer(){return this._demuxerPromise??=(async()=>{this._reader.fileSize=await this._source.getSizeOrNull();for(const e of this._formats)if(await e._canReadInput(this))return this._format=e,e._createDemuxer(this);throw new Error("Input has an unsupported or unrecognizable format.")})()}get source(){return this._source}async getFormat(){return await this._getDemuxer(),m(this._format),this._format}async computeDuration(){return(await this._getDemuxer()).computeDuration()}async getTracks(){return(await this._getDemuxer()).getTracks()}async getVideoTracks(){return(await this.getTracks()).filter(r=>r.isVideoTrack())}async getAudioTracks(){return(await this.getTracks()).filter(r=>r.isAudioTrack())}async getPrimaryVideoTrack(){return(await this.getTracks()).find(r=>r.isVideoTrack())??null}async getPrimaryAudioTrack(){return(await this.getTracks()).find(r=>r.isAudioTrack())??null}async getMimeType(){return(await this._getDemuxer()).getMimeType()}async getMetadataTags(){return(await this._getDemuxer()).getMetadataTags()}dispose(){this._disposed||(this._disposed=!0,this._source._disposed=!0,this._source._dispose())}[Symbol.dispose](){this.dispose()}}class ce extends Error{constructor(e="Input has been disposed."){super(e),this.name="InputDisposedError"}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class ko{constructor(e){this.source=e}requestSlice(e,r){if(this.source._disposed)throw new ce;if(this.fileSize!==null&&e+r>this.fileSize)return null;const n=e+r,i=this.source._read(e,n);return i instanceof Promise?i.then(a=>a?new yt(a.bytes,a.view,a.offset,e,n):null):i?new yt(i.bytes,i.view,i.offset,e,n):null}requestSliceRange(e,r,n){if(this.source._disposed)throw new ce;if(this.fileSize!==null)return this.requestSlice(e,G(this.fileSize-e,r,n));{const i=this.requestSlice(e,n),a=s=>{if(s)return s;const o=l=>(m(l!==null),this.requestSlice(e,G(l-e,r,n))),c=this.source._retrieveSize();return c instanceof Promise?c.then(o):o(c)};return i instanceof Promise?i.then(a):a(i)}}}class yt{constructor(e,r,n,i,a){this.bytes=e,this.view=r,this.offset=n,this.start=i,this.end=a,this.bufferPos=i-n}static tempFromBytes(e){return new yt(e,te(e),0,0,e.length)}get length(){return this.end-this.start}get filePos(){return this.offset+this.bufferPos}set filePos(e){this.bufferPos=e-this.offset}get remainingLength(){return Math.max(this.end-this.filePos,0)}skip(e){this.bufferPos+=e}slice(e,r=this.end-e){if(e<this.start||e+r>this.end)throw new RangeError("Slicing outside of original slice.");return new yt(this.bytes,this.view,this.offset,e,e+r)}}const ae=(t,e)=>{if(t.filePos<t.start||t.filePos+e>t.end)throw new RangeError(`Tried reading [${t.filePos}, ${t.filePos+e}), but slice is [${t.start}, ${t.end}). This is likely an internal error, please report it alongside the file that caused it.`)},O=(t,e)=>{ae(t,e);const r=t.bytes.subarray(t.bufferPos,t.bufferPos+e);return t.bufferPos+=e,r},z=t=>(ae(t,1),t.view.getUint8(t.bufferPos++)),vt=(t,e)=>{ae(t,2);const r=t.view.getUint16(t.bufferPos,e);return t.bufferPos+=2,r},Z=t=>{ae(t,2);const e=t.view.getUint16(t.bufferPos,!1);return t.bufferPos+=2,e},dt=t=>{ae(t,3);const e=lr(t.view,t.bufferPos,!1);return t.bufferPos+=3,e},qr=t=>{ae(t,2);const e=t.view.getInt16(t.bufferPos,!1);return t.bufferPos+=2,e},Le=(t,e)=>{ae(t,4);const r=t.view.getUint32(t.bufferPos,e);return t.bufferPos+=4,r},E=t=>{ae(t,4);const e=t.view.getUint32(t.bufferPos,!1);return t.bufferPos+=4,e},pt=t=>{ae(t,4);const e=t.view.getUint32(t.bufferPos,!0);return t.bufferPos+=4,e},Ze=t=>{ae(t,4);const e=t.view.getInt32(t.bufferPos,!1);return t.bufferPos+=4,e},bo=t=>{ae(t,4);const e=t.view.getInt32(t.bufferPos,!0);return t.bufferPos+=4,e},Rn=(t,e)=>{let r,n;return e?(r=Le(t,!0),n=Le(t,!0)):(n=Le(t,!1),r=Le(t,!1)),n*4294967296+r},pe=t=>{const e=E(t),r=E(t);return e*4294967296+r},wo=t=>{const e=Ze(t),r=E(t);return e*4294967296+r},To=t=>{const e=pt(t);return bo(t)*4294967296+e},yo=t=>{ae(t,4);const e=t.view.getFloat32(t.bufferPos,!1);return t.bufferPos+=4,e},Li=t=>{ae(t,8);const e=t.view.getFloat64(t.bufferPos,!1);return t.bufferPos+=8,e},X=(t,e)=>{ae(t,e);let r="";for(let n=0;n<e;n++)r+=String.fromCharCode(t.bytes[t.bufferPos++]);return r};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Dn=/<(?:(\d{2}):)?(\d{2}):(\d{2}).(\d{3})>/g,So=t=>{const e=Math.floor(t/36e5),r=Math.floor(t%(60*60*1e3)/(60*1e3)),n=Math.floor(t%(60*1e3)/1e3),i=t%1e3;return e.toString().padStart(2,"0")+":"+r.toString().padStart(2,"0")+":"+n.toString().padStart(2,"0")+"."+i.toString().padStart(3,"0")};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Mn{constructor(e){this.writer=e,this.helper=new Uint8Array(8),this.helperView=new DataView(this.helper.buffer),this.offsets=new WeakMap}writeU32(e){this.helperView.setUint32(0,e,!1),this.writer.write(this.helper.subarray(0,4))}writeU64(e){this.helperView.setUint32(0,Math.floor(e/2**32),!1),this.helperView.setUint32(4,e,!1),this.writer.write(this.helper.subarray(0,8))}writeAscii(e){for(let r=0;r<e.length;r++)this.helperView.setUint8(r%8,e.charCodeAt(r)),r%8===7&&this.writer.write(this.helper);e.length%8!==0&&this.writer.write(this.helper.subarray(0,e.length%8))}writeBox(e){if(this.offsets.set(e,this.writer.getPos()),e.contents&&!e.children)this.writeBoxHeader(e,e.size??e.contents.byteLength+8),this.writer.write(e.contents);else{const r=this.writer.getPos();if(this.writeBoxHeader(e,0),e.contents&&this.writer.write(e.contents),e.children)for(const a of e.children)a&&this.writeBox(a);const n=this.writer.getPos(),i=e.size??n-r;this.writer.seek(r),this.writeBoxHeader(e,i),this.writer.seek(n)}}writeBoxHeader(e,r){this.writeU32(e.largeSize?1:r),this.writeAscii(e.type),e.largeSize&&this.writeU64(r)}measureBoxHeader(e){return 8+(e.largeSize?8:0)}patchBox(e){const r=this.offsets.get(e);m(r!==void 0);const n=this.writer.getPos();this.writer.seek(r),this.writeBox(e),this.writer.seek(n)}measureBox(e){if(e.contents&&!e.children)return this.measureBoxHeader(e)+e.contents.byteLength;{let r=this.measureBoxHeader(e);if(e.contents&&(r+=e.contents.byteLength),e.children)for(const n of e.children)n&&(r+=this.measureBox(n));return r}}}const N=new Uint8Array(8),ve=new DataView(N.buffer),q=t=>[(t%256+256)%256],R=t=>(ve.setUint16(0,t,!1),[N[0],N[1]]),Hi=t=>(ve.setInt16(0,t,!1),[N[0],N[1]]),qi=t=>(ve.setUint32(0,t,!1),[N[1],N[2],N[3]]),P=t=>(ve.setUint32(0,t,!1),[N[0],N[1],N[2],N[3]]),Ve=t=>(ve.setInt32(0,t,!1),[N[0],N[1],N[2],N[3]]),Je=t=>(ve.setUint32(0,Math.floor(t/2**32),!1),ve.setUint32(4,t,!1),[N[0],N[1],N[2],N[3],N[4],N[5],N[6],N[7]]),$i=t=>(ve.setInt16(0,2**8*t,!1),[N[0],N[1]]),Ae=t=>(ve.setInt32(0,2**16*t,!1),[N[0],N[1],N[2],N[3]]),yr=t=>(ve.setInt32(0,2**30*t,!1),[N[0],N[1],N[2],N[3]]),Sr=(t,e)=>{const r=[];let n=t;do{let i=n&127;n>>=7,r.length>0&&(i|=128),r.push(i)}while(n>0||e);return r.reverse()},J=(t,e=!1)=>{const r=Array(t.length).fill(null).map((n,i)=>t.charCodeAt(i));return e&&r.push(0),r},sn=t=>{let e=null;for(const r of t)(!e||r.timestamp>e.timestamp)&&(e=r);return e},ji=t=>{const e=t*(Math.PI/180),r=Math.round(Math.cos(e)),n=Math.round(Math.sin(e));return[r,n,0,-n,r,0,0,0,1]},Ki=ji(0),Qi=t=>[Ae(t[0]),Ae(t[1]),yr(t[2]),Ae(t[3]),Ae(t[4]),yr(t[5]),Ae(t[6]),Ae(t[7]),yr(t[8])],D=(t,e,r)=>({type:t,contents:e&&new Uint8Array(e.flat(10)),children:r}),U=(t,e,r,n,i)=>D(t,[q(e),qi(r),n??[]],i),xo=t=>t.isQuickTime?D("ftyp",[J("qt  "),P(512),J("qt  ")]):t.fragmented?D("ftyp",[J("iso5"),P(512),J("iso5"),J("iso6"),J("mp41")]):D("ftyp",[J("isom"),P(512),J("isom"),t.holdsAvc?J("avc1"):[],J("mp41")]),jt=t=>({type:"mdat",largeSize:t}),Co=t=>({type:"free",size:t}),_t=t=>D("moov",void 0,[Po(t.creationTime,t.trackDatas),...t.trackDatas.map(e=>vo(e,t.creationTime)),t.isFragmented?oc(t.trackDatas):null,Tc(t)]),Po=(t,e)=>{const r=Q(Math.max(0,...e.filter(s=>s.samples.length>0).map(s=>{const o=sn(s.samples);return o.timestamp+o.duration})),$r),n=Math.max(0,...e.map(s=>s.track.id))+1,i=!Tt(t)||!Tt(r),a=i?Je:P;return U("mvhd",+i,0,[a(t),a(t),P($r),a(r),Ae(1),$i(1),Array(10).fill(0),Qi(Ki),Array(24).fill(0),P(n)])},vo=(t,e)=>{const r=Bc(t);return D("trak",void 0,[_o(t,e),Eo(t,e),r.name!==void 0?D("udta",void 0,[D("name",[...ye.encode(r.name)])]):null])},_o=(t,e)=>{const r=sn(t.samples),n=Q(r?r.timestamp+r.duration:0,$r),i=!Tt(e)||!Tt(n),a=i?Je:P;let s;if(t.type==="video"){const o=t.track.metadata.rotation;s=ji(o??0)}else s=Ki;return U("tkhd",+i,3,[a(e),a(e),P(t.track.id),P(0),a(n),Array(8).fill(0),R(0),R(t.track.id),$i(t.type==="audio"?1:0),R(0),Qi(s),Ae(t.type==="video"?t.info.width:0),Ae(t.type==="video"?t.info.height:0)])},Eo=(t,e)=>D("mdia",void 0,[Io(t,e),an(!0,Fo[t.type],Ao[t.type]),Bo(t)]),Io=(t,e)=>{const r=sn(t.samples),n=Q(r?r.timestamp+r.duration:0,t.timescale),i=!Tt(e)||!Tt(n),a=i?Je:P;return U("mdhd",+i,0,[a(e),a(e),P(t.timescale),a(n),R(Zi(t.track.metadata.languageCode??ue)),R(0)])},Fo={video:"vide",audio:"soun",subtitle:"text"},Ao={video:"MediabunnyVideoHandler",audio:"MediabunnySoundHandler",subtitle:"MediabunnyTextHandler"},an=(t,e,r,n="\0\0\0\0")=>U("hdlr",0,0,[t?J("mhlr"):P(0),J(e),J(n),P(0),P(0),J(r,!0)]),Bo=t=>D("minf",void 0,[Mo[t.type](),Oo(),Uo(t)]),zo=()=>U("vmhd",0,1,[R(0),R(0),R(0),R(0)]),Ro=()=>U("smhd",0,0,[R(0),R(0)]),Do=()=>U("nmhd",0,0),Mo={video:zo,audio:Ro,subtitle:Do},Oo=()=>D("dinf",void 0,[No()]),No=()=>U("dref",0,0,[P(1)],[Vo()]),Vo=()=>U("url ",0,1),Uo=t=>{const e=t.compositionTimeOffsetTable.length>1||t.compositionTimeOffsetTable.some(r=>r.sampleCompositionTimeOffset!==0);return D("stbl",void 0,[Wo(t),ec(t),e?sc(t):null,e?ac(t):null,rc(t),nc(t),ic(t),tc(t)])},Wo=t=>{let e;if(t.type==="video")e=Lo(Cc[t.track.source._codec],t);else if(t.type==="audio"){const r=Yi(t.track.source._codec,t.muxer.isQuickTime);m(r),e=Ko(r,t)}else t.type==="subtitle"&&(e=Zo(_c[t.track.source._codec],t));return m(e),U("stsd",0,0,[P(1)],[e])},Lo=(t,e)=>D(t,[Array(6).fill(0),R(1),R(0),R(0),Array(12).fill(0),R(e.info.width),R(e.info.height),P(4718592),P(4718592),P(0),R(1),Array(32).fill(0),R(24),Hi(65535)],[Pc[e.track.source._codec](e),os(e.info.decoderConfig.colorSpace)?Ho(e):null]),Ho=t=>D("colr",[J("nclx"),R(Vt[t.info.decoderConfig.colorSpace.primaries]),R(Ut[t.info.decoderConfig.colorSpace.transfer]),R(Wt[t.info.decoderConfig.colorSpace.matrix]),q((t.info.decoderConfig.colorSpace.fullRange?1:0)<<7)]),qo=t=>t.info.decoderConfig&&D("avcC",[...xe(t.info.decoderConfig.description)]),$o=t=>t.info.decoderConfig&&D("hvcC",[...xe(t.info.decoderConfig.description)]),On=t=>{if(!t.info.decoderConfig)return null;const e=t.info.decoderConfig,r=e.codec.split("."),n=Number(r[1]),i=Number(r[2]),a=Number(r[3]),s=r[4]?Number(r[4]):1,o=r[8]?Number(r[8]):Number(e.colorSpace?.fullRange??0),c=(a<<4)+(s<<1)+o,l=r[5]?Number(r[5]):e.colorSpace?.primaries?Vt[e.colorSpace.primaries]:2,u=r[6]?Number(r[6]):e.colorSpace?.transfer?Ut[e.colorSpace.transfer]:2,d=r[7]?Number(r[7]):e.colorSpace?.matrix?Wt[e.colorSpace.matrix]:2;return U("vpcC",1,0,[q(n),q(i),q(c),q(l),q(u),q(d),R(0)])},jo=t=>D("av1C",bs(t.info.decoderConfig.codec)),Ko=(t,e)=>{let r=0,n,i=16;if(ne.includes(e.track.source._codec)){const a=e.track.source._codec,{sampleSize:s}=Ke(a);i=8*s,i>16&&(r=1)}return r===0?n=[Array(6).fill(0),R(1),R(r),R(0),P(0),R(e.info.numberOfChannels),R(i),R(0),R(0),R(e.info.sampleRate<2**16?e.info.sampleRate:0),R(0)]:n=[Array(6).fill(0),R(1),R(r),R(0),P(0),R(e.info.numberOfChannels),R(Math.min(i,16)),R(0),R(0),R(e.info.sampleRate<2**16?e.info.sampleRate:0),R(0),P(1),P(i/8),P(e.info.numberOfChannels*i/8),P(2)],D(t,n,[vc(e.track.source._codec,e.muxer.isQuickTime)?.(e)??null])},xr=t=>{let e;switch(t.track.source._codec){case"aac":e=64;break;case"mp3":e=107;break;case"vorbis":e=221;break;default:throw new Error(`Unhandled audio codec: ${t.track.source._codec}`)}let r=[...q(e),...q(21),...qi(0),...P(0),...P(0)];if(t.info.decoderConfig.description){const n=xe(t.info.decoderConfig.description);r=[...r,...q(5),...Sr(n.byteLength),...n]}return r=[...R(1),...q(0),...q(4),...Sr(r.length),...r,...q(6),...q(1),...q(2)],r=[...q(3),...Sr(r.length),...r],U("esds",0,0,r)},De=t=>D("wave",void 0,[Qo(t),Go(t),D("\0\0\0\0")]),Qo=t=>D("frma",[J(Yi(t.track.source._codec,t.muxer.isQuickTime))]),Go=t=>{const{littleEndian:e}=Ke(t.track.source._codec);return D("enda",[R(+e)])},Xo=t=>{let e=t.info.numberOfChannels,r=3840,n=t.info.sampleRate,i=0,a=0,s=new Uint8Array(0);const o=t.info.decoderConfig?.description;if(o){m(o.byteLength>=18);const c=xe(o),l=Ti(c);e=l.outputChannelCount,r=l.preSkip,n=l.inputSampleRate,i=l.outputGain,a=l.channelMappingFamily,l.channelMappingTable&&(s=l.channelMappingTable)}return D("dOps",[q(0),q(e),R(r),P(n),Hi(i),q(a),...s])},Yo=t=>{const e=t.info.decoderConfig?.description;m(e);const r=xe(e);return U("dfLa",0,0,[...r.subarray(4)])},we=t=>{const{littleEndian:e,sampleSize:r}=Ke(t.track.source._codec),n=+e;return U("pcmC",0,0,[q(n),q(8*r)])},Zo=(t,e)=>D(t,[Array(6).fill(0),R(1)],[Ec[e.track.source._codec](e)]),Jo=t=>D("vttC",[...ye.encode(t.info.config.description)]),ec=t=>U("stts",0,0,[P(t.timeToSampleTable.length),t.timeToSampleTable.map(e=>[P(e.sampleCount),P(e.sampleDelta)])]),tc=t=>{if(t.samples.every(r=>r.type==="key"))return null;const e=[...t.samples.entries()].filter(([,r])=>r.type==="key");return U("stss",0,0,[P(e.length),e.map(([r])=>P(r+1))])},rc=t=>U("stsc",0,0,[P(t.compactlyCodedChunkTable.length),t.compactlyCodedChunkTable.map(e=>[P(e.firstChunk),P(e.samplesPerChunk),P(1)])]),nc=t=>{if(t.type==="audio"&&t.info.requiresPcmTransformation){const{sampleSize:e}=Ke(t.track.source._codec);return U("stsz",0,0,[P(e*t.info.numberOfChannels),P(t.samples.reduce((r,n)=>r+Q(n.duration,t.timescale),0))])}return U("stsz",0,0,[P(0),P(t.samples.length),t.samples.map(e=>P(e.size))])},ic=t=>t.finalizedChunks.length>0&&$(t.finalizedChunks).offset>=2**32?U("co64",0,0,[P(t.finalizedChunks.length),t.finalizedChunks.map(e=>Je(e.offset))]):U("stco",0,0,[P(t.finalizedChunks.length),t.finalizedChunks.map(e=>P(e.offset))]),sc=t=>U("ctts",1,0,[P(t.compositionTimeOffsetTable.length),t.compositionTimeOffsetTable.map(e=>[P(e.sampleCount),Ve(e.sampleCompositionTimeOffset)])]),ac=t=>{let e=1/0,r=-1/0,n=1/0,i=-1/0;m(t.compositionTimeOffsetTable.length>0),m(t.samples.length>0);for(let s=0;s<t.compositionTimeOffsetTable.length;s++){const o=t.compositionTimeOffsetTable[s];e=Math.min(e,o.sampleCompositionTimeOffset),r=Math.max(r,o.sampleCompositionTimeOffset)}for(let s=0;s<t.samples.length;s++){const o=t.samples[s];n=Math.min(n,Q(o.timestamp,t.timescale)),i=Math.max(i,Q(o.timestamp+o.duration,t.timescale))}const a=Math.max(-e,0);return i>=2**31?null:U("cslg",0,0,[Ve(a),Ve(e),Ve(r),Ve(n),Ve(i)])},oc=t=>D("mvex",void 0,t.map(cc)),cc=t=>U("trex",0,0,[P(t.track.id),P(1),P(0),P(0),P(0)]),Nn=(t,e)=>D("moof",void 0,[lc(t),...e.map(uc)]),lc=t=>U("mfhd",0,0,[P(t)]),Gi=t=>{let e=0,r=0;const n=0,i=0,a=t.type==="delta";return r|=+a,a?e|=1:e|=2,e<<24|r<<16|n<<8|i},uc=t=>D("traf",void 0,[dc(t),hc(t),fc(t)]),dc=t=>{m(t.currentChunk);let e=0;e|=8,e|=16,e|=32,e|=131072;const r=t.currentChunk.samples[1]??t.currentChunk.samples[0],n={duration:r.timescaleUnitsToNextSample,size:r.size,flags:Gi(r)};return U("tfhd",0,e,[P(t.track.id),P(n.duration),P(n.size),P(n.flags)])},hc=t=>(m(t.currentChunk),U("tfdt",1,0,[Je(Q(t.currentChunk.startTimestamp,t.timescale))])),fc=t=>{m(t.currentChunk);const e=t.currentChunk.samples.map(g=>g.timescaleUnitsToNextSample),r=t.currentChunk.samples.map(g=>g.size),n=t.currentChunk.samples.map(Gi),i=t.currentChunk.samples.map(g=>Q(g.timestamp-g.decodeTimestamp,t.timescale)),a=new Set(e),s=new Set(r),o=new Set(n),c=new Set(i),l=o.size===2&&n[0]!==n[1],u=a.size>1,d=s.size>1,h=!l&&o.size>1,f=c.size>1||[...c].some(g=>g!==0);let p=0;return p|=1,p|=4*+l,p|=256*+u,p|=512*+d,p|=1024*+h,p|=2048*+f,U("trun",1,p,[P(t.currentChunk.samples.length),P(t.currentChunk.offset-t.currentChunk.moofOffset||0),l?P(n[0]):[],t.currentChunk.samples.map((g,b)=>[u?P(e[b]):[],d?P(r[b]):[],h?P(n[b]):[],f?Ve(i[b]):[]])])},mc=t=>D("mfra",void 0,[...t.map(pc),gc()]),pc=(t,e)=>U("tfra",1,0,[P(t.track.id),P(63),P(t.finalizedChunks.length),t.finalizedChunks.map(n=>[Je(Q(n.samples[0].timestamp,t.timescale)),Je(n.moofOffset),P(e+1),P(1),P(1)])]),gc=()=>U("mfro",0,0,[P(0)]),kc=()=>D("vtte"),bc=(t,e,r,n,i)=>D("vttc",void 0,[i!==null?D("vsid",[Ve(i)]):null,r!==null?D("iden",[...ye.encode(r)]):null,e!==null?D("ctim",[...ye.encode(So(e))]):null,n!==null?D("sttg",[...ye.encode(n)]):null,D("payl",[...ye.encode(t)])]),wc=t=>D("vtta",[...ye.encode(t)]),Tc=t=>{const e=[],r=t.format._options.metadataFormat??"auto",n=t.output._metadataTags;if(r==="mdir"||r==="auto"&&!t.isQuickTime){const i=Sc(n);i&&e.push(i)}else if(r==="mdta"){const i=xc(n);i&&e.push(i)}else(r==="udta"||r==="auto"&&t.isQuickTime)&&yc(e,t.output._metadataTags);return e.length===0?null:D("udta",void 0,e)},yc=(t,e)=>{for(const{key:r,value:n}of ii(e))switch(r){case"title":t.push(Te("nam",n));break;case"description":t.push(Te("des",n));break;case"artist":t.push(Te("ART",n));break;case"album":t.push(Te("alb",n));break;case"albumArtist":t.push(Te("albr",n));break;case"genre":t.push(Te("gen",n));break;case"date":t.push(Te("day",n.toISOString().slice(0,10)));break;case"comment":t.push(Te("cmt",n));break;case"lyrics":t.push(Te("lyr",n));break;case"raw":break;case"discNumber":case"discsTotal":case"trackNumber":case"tracksTotal":case"images":break;default:$e(r)}if(e.raw)for(const r in e.raw){const n=e.raw[r];n==null||r.length!==4||t.some(i=>i.type===r)||(typeof n=="string"?t.push(Te(r,n)):n instanceof Uint8Array&&t.push(D(r,Array.from(n))))}},Te=(t,e)=>{const r=ye.encode(e);return D(t,[R(r.length),R(Zi("und")),Array.from(r)])},Vn={"image/jpeg":13,"image/png":14,"image/bmp":27},Xi=(t,e)=>{const r=[];for(const{key:n,value:i}of ii(t))switch(n){case"title":r.push({key:e?"title":"nam",value:me(i)});break;case"description":r.push({key:e?"description":"des",value:me(i)});break;case"artist":r.push({key:e?"artist":"ART",value:me(i)});break;case"album":r.push({key:e?"album":"alb",value:me(i)});break;case"albumArtist":r.push({key:e?"album_artist":"aART",value:me(i)});break;case"comment":r.push({key:e?"comment":"cmt",value:me(i)});break;case"genre":r.push({key:e?"genre":"gen",value:me(i)});break;case"lyrics":r.push({key:e?"lyrics":"lyr",value:me(i)});break;case"date":r.push({key:e?"date":"day",value:me(i.toISOString().slice(0,10))});break;case"images":for(const a of i)a.kind==="coverFront"&&r.push({key:"covr",value:D("data",[P(Vn[a.mimeType]??0),P(0),Array.from(a.data)])});break;case"trackNumber":if(e){const a=t.tracksTotal!==void 0?`${i}/${t.tracksTotal}`:i.toString();r.push({key:"track",value:me(a)})}else r.push({key:"trkn",value:D("data",[P(0),P(0),R(0),R(i),R(t.tracksTotal??0),R(0)])});break;case"discNumber":e||r.push({key:"disc",value:D("data",[P(0),P(0),R(0),R(i),R(t.discsTotal??0),R(0)])});break;case"tracksTotal":case"discsTotal":break;case"raw":break;default:$e(n)}if(t.raw)for(const n in t.raw){const i=t.raw[n];i==null||!e&&n.length!==4||r.some(a=>a.key===n)||(typeof i=="string"?r.push({key:n,value:me(i)}):i instanceof Uint8Array?r.push({key:n,value:D("data",[P(0),P(0),Array.from(i)])}):i instanceof gt&&r.push({key:n,value:D("data",[P(Vn[i.mimeType]??0),P(0),Array.from(i.data)])}))}return r},Sc=t=>{const e=Xi(t,!1);return e.length===0?null:U("meta",0,0,void 0,[an(!1,"mdir","","appl"),D("ilst",void 0,e.map(r=>D(r.key,void 0,[r.value])))])},xc=t=>{const e=Xi(t,!0);return e.length===0?null:D("meta",void 0,[an(!1,"mdta",""),U("keys",0,0,[P(e.length)],e.map(r=>D("mdta",[...ye.encode(r.key)]))),D("ilst",void 0,e.map((r,n)=>{const i=String.fromCharCode(...P(n+1));return D(i,void 0,[r.value])}))])},me=t=>D("data",[P(1),P(0),...ye.encode(t)]),Cc={avc:"avc1",hevc:"hvc1",vp8:"vp08",vp9:"vp09",av1:"av01"},Pc={avc:qo,hevc:$o,vp8:On,vp9:On,av1:jo},Yi=(t,e)=>{switch(t){case"aac":return"mp4a";case"mp3":return"mp4a";case"opus":return"Opus";case"vorbis":return"mp4a";case"flac":return"fLaC";case"ulaw":return"ulaw";case"alaw":return"alaw";case"pcm-u8":return"raw ";case"pcm-s8":return"sowt"}if(e)switch(t){case"pcm-s16":return"sowt";case"pcm-s16be":return"twos";case"pcm-s24":return"in24";case"pcm-s24be":return"in24";case"pcm-s32":return"in32";case"pcm-s32be":return"in32";case"pcm-f32":return"fl32";case"pcm-f32be":return"fl32";case"pcm-f64":return"fl64";case"pcm-f64be":return"fl64"}else switch(t){case"pcm-s16":return"ipcm";case"pcm-s16be":return"ipcm";case"pcm-s24":return"ipcm";case"pcm-s24be":return"ipcm";case"pcm-s32":return"ipcm";case"pcm-s32be":return"ipcm";case"pcm-f32":return"fpcm";case"pcm-f32be":return"fpcm";case"pcm-f64":return"fpcm";case"pcm-f64be":return"fpcm"}},vc=(t,e)=>{switch(t){case"aac":return xr;case"mp3":return xr;case"opus":return Xo;case"vorbis":return xr;case"flac":return Yo}if(e)switch(t){case"pcm-s24":return De;case"pcm-s24be":return De;case"pcm-s32":return De;case"pcm-s32be":return De;case"pcm-f32":return De;case"pcm-f32be":return De;case"pcm-f64":return De;case"pcm-f64be":return De}else switch(t){case"pcm-s16":return we;case"pcm-s16be":return we;case"pcm-s24":return we;case"pcm-s24be":return we;case"pcm-s32":return we;case"pcm-s32be":return we;case"pcm-f32":return we;case"pcm-f32be":return we;case"pcm-f64":return we;case"pcm-f64be":return we}return null},_c={webvtt:"wvtt"},Ec={webvtt:Jo},Zi=t=>{m(t.length===3);let e=0;for(let r=0;r<3;r++)e<<=5,e+=t.charCodeAt(r)-96;return e};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Ji{constructor(){this.ensureMonotonicity=!1,this.trackedWrites=null,this.trackedStart=-1,this.trackedEnd=-1}start(){}maybeTrackWrites(e){if(!this.trackedWrites)return;let r=this.getPos();if(r<this.trackedStart){if(r+e.byteLength<=this.trackedStart)return;e=e.subarray(this.trackedStart-r),r=0}const n=r+e.byteLength-this.trackedStart;let i=this.trackedWrites.byteLength;for(;i<n;)i*=2;if(i!==this.trackedWrites.byteLength){const a=new Uint8Array(i);a.set(this.trackedWrites,0),this.trackedWrites=a}this.trackedWrites.set(e,r-this.trackedStart),this.trackedEnd=Math.max(this.trackedEnd,r+e.byteLength)}startTrackingWrites(){this.trackedWrites=new Uint8Array(2**10),this.trackedStart=this.getPos(),this.trackedEnd=this.trackedStart}stopTrackingWrites(){if(!this.trackedWrites)throw new Error("Internal error: Can't get tracked writes since nothing was tracked.");const r={data:this.trackedWrites.subarray(0,this.trackedEnd-this.trackedStart),start:this.trackedStart,end:this.trackedEnd};return this.trackedWrites=null,r}}const Cr=2**16,Pr=2**32;class es extends Ji{constructor(e){if(super(),this.pos=0,this.maxPos=0,this.target=e,this.supportsResize="resize"in new ArrayBuffer(0),this.supportsResize)try{this.buffer=new ArrayBuffer(Cr,{maxByteLength:Pr})}catch{this.buffer=new ArrayBuffer(Cr),this.supportsResize=!1}else this.buffer=new ArrayBuffer(Cr);this.bytes=new Uint8Array(this.buffer)}ensureSize(e){let r=this.buffer.byteLength;for(;r<e;)r*=2;if(r!==this.buffer.byteLength){if(r>Pr)throw new Error(`ArrayBuffer exceeded maximum size of ${Pr} bytes. Please consider using another target.`);if(this.supportsResize)this.buffer.resize(r);else{const n=new ArrayBuffer(r),i=new Uint8Array(n);i.set(this.bytes,0),this.buffer=n,this.bytes=i}}}write(e){this.maybeTrackWrites(e),this.ensureSize(this.pos+e.byteLength),this.bytes.set(e,this.pos),this.target.onwrite?.(this.pos,this.pos+e.byteLength),this.pos+=e.byteLength,this.maxPos=Math.max(this.maxPos,this.pos)}seek(e){this.pos=e}getPos(){return this.pos}async flush(){}async finalize(){this.ensureSize(this.pos),this.target.buffer=this.buffer.slice(0,Math.max(this.maxPos,this.pos))}async close(){}getSlice(e,r){return this.bytes.slice(e,r)}}class Ic extends Ji{constructor(e){super(),this.target=e,this.pos=0}write(e){this.maybeTrackWrites(e),this.target.onwrite?.(this.pos,this.pos+e.byteLength),this.pos+=e.byteLength}getPos(){return this.pos}seek(e){this.pos=e}async flush(){}async finalize(){}async close(){}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class on{constructor(){this._output=null,this.onwrite=null}}class ts extends on{constructor(){super(...arguments),this.buffer=null}_createWriter(){return new es(this)}}class Fc extends on{_createWriter(){return new Ic(this)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const $r=1e3,Ac=2082844800,Bc=t=>{const e={},r=t.track;return r.metadata.name!==void 0&&(e.name=r.metadata.name),e},Q=(t,e,r=!0)=>{const n=t*e;return r?Math.round(n):n};class zc extends As{constructor(e,r){super(e),this.auxTarget=new ts,this.auxWriter=this.auxTarget._createWriter(),this.auxBoxWriter=new Mn(this.auxWriter),this.mdat=null,this.ftypSize=null,this.trackDatas=[],this.allTracksKnown=ee(),this.creationTime=Math.floor(Date.now()/1e3)+Ac,this.finalizedChunks=[],this.nextFragmentNumber=1,this.maxWrittenTimestamp=-1/0,this.format=r,this.writer=e._writer,this.boxWriter=new Mn(this.writer),this.isQuickTime=r instanceof is;const n=this.writer instanceof es?"in-memory":!1;this.fastStart=r._options.fastStart??n,this.isFragmented=this.fastStart==="fragmented",(this.fastStart==="in-memory"||this.isFragmented)&&(this.writer.ensureMonotonicity=!0),this.minimumFragmentDuration=r._options.minimumFragmentDuration??1}async start(){const e=await this.mutex.acquire(),r=this.output._tracks.some(n=>n.type==="video"&&n.source._codec==="avc");if(this.format._options.onFtyp&&this.writer.startTrackingWrites(),this.boxWriter.writeBox(xo({isQuickTime:this.isQuickTime,holdsAvc:r,fragmented:this.isFragmented})),this.format._options.onFtyp){const{data:n,start:i}=this.writer.stopTrackingWrites();this.format._options.onFtyp(n,i)}if(this.ftypSize=this.writer.getPos(),this.fastStart!=="in-memory")if(this.fastStart==="reserve"){for(const n of this.output._tracks)if(n.metadata.maximumPacketCount===void 0)throw new Error("All tracks must specify maximumPacketCount in their metadata when using fastStart: 'reserve'.")}else this.isFragmented||(this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat=jt(!0),this.boxWriter.writeBox(this.mdat));await this.writer.flush(),e()}allTracksAreKnown(){for(const e of this.output._tracks)if(!e.source._closed&&!this.trackDatas.some(r=>r.track===e))return!1;return!0}async getMimeType(){await this.allTracksKnown.promise;const e=this.trackDatas.map(r=>r.type==="video"||r.type==="audio"?r.info.decoderConfig.codec:{webvtt:"wvtt"}[r.track.source._codec]);return Pi({isQuickTime:this.isQuickTime,hasVideo:this.trackDatas.some(r=>r.type==="video"),hasAudio:this.trackDatas.some(r=>r.type==="audio"),codecStrings:e})}getVideoTrackData(e,r,n){const i=this.trackDatas.find(l=>l.track===e);if(i)return i;_s(n),m(n),m(n.decoderConfig);const a={...n.decoderConfig};m(a.codedWidth!==void 0),m(a.codedHeight!==void 0);let s=!1;if(e.source._codec==="avc"&&!a.description){const l=mi(r.data);if(!l)throw new Error("Couldn't extract an AVCDecoderConfigurationRecord from the AVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.264) when not providing a description, or provide a description (must be an AVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in AVCC format.");a.description=Rs(l),s=!0}else if(e.source._codec==="hevc"&&!a.description){const l=gi(r.data);if(!l)throw new Error("Couldn't extract an HEVCDecoderConfigurationRecord from the HEVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.265) when not providing a description, or provide a description (must be an HEVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in HEVC format.");a.description=Ws(l),s=!0}const o=ps(1/(e.metadata.frameRate??57600),1e6).denominator,c={muxer:this,track:e,type:"video",info:{width:a.codedWidth,height:a.codedHeight,decoderConfig:a,requiresAnnexBTransformation:s},timescale:o,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(c),this.trackDatas.sort((l,u)=>l.track.id-u.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),c}getAudioTrackData(e,r){const n=this.trackDatas.find(a=>a.track===e);if(n)return n;Is(r),m(r),m(r.decoderConfig);const i={muxer:this,track:e,type:"audio",info:{numberOfChannels:r.decoderConfig.numberOfChannels,sampleRate:r.decoderConfig.sampleRate,decoderConfig:r.decoderConfig,requiresPcmTransformation:!this.isFragmented&&ne.includes(e.source._codec)},timescale:r.decoderConfig.sampleRate,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(i),this.trackDatas.sort((a,s)=>a.track.id-s.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),i}getSubtitleTrackData(e,r){const n=this.trackDatas.find(a=>a.track===e);if(n)return n;Fs(r),m(r),m(r.config);const i={muxer:this,track:e,type:"subtitle",info:{config:r.config},timescale:1e3,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[],lastCueEndTimestamp:0,cueQueue:[],nextSourceId:0,cueToSourceId:new WeakMap};return this.trackDatas.push(i),this.trackDatas.sort((a,s)=>a.track.id-s.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),i}async addEncodedVideoPacket(e,r,n){const i=await this.mutex.acquire();try{const a=this.getVideoTrackData(e,r,n);let s=r.data;if(a.info.requiresAnnexBTransformation){const l=Bs(s);if(!l)throw new Error("Failed to transform packet data. Make sure all packets are provided in Annex B format, as specified in ITU-T-REC-H.264 and ITU-T-REC-H.265.");s=l}const o=this.validateAndNormalizeTimestamp(a.track,r.timestamp,r.type==="key"),c=this.createSampleForTrack(a,s,o,r.duration,r.type);await this.registerSample(a,c)}finally{i()}}async addEncodedAudioPacket(e,r,n){const i=await this.mutex.acquire();try{const a=this.getAudioTrackData(e,n),s=this.validateAndNormalizeTimestamp(a.track,r.timestamp,r.type==="key"),o=this.createSampleForTrack(a,r.data,s,r.duration,r.type);a.info.requiresPcmTransformation&&await this.maybePadWithSilence(a,s),await this.registerSample(a,o)}finally{i()}}async maybePadWithSilence(e,r){const n=$(e.samples),i=n?n.timestamp+n.duration:0,a=r-i,s=Q(a,e.timescale);if(s>0){const{sampleSize:o,silentValue:c}=Ke(e.info.decoderConfig.codec),l=s*e.info.numberOfChannels,u=new Uint8Array(o*l).fill(c),d=this.createSampleForTrack(e,new Uint8Array(u.buffer),i,a,"key");await this.registerSample(e,d)}}async addSubtitleCue(e,r,n){const i=await this.mutex.acquire();try{const a=this.getSubtitleTrackData(e,n);this.validateAndNormalizeTimestamp(a.track,r.timestamp,!0),e.source._codec==="webvtt"&&(a.cueQueue.push(r),await this.processWebVTTCues(a,r.timestamp))}finally{i()}}async processWebVTTCues(e,r){for(;e.cueQueue.length>0;){const n=new Set([]);for(const l of e.cueQueue)m(l.timestamp<=r),m(e.lastCueEndTimestamp<=l.timestamp+l.duration),n.add(Math.max(l.timestamp,e.lastCueEndTimestamp)),n.add(l.timestamp+l.duration);const i=[...n].sort((l,u)=>l-u),a=i[0],s=i[1]??a;if(r<s)break;if(e.lastCueEndTimestamp<a){this.auxWriter.seek(0);const l=kc();this.auxBoxWriter.writeBox(l);const u=this.auxWriter.getSlice(0,this.auxWriter.getPos()),d=this.createSampleForTrack(e,u,e.lastCueEndTimestamp,a-e.lastCueEndTimestamp,"key");await this.registerSample(e,d),e.lastCueEndTimestamp=a}this.auxWriter.seek(0);for(let l=0;l<e.cueQueue.length;l++){const u=e.cueQueue[l];if(u.timestamp>=s)break;Dn.lastIndex=0;const d=Dn.test(u.text),h=u.timestamp+u.duration;let f=e.cueToSourceId.get(u);if(f===void 0&&s<h&&(f=e.nextSourceId++,e.cueToSourceId.set(u,f)),u.notes){const g=wc(u.notes);this.auxBoxWriter.writeBox(g)}const p=bc(u.text,d?a:null,u.identifier??null,u.settings??null,f??null);this.auxBoxWriter.writeBox(p),h===s&&e.cueQueue.splice(l--,1)}const o=this.auxWriter.getSlice(0,this.auxWriter.getPos()),c=this.createSampleForTrack(e,o,a,s-a,"key");await this.registerSample(e,c),e.lastCueEndTimestamp=s}}createSampleForTrack(e,r,n,i,a){return{timestamp:n,decodeTimestamp:n,duration:i,data:r,size:r.byteLength,type:a,timescaleUnitsToNextSample:Q(i,e.timescale)}}processTimestamps(e,r){if(e.timestampProcessingQueue.length===0)return;if(e.type==="audio"&&e.info.requiresPcmTransformation){let i=0;for(let a=0;a<e.timestampProcessingQueue.length;a++){const s=e.timestampProcessingQueue[a],o=Q(s.duration,e.timescale);i+=o}if(e.timeToSampleTable.length===0)e.timeToSampleTable.push({sampleCount:i,sampleDelta:1});else{const a=$(e.timeToSampleTable);a.sampleCount+=i}e.timestampProcessingQueue.length=0;return}const n=e.timestampProcessingQueue.map(i=>i.timestamp).sort((i,a)=>i-a);for(let i=0;i<e.timestampProcessingQueue.length;i++){const a=e.timestampProcessingQueue[i];a.decodeTimestamp=n[i],!this.isFragmented&&e.lastTimescaleUnits===null&&(a.decodeTimestamp=0);const s=Q(a.timestamp-a.decodeTimestamp,e.timescale),o=Q(a.duration,e.timescale);if(e.lastTimescaleUnits!==null){m(e.lastSample);const c=Q(a.decodeTimestamp,e.timescale,!1),l=Math.round(c-e.lastTimescaleUnits);if(m(l>=0),e.lastTimescaleUnits+=l,e.lastSample.timescaleUnitsToNextSample=l,!this.isFragmented){let u=$(e.timeToSampleTable);if(m(u),u.sampleCount===1){u.sampleDelta=l;const h=e.timeToSampleTable[e.timeToSampleTable.length-2];h&&h.sampleDelta===l&&(h.sampleCount++,e.timeToSampleTable.pop(),u=h)}else u.sampleDelta!==l&&(u.sampleCount--,e.timeToSampleTable.push(u={sampleCount:1,sampleDelta:l}));u.sampleDelta===o?u.sampleCount++:e.timeToSampleTable.push({sampleCount:1,sampleDelta:o});const d=$(e.compositionTimeOffsetTable);m(d),d.sampleCompositionTimeOffset===s?d.sampleCount++:e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:s})}}else e.lastTimescaleUnits=Q(a.decodeTimestamp,e.timescale,!1),this.isFragmented||(e.timeToSampleTable.push({sampleCount:1,sampleDelta:o}),e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:s}));e.lastSample=a}if(e.timestampProcessingQueue.length=0,m(e.lastSample),m(e.lastTimescaleUnits!==null),r!==void 0&&e.lastSample.timescaleUnitsToNextSample===0){m(r.type==="key");const i=Q(r.timestamp,e.timescale,!1),a=Math.round(i-e.lastTimescaleUnits);e.lastSample.timescaleUnitsToNextSample=a}}async registerSample(e,r){r.type==="key"&&this.processTimestamps(e,r),e.timestampProcessingQueue.push(r),this.isFragmented?(e.sampleQueue.push(r),await this.interleaveSamples()):this.fastStart==="reserve"?await this.registerSampleFastStartReserve(e,r):await this.addSampleToTrack(e,r)}async addSampleToTrack(e,r){if(!this.isFragmented&&(e.samples.push(r),this.fastStart==="reserve")){const i=e.track.metadata.maximumPacketCount;if(m(i!==void 0),e.samples.length>i)throw new Error(`Track #${e.track.id} has already reached the maximum packet count (${i}). Either add less packets or increase the maximum packet count.`)}let n=!1;if(!e.currentChunk)n=!0;else{e.currentChunk.startTimestamp=Math.min(e.currentChunk.startTimestamp,r.timestamp);const i=r.timestamp-e.currentChunk.startTimestamp;if(this.isFragmented){const a=this.trackDatas.every(s=>{if(e===s)return r.type==="key";const o=s.sampleQueue[0];return o?o.type==="key":s.track.source._closed});i>=this.minimumFragmentDuration&&a&&r.timestamp>this.maxWrittenTimestamp&&(n=!0,await this.finalizeFragment())}else n=i>=.5}n&&(e.currentChunk&&await this.finalizeCurrentChunk(e),e.currentChunk={startTimestamp:r.timestamp,samples:[],offset:null,moofOffset:null}),m(e.currentChunk),e.currentChunk.samples.push(r),this.isFragmented&&(this.maxWrittenTimestamp=Math.max(this.maxWrittenTimestamp,r.timestamp))}async finalizeCurrentChunk(e){if(m(!this.isFragmented),!e.currentChunk)return;e.finalizedChunks.push(e.currentChunk),this.finalizedChunks.push(e.currentChunk);let r=e.currentChunk.samples.length;if(e.type==="audio"&&e.info.requiresPcmTransformation&&(r=e.currentChunk.samples.reduce((n,i)=>n+Q(i.duration,e.timescale),0)),(e.compactlyCodedChunkTable.length===0||$(e.compactlyCodedChunkTable).samplesPerChunk!==r)&&e.compactlyCodedChunkTable.push({firstChunk:e.finalizedChunks.length,samplesPerChunk:r}),this.fastStart==="in-memory"){e.currentChunk.offset=0;return}e.currentChunk.offset=this.writer.getPos();for(const n of e.currentChunk.samples)m(n.data),this.writer.write(n.data),n.data=null;await this.writer.flush()}async interleaveSamples(e=!1){if(m(this.isFragmented),!(!e&&!this.allTracksAreKnown()))e:for(;;){let r=null,n=1/0;for(const a of this.trackDatas){if(!e&&a.sampleQueue.length===0&&!a.track.source._closed)break e;a.sampleQueue.length>0&&a.sampleQueue[0].timestamp<n&&(r=a,n=a.sampleQueue[0].timestamp)}if(!r)break;const i=r.sampleQueue.shift();await this.addSampleToTrack(r,i)}}async finalizeFragment(e=!0){m(this.isFragmented);const r=this.nextFragmentNumber++;if(r===1){this.format._options.onMoov&&this.writer.startTrackingWrites();const f=_t(this);if(this.boxWriter.writeBox(f),this.format._options.onMoov){const{data:p,start:g}=this.writer.stopTrackingWrites();this.format._options.onMoov(p,g)}}const n=this.trackDatas.filter(f=>f.currentChunk),i=Nn(r,n),a=this.writer.getPos(),s=a+this.boxWriter.measureBox(i);let o=s+ge,c=1/0;for(const f of n){f.currentChunk.offset=o,f.currentChunk.moofOffset=a;for(const p of f.currentChunk.samples)o+=p.size;c=Math.min(c,f.currentChunk.startTimestamp)}const l=o-s,u=l>=2**32;if(u)for(const f of n)f.currentChunk.offset+=Ne-ge;this.format._options.onMoof&&this.writer.startTrackingWrites();const d=Nn(r,n);if(this.boxWriter.writeBox(d),this.format._options.onMoof){const{data:f,start:p}=this.writer.stopTrackingWrites();this.format._options.onMoof(f,p,c)}m(this.writer.getPos()===s),this.format._options.onMdat&&this.writer.startTrackingWrites();const h=jt(u);h.size=l,this.boxWriter.writeBox(h),this.writer.seek(s+(u?Ne:ge));for(const f of n)for(const p of f.currentChunk.samples)this.writer.write(p.data),p.data=null;if(this.format._options.onMdat){const{data:f,start:p}=this.writer.stopTrackingWrites();this.format._options.onMdat(f,p)}for(const f of n)f.finalizedChunks.push(f.currentChunk),this.finalizedChunks.push(f.currentChunk),f.currentChunk=null;e&&await this.writer.flush()}async registerSampleFastStartReserve(e,r){if(this.allTracksAreKnown()){if(!this.mdat){const n=_t(this),a=this.boxWriter.measureBox(n)+this.computeSampleTableSizeUpperBound()+4096;m(this.ftypSize!==null),this.writer.seek(this.ftypSize+a),this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat=jt(!0),this.boxWriter.writeBox(this.mdat);for(const s of this.trackDatas){for(const o of s.sampleQueue)await this.addSampleToTrack(s,o);s.sampleQueue.length=0}}await this.addSampleToTrack(e,r)}else e.sampleQueue.push(r)}computeSampleTableSizeUpperBound(){m(this.fastStart==="reserve");let e=0;for(const r of this.trackDatas){const n=r.track.metadata.maximumPacketCount;m(n!==void 0),e+=8*Math.ceil(2/3*n),e+=4*n,e+=8*Math.ceil(2/3*n),e+=12*Math.ceil(2/3*n),e+=4*n,e+=8*n}return e}async onTrackClose(e){const r=await this.mutex.acquire();if(e.type==="subtitle"&&e.source._codec==="webvtt"){const n=this.trackDatas.find(i=>i.track===e);n&&await this.processWebVTTCues(n,1/0)}this.allTracksAreKnown()&&this.allTracksKnown.resolve(),this.isFragmented&&await this.interleaveSamples(),r()}async finalize(){const e=await this.mutex.acquire();this.allTracksKnown.resolve();for(const r of this.trackDatas)r.type==="subtitle"&&r.track.source._codec==="webvtt"&&await this.processWebVTTCues(r,1/0);if(this.isFragmented){await this.interleaveSamples(!0);for(const r of this.trackDatas)this.processTimestamps(r);await this.finalizeFragment(!1)}else for(const r of this.trackDatas)this.processTimestamps(r),await this.finalizeCurrentChunk(r);if(this.fastStart==="in-memory"){this.mdat=jt(!1);let r;for(let i=0;i<2;i++){const a=_t(this),s=this.boxWriter.measureBox(a);r=this.boxWriter.measureBox(this.mdat);let o=this.writer.getPos()+s+r;for(const c of this.finalizedChunks){c.offset=o;for(const{data:l}of c.samples)m(l),o+=l.byteLength,r+=l.byteLength}if(o<2**32)break;r>=2**32&&(this.mdat.largeSize=!0)}this.format._options.onMoov&&this.writer.startTrackingWrites();const n=_t(this);if(this.boxWriter.writeBox(n),this.format._options.onMoov){const{data:i,start:a}=this.writer.stopTrackingWrites();this.format._options.onMoov(i,a)}this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat.size=r,this.boxWriter.writeBox(this.mdat);for(const i of this.finalizedChunks)for(const a of i.samples)m(a.data),this.writer.write(a.data),a.data=null;if(this.format._options.onMdat){const{data:i,start:a}=this.writer.stopTrackingWrites();this.format._options.onMdat(i,a)}}else if(this.isFragmented){const r=this.writer.getPos(),n=mc(this.trackDatas);this.boxWriter.writeBox(n);const i=this.writer.getPos()-r;this.writer.seek(this.writer.getPos()-4),this.boxWriter.writeU32(i)}else{m(this.mdat);const r=this.boxWriter.offsets.get(this.mdat);m(r!==void 0);const n=this.writer.getPos()-r;if(this.mdat.size=n,this.mdat.largeSize=n>=2**32,this.boxWriter.patchBox(this.mdat),this.format._options.onMdat){const{data:a,start:s}=this.writer.stopTrackingWrites();this.format._options.onMdat(a,s)}const i=_t(this);if(this.fastStart==="reserve"){m(this.ftypSize!==null),this.writer.seek(this.ftypSize),this.format._options.onMoov&&this.writer.startTrackingWrites(),this.boxWriter.writeBox(i);const a=this.boxWriter.offsets.get(this.mdat)-this.writer.getPos();this.boxWriter.writeBox(Co(a))}else this.format._options.onMoov&&this.writer.startTrackingWrites(),this.boxWriter.writeBox(i);if(this.format._options.onMoov){const{data:a,start:s}=this.writer.stopTrackingWrites();this.format._options.onMoov(a,s)}}e()}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class rs{getSupportedVideoCodecs(){return this.getSupportedCodecs().filter(e=>Ce.includes(e))}getSupportedAudioCodecs(){return this.getSupportedCodecs().filter(e=>Pe.includes(e))}getSupportedSubtitleCodecs(){return this.getSupportedCodecs().filter(e=>er.includes(e))}_codecUnsupportedHint(e){return""}}class ns extends rs{constructor(e={}){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(e.fastStart!==void 0&&![!1,"in-memory","reserve","fragmented"].includes(e.fastStart))throw new TypeError("options.fastStart, when provided, must be false, 'in-memory', 'reserve', or 'fragmented'.");if(e.minimumFragmentDuration!==void 0&&(!Number.isFinite(e.minimumFragmentDuration)||e.minimumFragmentDuration<0))throw new TypeError("options.minimumFragmentDuration, when provided, must be a non-negative number.");if(e.onFtyp!==void 0&&typeof e.onFtyp!="function")throw new TypeError("options.onFtyp, when provided, must be a function.");if(e.onMoov!==void 0&&typeof e.onMoov!="function")throw new TypeError("options.onMoov, when provided, must be a function.");if(e.onMdat!==void 0&&typeof e.onMdat!="function")throw new TypeError("options.onMdat, when provided, must be a function.");if(e.onMoof!==void 0&&typeof e.onMoof!="function")throw new TypeError("options.onMoof, when provided, must be a function.");if(e.metadataFormat!==void 0&&!["mdir","mdta","udta","auto"].includes(e.metadataFormat))throw new TypeError("options.metadataFormat, when provided, must be either 'auto', 'mdir', 'mdta', or 'udta'.");super(),this._options=e}getSupportedTrackCounts(){return{video:{min:0,max:1/0},audio:{min:0,max:1/0},subtitle:{min:0,max:1/0},total:{min:1,max:2**32-1}}}get supportsVideoRotationMetadata(){return!0}_createMuxer(e){return new zc(e,this)}}class cn extends ns{constructor(e){super(e)}get _name(){return"MP4"}get fileExtension(){return".mp4"}get mimeType(){return"video/mp4"}getSupportedCodecs(){return[...Ce,...At,"pcm-s16","pcm-s16be","pcm-s24","pcm-s24be","pcm-s32","pcm-s32be","pcm-f32","pcm-f32be","pcm-f64","pcm-f64be",...er]}_codecUnsupportedHint(e){return new is().getSupportedCodecs().includes(e)?" Switching to MOV will grant support for this codec.":""}}class is extends ns{constructor(e){super(e)}get _name(){return"MOV"}get fileExtension(){return".mov"}get mimeType(){return"video/quicktime"}getSupportedCodecs(){return[...Ce,...Pe]}_codecUnsupportedHint(e){return new cn().getSupportedCodecs().includes(e)?" Switching to MP4 will grant support for this codec.":""}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Rc=t=>{if(!t||typeof t!="object")throw new TypeError("Encoding config must be an object.");if(!Ce.includes(t.codec))throw new TypeError(`Invalid video codec '${t.codec}'. Must be one of: ${Ce.join(", ")}.`);if(!(t.bitrate instanceof Re)&&(!Number.isInteger(t.bitrate)||t.bitrate<=0))throw new TypeError("config.bitrate must be a positive integer or a quality.");if(t.keyFrameInterval!==void 0&&(!Number.isFinite(t.keyFrameInterval)||t.keyFrameInterval<0))throw new TypeError("config.keyFrameInterval, when provided, must be a non-negative number.");if(t.sizeChangeBehavior!==void 0&&!["deny","passThrough","fill","contain","cover"].includes(t.sizeChangeBehavior))throw new TypeError("config.sizeChangeBehavior, when provided, must be 'deny', 'passThrough', 'fill', 'contain' or 'cover'.");if(t.onEncodedPacket!==void 0&&typeof t.onEncodedPacket!="function")throw new TypeError("config.onEncodedChunk, when provided, must be a function.");if(t.onEncoderConfig!==void 0&&typeof t.onEncoderConfig!="function")throw new TypeError("config.onEncoderConfig, when provided, must be a function.");ss(t.codec,t)},ss=(t,e)=>{if(!e||typeof e!="object")throw new TypeError("Encoding options must be an object.");if(e.alpha!==void 0&&!["discard","keep"].includes(e.alpha))throw new TypeError("options.alpha, when provided, must be 'discard' or 'keep'.");if(e.bitrateMode!==void 0&&!["constant","variable"].includes(e.bitrateMode))throw new TypeError("bitrateMode, when provided, must be 'constant' or 'variable'.");if(e.latencyMode!==void 0&&!["quality","realtime"].includes(e.latencyMode))throw new TypeError("latencyMode, when provided, must be 'quality' or 'realtime'.");if(e.fullCodecString!==void 0&&typeof e.fullCodecString!="string")throw new TypeError("fullCodecString, when provided, must be a string.");if(e.fullCodecString!==void 0&&hi(e.fullCodecString)!==t)throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${t}).`);if(e.hardwareAcceleration!==void 0&&!["no-preference","prefer-hardware","prefer-software"].includes(e.hardwareAcceleration))throw new TypeError("hardwareAcceleration, when provided, must be 'no-preference', 'prefer-hardware' or 'prefer-software'.");if(e.scalabilityMode!==void 0&&typeof e.scalabilityMode!="string")throw new TypeError("scalabilityMode, when provided, must be a string.");if(e.contentHint!==void 0&&typeof e.contentHint!="string")throw new TypeError("contentHint, when provided, must be a string.")},jr=t=>{const e=t.bitrate instanceof Re?t.bitrate._toVideoBitrate(t.codec,t.width,t.height):t.bitrate;return{codec:t.fullCodecString??ks(t.codec,t.width,t.height,e),width:t.width,height:t.height,bitrate:e,bitrateMode:t.bitrateMode,alpha:t.alpha??"discard",framerate:t.framerate,latencyMode:t.latencyMode,hardwareAcceleration:t.hardwareAcceleration,scalabilityMode:t.scalabilityMode,contentHint:t.contentHint,...Ts(t.codec)}},Dc=t=>{if(!t||typeof t!="object")throw new TypeError("Encoding config must be an object.");if(!Pe.includes(t.codec))throw new TypeError(`Invalid audio codec '${t.codec}'. Must be one of: ${Pe.join(", ")}.`);if(t.bitrate===void 0&&(!ne.includes(t.codec)||t.codec==="flac"))throw new TypeError("config.bitrate must be provided for compressed audio codecs.");if(t.bitrate!==void 0&&!(t.bitrate instanceof Re)&&(!Number.isInteger(t.bitrate)||t.bitrate<=0))throw new TypeError("config.bitrate, when provided, must be a positive integer or a quality.");if(t.onEncodedPacket!==void 0&&typeof t.onEncodedPacket!="function")throw new TypeError("config.onEncodedChunk, when provided, must be a function.");if(t.onEncoderConfig!==void 0&&typeof t.onEncoderConfig!="function")throw new TypeError("config.onEncoderConfig, when provided, must be a function.");as(t.codec,t)},as=(t,e)=>{if(!e||typeof e!="object")throw new TypeError("Encoding options must be an object.");if(e.bitrateMode!==void 0&&!["constant","variable"].includes(e.bitrateMode))throw new TypeError("bitrateMode, when provided, must be 'constant' or 'variable'.");if(e.fullCodecString!==void 0&&typeof e.fullCodecString!="string")throw new TypeError("fullCodecString, when provided, must be a string.");if(e.fullCodecString!==void 0&&hi(e.fullCodecString)!==t)throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${t}).`)},Kr=t=>{const e=t.bitrate instanceof Re?t.bitrate._toAudioBitrate(t.codec):t.bitrate;return{codec:t.fullCodecString??ws(t.codec,t.numberOfChannels,t.sampleRate),numberOfChannels:t.numberOfChannels,sampleRate:t.sampleRate,bitrate:e,bitrateMode:t.bitrateMode,...ys(t.codec)}};class Re{constructor(e){this._factor=e}_toVideoBitrate(e,r,n){const i=r*n,a={avc:1,hevc:.6,vp9:.6,av1:.4,vp8:1.2},s=1920*1080,o=3e6,c=Math.pow(i/s,.95),d=o*c*a[e]*this._factor;return Math.ceil(d/1e3)*1e3}_toAudioBitrate(e){if(ne.includes(e)||e==="flac")return;const n={aac:128e3,opus:64e3,mp3:16e4,vorbis:64e3}[e];if(!n)throw new Error(`Unhandled codec: ${e}`);let i=n*this._factor;return e==="aac"?i=[96e3,128e3,16e4,192e3].reduce((s,o)=>Math.abs(o-i)<Math.abs(s-i)?o:s):e==="opus"||e==="vorbis"?i=Math.max(6e3,i):e==="mp3"&&(i=[8e3,16e3,24e3,32e3,4e4,48e3,64e3,8e4,96e3,112e3,128e3,16e4,192e3,224e3,256e3,32e4].reduce((s,o)=>Math.abs(o-i)<Math.abs(s-i)?o:s)),Math.round(i/1e3)*1e3}}const Un=new Re(2),Mc=async(t,e={})=>{const{width:r=1280,height:n=720,bitrate:i=1e6,...a}=e;if(!Ce.includes(t))return!1;if(!Number.isInteger(r)||r<=0)throw new TypeError("width must be a positive integer.");if(!Number.isInteger(n)||n<=0)throw new TypeError("height must be a positive integer.");if(!(i instanceof Re)&&(!Number.isInteger(i)||i<=0))throw new TypeError("bitrate must be a positive integer or a quality.");ss(t,a);let s=null;return Rr.length>0&&(s??=jr({codec:t,width:r,height:n,bitrate:i,framerate:void 0,...a}),Rr.some(l=>l.supports(t,s)))?!0:typeof VideoEncoder>"u"||(r%2===1||n%2===1)&&(t==="avc"||t==="hevc")?!1:(s??=jr({codec:t,width:r,height:n,bitrate:i,framerate:void 0,...a,alpha:"discard"}),(await VideoEncoder.isConfigSupported(s)).supported===!0)},Oc=async(t,e={})=>{const{numberOfChannels:r=2,sampleRate:n=48e3,bitrate:i=128e3,...a}=e;if(!Pe.includes(t))return!1;if(!Number.isInteger(r)||r<=0)throw new TypeError("numberOfChannels must be a positive integer.");if(!Number.isInteger(n)||n<=0)throw new TypeError("sampleRate must be a positive integer.");if(!(i instanceof Re)&&(!Number.isInteger(i)||i<=0))throw new TypeError("bitrate must be a positive integer.");as(t,a);let s=null;return Dr.length>0&&(s??=Kr({codec:t,numberOfChannels:r,sampleRate:n,bitrate:i,...a}),Dr.some(c=>c.supports(t,s)))||ne.includes(t)?!0:typeof AudioEncoder>"u"?!1:(s??=Kr({codec:t,numberOfChannels:r,sampleRate:n,bitrate:i,...a}),(await AudioEncoder.isConfigSupported(s)).supported===!0)},Wn=async(t=Pe,e)=>{const r=await Promise.all(t.map(n=>Oc(n,e)));return t.filter((n,i)=>r[i])},Nc=async(t,e)=>{for(const r of t)if(await Mc(r,e))return r;return null};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class ln{constructor(){this._connectedTrack=null,this._closingPromise=null,this._closed=!1,this._timestampOffset=0}_ensureValidAdd(){if(!this._connectedTrack)throw new Error("Source is not connected to an output track.");if(this._connectedTrack.output.state==="canceled")throw new Error("Output has been canceled.");if(this._connectedTrack.output.state==="finalizing"||this._connectedTrack.output.state==="finalized")throw new Error("Output has been finalized.");if(this._connectedTrack.output.state==="pending")throw new Error("Output has not started.");if(this._closed)throw new Error("Source is closed.")}async _start(){}async _flushAndClose(e){}close(){if(this._closingPromise)return;const e=this._connectedTrack;if(!e)throw new Error("Cannot call close without connecting the source to an output track.");if(e.output.state==="pending")throw new Error("Cannot call close before output has been started.");this._closingPromise=(async()=>{await this._flushAndClose(!1),this._closed=!0,!(e.output.state==="finalizing"||e.output.state==="finalized")&&e.output._muxer.onTrackClose(e)})()}async _flushOrWaitForOngoingClose(e){return this._closingPromise?this._closingPromise:this._flushAndClose(e)}}class un extends ln{constructor(e){if(super(),this._connectedTrack=null,!Ce.includes(e))throw new TypeError(`Invalid video codec '${e}'. Must be one of: ${Ce.join(", ")}.`);this._codec=e}}class Vc extends un{constructor(e){super(e)}add(e,r){if(!(e instanceof H))throw new TypeError("packet must be an EncodedPacket.");if(e.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be added.");if(r!==void 0&&(!r||typeof r!="object"))throw new TypeError("meta, when provided, must be an object.");return this._ensureValidAdd(),this._connectedTrack.output._muxer.addEncodedVideoPacket(this._connectedTrack,e,r)}}class Uc{constructor(e,r){this.source=e,this.encodingConfig=r,this.ensureEncoderPromise=null,this.encoderInitialized=!1,this.encoder=null,this.muxer=null,this.lastMultipleOfKeyFrameInterval=-1,this.codedWidth=null,this.codedHeight=null,this.resizeCanvas=null,this.customEncoder=null,this.customEncoderCallSerializer=new ur,this.customEncoderQueueSize=0,this.alphaEncoder=null,this.splitter=null,this.splitterCreationFailed=!1,this.alphaFrameQueue=[],this.error=null,this.errorNeedsNewStack=!0}async add(e,r,n){try{if(this.checkForEncoderError(),this.source._ensureValidAdd(),this.codedWidth!==null&&this.codedHeight!==null){if(e.codedWidth!==this.codedWidth||e.codedHeight!==this.codedHeight){const o=this.encodingConfig.sizeChangeBehavior??"deny";if(o!=="passThrough"){if(o==="deny")throw new Error(`Video sample size must remain constant. Expected ${this.codedWidth}x${this.codedHeight}, got ${e.codedWidth}x${e.codedHeight}. To allow the sample size to change over time, set \`sizeChangeBehavior\` to a value other than 'strict' in the encoding options.`);{let c=!1;this.resizeCanvas||(typeof document<"u"?(this.resizeCanvas=document.createElement("canvas"),this.resizeCanvas.width=this.codedWidth,this.resizeCanvas.height=this.codedHeight):this.resizeCanvas=new OffscreenCanvas(this.codedWidth,this.codedHeight),c=!0);const l=this.resizeCanvas.getContext("2d",{alpha:Mt()});m(l),c||(Mt()?(l.fillStyle="black",l.fillRect(0,0,this.codedWidth,this.codedHeight)):l.clearRect(0,0,this.codedWidth,this.codedHeight)),e.drawWithFit(l,{fit:o}),r&&e.close(),e=new de(this.resizeCanvas,{timestamp:e.timestamp,duration:e.duration,rotation:e.rotation}),r=!0}}}}else this.codedWidth=e.codedWidth,this.codedHeight=e.codedHeight;this.encoderInitialized||(this.ensureEncoderPromise||this.ensureEncoder(e),this.encoderInitialized||await this.ensureEncoderPromise),m(this.encoderInitialized);const i=this.encodingConfig.keyFrameInterval??5,a=Math.floor(e.timestamp/i),s={...n,keyFrame:n?.keyFrame||i===0||a!==this.lastMultipleOfKeyFrameInterval};if(this.lastMultipleOfKeyFrameInterval=a,this.customEncoder){this.customEncoderQueueSize++;const o=e.clone(),c=this.customEncoderCallSerializer.call(()=>this.customEncoder.encode(o,s)).then(()=>this.customEncoderQueueSize--).catch(l=>this.error??=l).finally(()=>{o.close()});this.customEncoderQueueSize>=4&&await c}else{m(this.encoder);const o=e.toVideoFrame();if(!this.alphaEncoder)this.encoder.encode(o,s),o.close();else if(!!o.format&&!o.format.includes("A")||this.splitterCreationFailed)this.alphaFrameQueue.push(null),this.encoder.encode(o,s),o.close();else{const l=o.displayWidth,u=o.displayHeight;if(!this.splitter)try{this.splitter=new Wc(l,u)}catch(d){console.error("Due to an error, only color data will be encoded.",d),this.splitterCreationFailed=!0,this.alphaFrameQueue.push(null),this.encoder.encode(o,s),o.close()}if(this.splitter){const d=this.splitter.extractColor(o),h=this.splitter.extractAlpha(o);this.alphaFrameQueue.push(h),this.encoder.encode(d,s),d.close(),o.close()}}r&&e.close(),this.encoder.encodeQueueSize>=4&&await new Promise(c=>this.encoder.addEventListener("dequeue",c,{once:!0}))}await this.muxer.mutex.currentPromise}finally{r&&e.close()}}ensureEncoder(e){const r=new Error;this.ensureEncoderPromise=(async()=>{const n=jr({width:e.codedWidth,height:e.codedHeight,...this.encodingConfig,framerate:this.source._connectedTrack?.metadata.frameRate});this.encodingConfig.onEncoderConfig?.(n);const i=Rr.find(a=>a.supports(this.encodingConfig.codec,n));if(i)this.customEncoder=new i,this.customEncoder.codec=this.encodingConfig.codec,this.customEncoder.config=n,this.customEncoder.onPacket=(a,s)=>{if(!(a instanceof H))throw new TypeError("The first argument passed to onPacket must be an EncodedPacket.");if(s!==void 0&&(!s||typeof s!="object"))throw new TypeError("The second argument passed to onPacket must be an object or undefined.");this.encodingConfig.onEncodedPacket?.(a,s),this.muxer.addEncodedVideoPacket(this.source._connectedTrack,a,s).catch(o=>{this.error??=o,this.errorNeedsNewStack=!1})},await this.customEncoder.init();else{if(typeof VideoEncoder>"u")throw new Error("VideoEncoder is not supported by this browser.");if(n.alpha="discard",this.encodingConfig.alpha==="keep"&&(n.latencyMode="quality"),(n.width%2===1||n.height%2===1)&&(this.encodingConfig.codec==="avc"||this.encodingConfig.codec==="hevc"))throw new Error(`The dimensions ${n.width}x${n.height} are not supported for codec '${this.encodingConfig.codec}'; both width and height must be even numbers. Make sure to round your dimensions to the nearest even number.`);if(!(await VideoEncoder.isConfigSupported(n)).supported)throw new Error(`This specific encoder configuration (${n.codec}, ${n.bitrate} bps, ${n.width}x${n.height}, hardware acceleration: ${n.hardwareAcceleration??"no-preference"}) is not supported by this browser. Consider using another codec or changing your video parameters.`);const o=[],c=[];let l=0,u=0;const d=(h,f,p)=>{const g={};if(f){const w=new Uint8Array(f.byteLength);f.copyTo(w),g.alpha=w}const b=H.fromEncodedChunk(h,g);this.encodingConfig.onEncodedPacket?.(b,p),this.muxer.addEncodedVideoPacket(this.source._connectedTrack,b,p).catch(w=>{this.error??=w,this.errorNeedsNewStack=!1})};this.encoder=new VideoEncoder({output:(h,f)=>{if(!this.alphaEncoder){d(h,null,f);return}const p=this.alphaFrameQueue.shift();m(p!==void 0),p?(this.alphaEncoder.encode(p,{keyFrame:h.type==="key"}),u++,p.close(),o.push({chunk:h,meta:f})):u===0?d(h,null,f):(c.push(l+u),o.push({chunk:h,meta:f}))},error:h=>{h.stack=r.stack,this.error??=h}}),this.encoder.configure(n),this.encodingConfig.alpha==="keep"&&(this.alphaEncoder=new VideoEncoder({output:(h,f)=>{u--;const p=o.shift();for(m(p!==void 0),d(p.chunk,h,p.meta),l++;c.length>0&&c[0]===l;){c.shift();const g=o.shift();m(g!==void 0),d(g.chunk,null,g.meta)}},error:h=>{h.stack=r.stack,this.error??=h}}),this.alphaEncoder.configure(n))}m(this.source._connectedTrack),this.muxer=this.source._connectedTrack.output._muxer,this.encoderInitialized=!0})()}async flushAndClose(e){e||this.checkForEncoderError(),this.customEncoder?(e||this.customEncoderCallSerializer.call(()=>this.customEncoder.flush()),await this.customEncoderCallSerializer.call(()=>this.customEncoder.close())):this.encoder&&(e||(await this.encoder.flush(),await this.alphaEncoder?.flush()),this.encoder.state!=="closed"&&this.encoder.close(),this.alphaEncoder&&this.alphaEncoder.state!=="closed"&&this.alphaEncoder.close(),this.alphaFrameQueue.forEach(r=>r?.close()),this.splitter?.close()),e||this.checkForEncoderError()}getQueueSize(){return this.customEncoder?this.customEncoderQueueSize:this.encoder?.encodeQueueSize??0}checkForEncoderError(){if(this.error)throw this.errorNeedsNewStack&&(this.error.stack=new Error().stack),this.error}}class Wc{constructor(e,r){this.lastFrame=null,typeof OffscreenCanvas<"u"?this.canvas=new OffscreenCanvas(e,r):(this.canvas=document.createElement("canvas"),this.canvas.width=e,this.canvas.height=r);const n=this.canvas.getContext("webgl2",{alpha:!0});if(!n)throw new Error("Couldn't acquire WebGL 2 context.");this.gl=n,this.colorProgram=this.createColorProgram(),this.alphaProgram=this.createAlphaProgram(),this.vao=this.createVAO(),this.sourceTexture=this.createTexture(),this.alphaResolutionLocation=this.gl.getUniformLocation(this.alphaProgram,"u_resolution"),this.gl.useProgram(this.colorProgram),this.gl.uniform1i(this.gl.getUniformLocation(this.colorProgram,"u_sourceTexture"),0),this.gl.useProgram(this.alphaProgram),this.gl.uniform1i(this.gl.getUniformLocation(this.alphaProgram,"u_sourceTexture"),0)}createVertexShader(){return this.createShader(this.gl.VERTEX_SHADER,`#version 300 es
			in vec2 a_position;
			in vec2 a_texCoord;
			out vec2 v_texCoord;
			
			void main() {
				gl_Position = vec4(a_position, 0.0, 1.0);
				v_texCoord = a_texCoord;
			}
		`)}createColorProgram(){const e=this.createVertexShader(),r=this.createShader(this.gl.FRAGMENT_SHADER,`#version 300 es
			precision highp float;
			
			uniform sampler2D u_sourceTexture;
			in vec2 v_texCoord;
			out vec4 fragColor;
			
			void main() {
				vec4 source = texture(u_sourceTexture, v_texCoord);
				fragColor = vec4(source.rgb, 1.0);
			}
		`),n=this.gl.createProgram();return this.gl.attachShader(n,e),this.gl.attachShader(n,r),this.gl.linkProgram(n),n}createAlphaProgram(){const e=this.createVertexShader(),r=this.createShader(this.gl.FRAGMENT_SHADER,`#version 300 es
			precision highp float;
			
			uniform sampler2D u_sourceTexture;
			uniform vec2 u_resolution; // The width and height of the canvas
			in vec2 v_texCoord;
			out vec4 fragColor;

			// This function determines the value for a single byte in the YUV stream
			float getByteValue(float byteOffset) {
				float width = u_resolution.x;
				float height = u_resolution.y;

				float yPlaneSize = width * height;

				if (byteOffset < yPlaneSize) {
					// This byte is in the luma plane. Find the corresponding pixel coordinates to sample from
					float y = floor(byteOffset / width);
					float x = mod(byteOffset, width);
					
					// Add 0.5 to sample the center of the texel
					vec2 sampleCoord = (vec2(x, y) + 0.5) / u_resolution;
					
					// The luma value is the alpha from the source texture
					return texture(u_sourceTexture, sampleCoord).a;
				} else {
					// Write a fixed value for chroma and beyond
					return 128.0 / 255.0;
				}
			}
			
			void main() {
				// Each fragment writes 4 bytes (R, G, B, A)
				float pixelIndex = floor(gl_FragCoord.y) * u_resolution.x + floor(gl_FragCoord.x);
				float baseByteOffset = pixelIndex * 4.0;

				vec4 result;
				for (int i = 0; i < 4; i++) {
					float currentByteOffset = baseByteOffset + float(i);
					result[i] = getByteValue(currentByteOffset);
				}
				
				fragColor = result;
			}
		`),n=this.gl.createProgram();return this.gl.attachShader(n,e),this.gl.attachShader(n,r),this.gl.linkProgram(n),n}createShader(e,r){const n=this.gl.createShader(e);return this.gl.shaderSource(n,r),this.gl.compileShader(n),this.gl.getShaderParameter(n,this.gl.COMPILE_STATUS)||console.error("Shader compile error:",this.gl.getShaderInfoLog(n)),n}createVAO(){const e=this.gl.createVertexArray();this.gl.bindVertexArray(e);const r=new Float32Array([-1,-1,0,1,1,-1,1,1,-1,1,0,0,1,1,1,0]),n=this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER,n),this.gl.bufferData(this.gl.ARRAY_BUFFER,r,this.gl.STATIC_DRAW);const i=this.gl.getAttribLocation(this.colorProgram,"a_position"),a=this.gl.getAttribLocation(this.colorProgram,"a_texCoord");return this.gl.enableVertexAttribArray(i),this.gl.vertexAttribPointer(i,2,this.gl.FLOAT,!1,16,0),this.gl.enableVertexAttribArray(a),this.gl.vertexAttribPointer(a,2,this.gl.FLOAT,!1,16,8),e}createTexture(){const e=this.gl.createTexture();return this.gl.bindTexture(this.gl.TEXTURE_2D,e),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR),e}updateTexture(e){this.lastFrame!==e&&((e.displayWidth!==this.canvas.width||e.displayHeight!==this.canvas.height)&&(this.canvas.width=e.displayWidth,this.canvas.height=e.displayHeight),this.gl.activeTexture(this.gl.TEXTURE0),this.gl.bindTexture(this.gl.TEXTURE_2D,this.sourceTexture),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,e),this.lastFrame=e)}extractColor(e){return this.updateTexture(e),this.gl.useProgram(this.colorProgram),this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.gl.bindVertexArray(this.vao),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),new VideoFrame(this.canvas,{timestamp:e.timestamp,duration:e.duration??void 0,alpha:"discard"})}extractAlpha(e){this.updateTexture(e),this.gl.useProgram(this.alphaProgram),this.gl.uniform2f(this.alphaResolutionLocation,this.canvas.width,this.canvas.height),this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.gl.bindVertexArray(this.vao),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4);const{width:r,height:n}=this.canvas,i=Math.ceil(r/2)*Math.ceil(n/2),a=r*n+i*2,s=Math.ceil(a/(r*4));let o=new Uint8Array(4*r*s);this.gl.readPixels(0,0,r,s,this.gl.RGBA,this.gl.UNSIGNED_BYTE,o),o=o.subarray(0,a),m(o[r*n]===128),m(o[o.length-1]===128);const c={format:"I420",codedWidth:r,codedHeight:n,timestamp:e.timestamp,duration:e.duration??void 0,transfer:[o.buffer]};return new VideoFrame(o,c)}close(){this.gl.getExtension("WEBGL_lose_context")?.loseContext(),this.gl=null}}class Ln extends un{constructor(e){Rc(e),super(e.codec),this._encoder=new Uc(this,e)}add(e,r){if(!(e instanceof de))throw new TypeError("videoSample must be a VideoSample.");return this._encoder.add(e,!1,r)}_flushAndClose(e){return this._encoder.flushAndClose(e)}}class dn extends ln{constructor(e){if(super(),this._connectedTrack=null,!Pe.includes(e))throw new TypeError(`Invalid audio codec '${e}'. Must be one of: ${Pe.join(", ")}.`);this._codec=e}}class Lc extends dn{constructor(e){super(e)}add(e,r){if(!(e instanceof H))throw new TypeError("packet must be an EncodedPacket.");if(e.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be added.");if(r!==void 0&&(!r||typeof r!="object"))throw new TypeError("meta, when provided, must be an object.");return this._ensureValidAdd(),this._connectedTrack.output._muxer.addEncodedAudioPacket(this._connectedTrack,e,r)}}class Hc{constructor(e,r){this.source=e,this.encodingConfig=r,this.ensureEncoderPromise=null,this.encoderInitialized=!1,this.encoder=null,this.muxer=null,this.lastNumberOfChannels=null,this.lastSampleRate=null,this.isPcmEncoder=!1,this.outputSampleSize=null,this.writeOutputValue=null,this.customEncoder=null,this.customEncoderCallSerializer=new ur,this.customEncoderQueueSize=0,this.error=null,this.errorNeedsNewStack=!0}async add(e,r){try{if(this.checkForEncoderError(),this.source._ensureValidAdd(),this.lastNumberOfChannels!==null&&this.lastSampleRate!==null){if(e.numberOfChannels!==this.lastNumberOfChannels||e.sampleRate!==this.lastSampleRate)throw new Error(`Audio parameters must remain constant. Expected ${this.lastNumberOfChannels} channels at ${this.lastSampleRate} Hz, got ${e.numberOfChannels} channels at ${e.sampleRate} Hz.`)}else this.lastNumberOfChannels=e.numberOfChannels,this.lastSampleRate=e.sampleRate;if(this.encoderInitialized||(this.ensureEncoderPromise||this.ensureEncoder(e),this.encoderInitialized||await this.ensureEncoderPromise),m(this.encoderInitialized),this.customEncoder){this.customEncoderQueueSize++;const n=e.clone(),i=this.customEncoderCallSerializer.call(()=>this.customEncoder.encode(n)).then(()=>this.customEncoderQueueSize--).catch(a=>this.error??=a).finally(()=>{n.close()});this.customEncoderQueueSize>=4&&await i,await this.muxer.mutex.currentPromise}else if(this.isPcmEncoder)await this.doPcmEncoding(e,r);else{m(this.encoder);const n=e.toAudioData();this.encoder.encode(n),n.close(),r&&e.close(),this.encoder.encodeQueueSize>=4&&await new Promise(i=>this.encoder.addEventListener("dequeue",i,{once:!0})),await this.muxer.mutex.currentPromise}}finally{r&&e.close()}}async doPcmEncoding(e,r){m(this.outputSampleSize),m(this.writeOutputValue);const{numberOfChannels:n,numberOfFrames:i,sampleRate:a,timestamp:s}=e,o=2048,c=[];for(let h=0;h<i;h+=o){const f=Math.min(o,e.numberOfFrames-h),p=f*n*this.outputSampleSize,g=new ArrayBuffer(p),b=new DataView(g);c.push({frameCount:f,view:b})}const l=e.allocationSize({planeIndex:0,format:"f32-planar"}),u=new Float32Array(l/Float32Array.BYTES_PER_ELEMENT);for(let h=0;h<n;h++){e.copyTo(u,{planeIndex:h,format:"f32-planar"});for(let f=0;f<c.length;f++){const{frameCount:p,view:g}=c[f];for(let b=0;b<p;b++)this.writeOutputValue(g,(b*n+h)*this.outputSampleSize,u[f*o+b])}}r&&e.close();const d={decoderConfig:{codec:this.encodingConfig.codec,numberOfChannels:n,sampleRate:a}};for(let h=0;h<c.length;h++){const{frameCount:f,view:p}=c[h],g=p.buffer,b=h*o,w=new H(new Uint8Array(g),"key",s+b/a,f/a);this.encodingConfig.onEncodedPacket?.(w,d),await this.muxer.addEncodedAudioPacket(this.source._connectedTrack,w,d)}}ensureEncoder(e){const r=new Error;this.ensureEncoderPromise=(async()=>{const{numberOfChannels:n,sampleRate:i}=e,a=Kr({numberOfChannels:n,sampleRate:i,...this.encodingConfig});this.encodingConfig.onEncoderConfig?.(a);const s=Dr.find(o=>o.supports(this.encodingConfig.codec,a));if(s)this.customEncoder=new s,this.customEncoder.codec=this.encodingConfig.codec,this.customEncoder.config=a,this.customEncoder.onPacket=(o,c)=>{if(!(o instanceof H))throw new TypeError("The first argument passed to onPacket must be an EncodedPacket.");if(c!==void 0&&(!c||typeof c!="object"))throw new TypeError("The second argument passed to onPacket must be an object or undefined.");this.encodingConfig.onEncodedPacket?.(o,c),this.muxer.addEncodedAudioPacket(this.source._connectedTrack,o,c).catch(l=>{this.error??=l,this.errorNeedsNewStack=!1})},await this.customEncoder.init();else if(ne.includes(this.encodingConfig.codec))this.initPcmEncoder();else{if(typeof AudioEncoder>"u")throw new Error("AudioEncoder is not supported by this browser.");if(!(await AudioEncoder.isConfigSupported(a)).supported)throw new Error(`This specific encoder configuration (${a.codec}, ${a.bitrate} bps, ${a.numberOfChannels} channels, ${a.sampleRate} Hz) is not supported by this browser. Consider using another codec or changing your audio parameters.`);this.encoder=new AudioEncoder({output:(c,l)=>{const u=H.fromEncodedChunk(c);this.encodingConfig.onEncodedPacket?.(u,l),this.muxer.addEncodedAudioPacket(this.source._connectedTrack,u,l).catch(d=>{this.error??=d,this.errorNeedsNewStack=!1})},error:c=>{c.stack=r.stack,this.error??=c}}),this.encoder.configure(a)}m(this.source._connectedTrack),this.muxer=this.source._connectedTrack.output._muxer,this.encoderInitialized=!0})()}initPcmEncoder(){this.isPcmEncoder=!0;const e=this.encodingConfig.codec,{dataType:r,sampleSize:n,littleEndian:i}=Ke(e);switch(this.outputSampleSize=n,n){case 1:r==="unsigned"?this.writeOutputValue=(a,s,o)=>a.setUint8(s,G((o+1)*127.5,0,255)):r==="signed"?this.writeOutputValue=(a,s,o)=>{a.setInt8(s,G(Math.round(o*128),-128,127))}:r==="ulaw"?this.writeOutputValue=(a,s,o)=>{const c=G(Math.floor(o*32767),-32768,32767);a.setUint8(s,$s(c))}:r==="alaw"?this.writeOutputValue=(a,s,o)=>{const c=G(Math.floor(o*32767),-32768,32767);a.setUint8(s,Ks(c))}:m(!1);break;case 2:r==="unsigned"?this.writeOutputValue=(a,s,o)=>a.setUint16(s,G((o+1)*32767.5,0,65535),i):r==="signed"?this.writeOutputValue=(a,s,o)=>a.setInt16(s,G(Math.round(o*32767),-32768,32767),i):m(!1);break;case 3:r==="unsigned"?this.writeOutputValue=(a,s,o)=>ni(a,s,G((o+1)*83886075e-1,0,16777215),i):r==="signed"?this.writeOutputValue=(a,s,o)=>ds(a,s,G(Math.round(o*8388607),-8388608,8388607),i):m(!1);break;case 4:r==="unsigned"?this.writeOutputValue=(a,s,o)=>a.setUint32(s,G((o+1)*21474836475e-1,0,4294967295),i):r==="signed"?this.writeOutputValue=(a,s,o)=>a.setInt32(s,G(Math.round(o*2147483647),-2147483648,2147483647),i):r==="float"?this.writeOutputValue=(a,s,o)=>a.setFloat32(s,o,i):m(!1);break;case 8:r==="float"?this.writeOutputValue=(a,s,o)=>a.setFloat64(s,o,i):m(!1);break;default:$e(n),m(!1)}}async flushAndClose(e){e||this.checkForEncoderError(),this.customEncoder?(e||this.customEncoderCallSerializer.call(()=>this.customEncoder.flush()),await this.customEncoderCallSerializer.call(()=>this.customEncoder.close())):this.encoder&&(e||await this.encoder.flush(),this.encoder.state!=="closed"&&this.encoder.close()),e||this.checkForEncoderError()}getQueueSize(){return this.customEncoder?this.customEncoderQueueSize:this.isPcmEncoder?0:this.encoder?.encodeQueueSize??0}checkForEncoderError(){if(this.error)throw this.errorNeedsNewStack&&(this.error.stack=new Error().stack),this.error}}class Hn extends dn{constructor(e){Dc(e),super(e.codec),this._encoder=new Hc(this,e)}add(e){if(!(e instanceof Se))throw new TypeError("audioSample must be an AudioSample.");return this._encoder.add(e,!1)}_flushAndClose(e){return this._encoder.flushAndClose(e)}}class qc extends ln{constructor(e){if(super(),this._connectedTrack=null,!er.includes(e))throw new TypeError(`Invalid subtitle codec '${e}'. Must be one of: ${er.join(", ")}.`);this._codec=e}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const $c=["video","audio","subtitle"],vr=t=>{if(!t||typeof t!="object")throw new TypeError("metadata must be an object.");if(t.languageCode!==void 0&&!Dt(t.languageCode))throw new TypeError("metadata.languageCode, when provided, must be a three-letter, ISO 639-2/T language code.");if(t.name!==void 0&&typeof t.name!="string")throw new TypeError("metadata.name, when provided, must be a string.");if(t.maximumPacketCount!==void 0&&(!Number.isInteger(t.maximumPacketCount)||t.maximumPacketCount<0))throw new TypeError("metadata.maximumPacketCount, when provided, must be a non-negative integer.")};class Qr{constructor(e){if(this.state="pending",this._tracks=[],this._startPromise=null,this._cancelPromise=null,this._finalizePromise=null,this._mutex=new je,this._metadataTags={},!e||typeof e!="object")throw new TypeError("options must be an object.");if(!(e.format instanceof rs))throw new TypeError("options.format must be an OutputFormat.");if(!(e.target instanceof on))throw new TypeError("options.target must be a Target.");if(e.target._output)throw new Error("Target is already used for another output.");e.target._output=this,this.format=e.format,this.target=e.target,this._writer=e.target._createWriter(),this._muxer=e.format._createMuxer(this)}addVideoTrack(e,r={}){if(!(e instanceof un))throw new TypeError("source must be a VideoSource.");if(vr(r),r.rotation!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError(`Invalid video rotation: ${r.rotation}. Has to be 0, 90, 180 or 270.`);if(!this.format.supportsVideoRotationMetadata&&r.rotation)throw new Error(`${this.format._name} does not support video rotation metadata.`);if(r.frameRate!==void 0&&(!Number.isFinite(r.frameRate)||r.frameRate<=0))throw new TypeError(`Invalid video frame rate: ${r.frameRate}. Must be a positive number.`);this._addTrack("video",e,r)}addAudioTrack(e,r={}){if(!(e instanceof dn))throw new TypeError("source must be an AudioSource.");vr(r),this._addTrack("audio",e,r)}addSubtitleTrack(e,r={}){if(!(e instanceof qc))throw new TypeError("source must be a SubtitleSource.");vr(r),this._addTrack("subtitle",e,r)}setMetadataTags(e){if(Ar(e),this.state!=="pending")throw new Error("Cannot set metadata tags after output has been started or canceled.");this._metadataTags=e}_addTrack(e,r,n){if(this.state!=="pending")throw new Error("Cannot add track after output has been started or canceled.");if(r._connectedTrack)throw new Error("Source is already used for a track.");const i=this.format.getSupportedTrackCounts(),a=this._tracks.reduce((l,u)=>l+(u.type===e?1:0),0),s=i[e].max;if(a===s)throw new Error(s===0?`${this.format._name} does not support ${e} tracks.`:`${this.format._name} does not support more than ${s} ${e} track${s===1?"":"s"}.`);const o=i.total.max;if(this._tracks.length===o)throw new Error(`${this.format._name} does not support more than ${o} tracks${o===1?"":"s"} in total.`);const c={id:this._tracks.length+1,output:this,type:e,source:r,metadata:n};if(c.type==="video"){const l=this.format.getSupportedVideoCodecs();if(l.length===0)throw new Error(`${this.format._name} does not support video tracks.`+this.format._codecUnsupportedHint(c.source._codec));if(!l.includes(c.source._codec))throw new Error(`Codec '${c.source._codec}' cannot be contained within ${this.format._name}. Supported video codecs are: ${l.map(u=>`'${u}'`).join(", ")}.`+this.format._codecUnsupportedHint(c.source._codec))}else if(c.type==="audio"){const l=this.format.getSupportedAudioCodecs();if(l.length===0)throw new Error(`${this.format._name} does not support audio tracks.`+this.format._codecUnsupportedHint(c.source._codec));if(!l.includes(c.source._codec))throw new Error(`Codec '${c.source._codec}' cannot be contained within ${this.format._name}. Supported audio codecs are: ${l.map(u=>`'${u}'`).join(", ")}.`+this.format._codecUnsupportedHint(c.source._codec))}else if(c.type==="subtitle"){const l=this.format.getSupportedSubtitleCodecs();if(l.length===0)throw new Error(`${this.format._name} does not support subtitle tracks.`+this.format._codecUnsupportedHint(c.source._codec));if(!l.includes(c.source._codec))throw new Error(`Codec '${c.source._codec}' cannot be contained within ${this.format._name}. Supported subtitle codecs are: ${l.map(u=>`'${u}'`).join(", ")}.`+this.format._codecUnsupportedHint(c.source._codec))}this._tracks.push(c),r._connectedTrack=c}async start(){const e=this.format.getSupportedTrackCounts();for(const n of $c){const i=this._tracks.reduce((s,o)=>s+(o.type===n?1:0),0),a=e[n].min;if(i<a)throw new Error(a===e[n].max?`${this.format._name} requires exactly ${a} ${n} track${a===1?"":"s"}.`:`${this.format._name} requires at least ${a} ${n} track${a===1?"":"s"}.`)}const r=e.total.min;if(this._tracks.length<r)throw new Error(r===e.total.max?`${this.format._name} requires exactly ${r} track${r===1?"":"s"}.`:`${this.format._name} requires at least ${r} track${r===1?"":"s"}.`);if(this.state==="canceled")throw new Error("Output has been canceled.");return this._startPromise?(console.warn("Output has already been started."),this._startPromise):this._startPromise=(async()=>{this.state="started",this._writer.start();const n=await this._mutex.acquire();await this._muxer.start();const i=this._tracks.map(a=>a.source._start());await Promise.all(i),n()})()}getMimeType(){return this._muxer.getMimeType()}async cancel(){if(this._cancelPromise)return console.warn("Output has already been canceled."),this._cancelPromise;if(this.state==="finalizing"||this.state==="finalized"){console.warn("Output has already been finalized.");return}return this._cancelPromise=(async()=>{this.state="canceled";const e=await this._mutex.acquire(),r=this._tracks.map(n=>n.source._flushOrWaitForOngoingClose(!0));await Promise.all(r),await this._writer.close(),e()})()}async finalize(){if(this.state==="pending")throw new Error("Cannot finalize before starting.");if(this.state==="canceled")throw new Error("Cannot finalize after canceling.");return this._finalizePromise?(console.warn("Output has already been finalized."),this._finalizePromise):this._finalizePromise=(async()=>{this.state="finalizing";const e=await this._mutex.acquire(),r=this._tracks.map(n=>n.source._flushOrWaitForOngoingClose(!1));await Promise.all(r),await this._muxer.finalize(),await this._writer.flush(),await this._writer.finalize(),this.state="finalized",e()})()}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const qn=t=>{if(t!==void 0&&(!t||typeof t!="object"))throw new TypeError("options.video, when provided, must be an object.");if(t?.discard!==void 0&&typeof t.discard!="boolean")throw new TypeError("options.video.discard, when provided, must be a boolean.");if(t?.forceTranscode!==void 0&&typeof t.forceTranscode!="boolean")throw new TypeError("options.video.forceTranscode, when provided, must be a boolean.");if(t?.codec!==void 0&&!Ce.includes(t.codec))throw new TypeError(`options.video.codec, when provided, must be one of: ${Ce.join(", ")}.`);if(t?.bitrate!==void 0&&!(t.bitrate instanceof Re)&&(!Number.isInteger(t.bitrate)||t.bitrate<=0))throw new TypeError("options.video.bitrate, when provided, must be a positive integer or a quality.");if(t?.width!==void 0&&(!Number.isInteger(t.width)||t.width<=0))throw new TypeError("options.video.width, when provided, must be a positive integer.");if(t?.height!==void 0&&(!Number.isInteger(t.height)||t.height<=0))throw new TypeError("options.video.height, when provided, must be a positive integer.");if(t?.fit!==void 0&&!["fill","contain","cover"].includes(t.fit))throw new TypeError("options.video.fit, when provided, must be one of 'fill', 'contain', or 'cover'.");if(t?.width!==void 0&&t.height!==void 0&&t.fit===void 0)throw new TypeError("When both options.video.width and options.video.height are provided, options.video.fit must also be provided.");if(t?.rotate!==void 0&&![0,90,180,270].includes(t.rotate))throw new TypeError("options.video.rotate, when provided, must be 0, 90, 180 or 270.");if(t?.crop!==void 0&&Jr(t.crop,"options.video."),t?.frameRate!==void 0&&(!Number.isFinite(t.frameRate)||t.frameRate<=0))throw new TypeError("options.video.frameRate, when provided, must be a finite positive number.");if(t?.alpha!==void 0&&!["discard","keep"].includes(t.alpha))throw new TypeError("options.video.alpha, when provided, must be either 'discard' or 'keep'.")},$n=t=>{if(t!==void 0&&(!t||typeof t!="object"))throw new TypeError("options.audio, when provided, must be an object.");if(t?.discard!==void 0&&typeof t.discard!="boolean")throw new TypeError("options.audio.discard, when provided, must be a boolean.");if(t?.forceTranscode!==void 0&&typeof t.forceTranscode!="boolean")throw new TypeError("options.audio.forceTranscode, when provided, must be a boolean.");if(t?.codec!==void 0&&!Pe.includes(t.codec))throw new TypeError(`options.audio.codec, when provided, must be one of: ${Pe.join(", ")}.`);if(t?.bitrate!==void 0&&!(t.bitrate instanceof Re)&&(!Number.isInteger(t.bitrate)||t.bitrate<=0))throw new TypeError("options.audio.bitrate, when provided, must be a positive integer or a quality.");if(t?.numberOfChannels!==void 0&&(!Number.isInteger(t.numberOfChannels)||t.numberOfChannels<=0))throw new TypeError("options.audio.numberOfChannels, when provided, must be a positive integer.");if(t?.sampleRate!==void 0&&(!Number.isInteger(t.sampleRate)||t.sampleRate<=0))throw new TypeError("options.audio.sampleRate, when provided, must be a positive integer.")},_r=2,Er=48e3;class hn{static async init(e){const r=new hn(e);return await r._init(),r}constructor(e){if(this._addedCounts={video:0,audio:0,subtitle:0},this._totalTrackCount=0,this._trackPromises=[],this._executed=!1,this._synchronizer=new jc,this._totalDuration=null,this._maxTimestamps=new Map,this._canceled=!1,this.onProgress=void 0,this._computeProgress=!1,this._lastProgress=0,this.isValid=!1,this.utilizedTracks=[],this.discardedTracks=[],!e||typeof e!="object")throw new TypeError("options must be an object.");if(!(e.input instanceof Wi))throw new TypeError("options.input must be an Input.");if(!(e.output instanceof Qr))throw new TypeError("options.output must be an Output.");if(e.output._tracks.length>0||Object.keys(e.output._metadataTags).length>0||e.output.state!=="pending")throw new TypeError("options.output must be fresh: no tracks or metadata tags added and not started.");if(typeof e.video!="function"&&qn(e.video),typeof e.audio!="function"&&$n(e.audio),e.trim!==void 0&&(!e.trim||typeof e.trim!="object"))throw new TypeError("options.trim, when provided, must be an object.");if(e.trim?.start!==void 0&&(!Number.isFinite(e.trim.start)||e.trim.start<0))throw new TypeError("options.trim.start, when provided, must be a non-negative number.");if(e.trim?.end!==void 0&&(!Number.isFinite(e.trim.end)||e.trim.end<0))throw new TypeError("options.trim.end, when provided, must be a non-negative number.");if(e.trim?.start!==void 0&&e.trim.end!==void 0&&e.trim.start>=e.trim.end)throw new TypeError("options.trim.start must be less than options.trim.end.");if(e.tags!==void 0&&(typeof e.tags!="object"||!e.tags)&&typeof e.tags!="function")throw new TypeError("options.tags, when provided, must be an object or a function.");if(typeof e.tags=="object"&&Ar(e.tags),e.showWarnings!==void 0&&typeof e.showWarnings!="boolean")throw new TypeError("options.showWarnings, when provided, must be a boolean.");this._options=e,this.input=e.input,this.output=e.output,this._startTimestamp=e.trim?.start??0,this._endTimestamp=e.trim?.end??1/0;const{promise:r,resolve:n}=ee();this._started=r,this._start=n}async _init(){const e=await this.input.getTracks(),r=this.output.format.getSupportedTrackCounts();let n=1,i=1;for(const l of e){let u;if(l.isVideoTrack()?this._options.video&&(typeof this._options.video=="function"?(u=await this._options.video(l,n),qn(u),n++):u=this._options.video):l.isAudioTrack()?this._options.audio&&(typeof this._options.audio=="function"?(u=await this._options.audio(l,i),$n(u),i++):u=this._options.audio):m(!1),u?.discard){this.discardedTracks.push({track:l,reason:"discarded_by_user"});continue}if(this._totalTrackCount===r.total.max){this.discardedTracks.push({track:l,reason:"max_track_count_reached"});continue}if(this._addedCounts[l.type]===r[l.type].max){this.discardedTracks.push({track:l,reason:"max_track_count_of_type_reached"});continue}l.isVideoTrack()?await this._processVideoTrack(l,u??{}):l.isAudioTrack()&&await this._processAudioTrack(l,u??{})}const a=await this.input.getMetadataTags();let s;if(this._options.tags){const l=typeof this._options.tags=="function"?await this._options.tags(a):this._options.tags;Ar(l),s=l}else s=a;const o=(await this.input.getFormat()).mimeType===this.output.format.mimeType,c=a.raw===s.raw;if(a.raw&&c&&!o&&delete s.raw,this.output.setMetadataTags(s),this.isValid=this._totalTrackCount>=r.total.min&&this._addedCounts.video>=r.video.min&&this._addedCounts.audio>=r.audio.min&&this._addedCounts.subtitle>=r.subtitle.min,this._options.showWarnings??!0){const l=[],u=this.discardedTracks.filter(d=>d.reason!=="discarded_by_user");u.length>0&&l.push("Some tracks had to be discarded from the conversion:",u),this.isValid||l.push(`

`+this._getInvalidityExplanation().join("")),l.length>0&&console.warn(...l)}}_getInvalidityExplanation(){const e=[];if(this.discardedTracks.length===0)e.push("Due to missing tracks, this conversion cannot be executed.");else{const r=this.discardedTracks.every(n=>n.reason==="discarded_by_user"||n.reason==="no_encodable_target_codec");if(e.push("Due to discarded tracks, this conversion cannot be executed."),r){const n=this.discardedTracks.flatMap(i=>i.reason==="discarded_by_user"?[]:i.track.type==="video"?this.output.format.getSupportedVideoCodecs():i.track.type==="audio"?this.output.format.getSupportedAudioCodecs():this.output.format.getSupportedSubtitleCodecs());n.length===1?e.push(`
Tracks were discarded because your environment is not able to encode '${n[0]}'.`):e.push(`
Tracks were discarded because your environment is not able to encode any of the following codecs: ${n.map(i=>`'${i}'`).join(", ")}.`),n.includes("mp3")&&e.push(`
The @mediabunny/mp3-encoder extension package provides support for encoding MP3.`)}else e.push(`
Check the discardedTracks field for more info.`)}return e}async execute(){if(!this.isValid)throw new Error(`Cannot execute this conversion because its output configuration is invalid. Make sure to always check the isValid field before executing a conversion.
`+this._getInvalidityExplanation().join(""));if(this._executed)throw new Error("Conversion cannot be executed twice.");if(this._executed=!0,this.onProgress){this._computeProgress=!0,this._totalDuration=Math.min(await this.input.computeDuration()-this._startTimestamp,this._endTimestamp-this._startTimestamp);for(const e of this.utilizedTracks)this._maxTimestamps.set(e.id,0);this.onProgress?.(0)}await this.output.start(),this._start();try{await Promise.all(this._trackPromises)}catch(e){throw this._canceled||this.cancel(),e}this._canceled&&await new Promise(()=>{}),await this.output.finalize(),this._computeProgress&&this.onProgress?.(1)}async cancel(){if(!(this.output.state==="finalizing"||this.output.state==="finalized")){if(this._canceled){console.warn("Conversion already canceled.");return}this._canceled=!0,await this.output.cancel()}}async _processVideoTrack(e,r){const n=e.codec;if(!n){this.discardedTracks.push({track:e,reason:"unknown_source_codec"});return}let i;const a=Xr(e.rotation+(r.rotate??0)),s=this.output.format.supportsVideoRotationMetadata,[o,c]=a%180===0?[e.codedWidth,e.codedHeight]:[e.codedHeight,e.codedWidth],l=r.crop;l&&Zr(l,o,c);const[u,d]=l?[l.width,l.height]:[o,c];let h=u,f=d;const p=h/f,g=x=>Math.ceil(x/2)*2;r.width!==void 0&&r.height===void 0?(h=g(r.width),f=g(Math.round(h/p))):r.width===void 0&&r.height!==void 0?(f=g(r.height),h=g(Math.round(f*p))):r.width!==void 0&&r.height!==void 0&&(h=g(r.width),f=g(r.height));const b=await e.getFirstTimestamp(),w=!!r.forceTranscode||this._startTimestamp>0||b<0||!!r.frameRate;let k=h!==u||f!==d||a!==0&&!s||!!l;const T=r.alpha??"discard";let y=this.output.format.getSupportedVideoCodecs();if(!w&&!r.bitrate&&!k&&y.includes(n)&&(!r.codec||r.codec===n)){const x=new Vc(n);i=x,this._trackPromises.push((async()=>{await this._started;const _=new Ot(e),F={decoderConfig:await e.getDecoderConfig()??void 0},v=Number.isFinite(this._endTimestamp)?await _.getPacket(this._endTimestamp,{metadataOnly:!0})??void 0:void 0;for await(const I of _.packets(void 0,v,{verifyKeyPackets:!0})){if(this._synchronizer.shouldWait(e.id,I.timestamp)&&await this._synchronizer.wait(I.timestamp),this._canceled)return;T==="discard"&&(delete I.sideData.alpha,delete I.sideData.alphaByteLength),await x.add(I,F),this._reportProgress(e.id,I.timestamp+I.duration)}x.close(),this._synchronizer.closeTrack(e.id)})())}else{if(!await e.canDecode()){this.discardedTracks.push({track:e,reason:"undecodable_source_codec"});return}r.codec&&(y=y.filter(I=>I===r.codec));const _=r.bitrate??Un,C=await Nc(y,{width:h,height:f,bitrate:_});if(!C){this.discardedTracks.push({track:e,reason:"no_encodable_target_codec"});return}const F={codec:C,bitrate:_,sizeChangeBehavior:r.fit??"passThrough",alpha:T,onEncodedPacket:I=>this._reportProgress(e.id,I.timestamp+I.duration)},v=new Ln(F);if(i=v,!k){const I=new Qr({format:new cn,target:new Fc}),A=new Ln(F);I.addVideoTrack(A),await I.start();const W=await new Mr(e).getSample(b);if(W)try{await A.add(W),W.close(),await I.finalize()}catch(Y){console.info("Error when probing encoder support. Falling back to rerender path.",Y),k=!0,I.cancel()}else await I.cancel()}k?this._trackPromises.push((async()=>{await this._started;const A=new Js(e,{width:h,height:f,fit:r.fit??"fill",rotation:a,crop:r.crop,poolSize:1,alpha:T==="keep"}).canvases(this._startTimestamp,this._endTimestamp),M=r.frameRate;let W=null,Y=null,rt=null;const re=async oe=>{m(W),m(M!==void 0);const ie=Math.round((oe-Y)*M);for(let nt=1;nt<ie;nt++){const Ge=new de(W,{timestamp:Y+nt/M,duration:1/M});await v.add(Ge)}};for await(const{canvas:oe,timestamp:ie,duration:nt}of A){if(this._synchronizer.shouldWait(e.id,ie)&&await this._synchronizer.wait(ie),this._canceled)return;let Ge=Math.max(ie-this._startTimestamp,0);if(rt=Ge+nt,M!==void 0){const qt=Math.floor(Ge*M)/M;if(W!==null)if(qt<=Y){W=oe,Y=qt;continue}else await re(qt);Ge=qt}const mn=new de(oe,{timestamp:Ge,duration:M!==void 0?1/M:nt});await v.add(mn),M!==void 0?(W=oe,Y=Ge):mn.close()}W&&(m(rt!==null),m(M!==void 0),await re(Math.floor(rt*M)/M)),v.close(),this._synchronizer.closeTrack(e.id)})()):this._trackPromises.push((async()=>{await this._started;const I=new Mr(e),A=r.frameRate;let M=null,W=null,Y=null;const rt=async re=>{m(M),m(A!==void 0);const oe=Math.round((re-W)*A);for(let ie=1;ie<oe;ie++)M.setTimestamp(W+ie/A),M.setDuration(1/A),await v.add(M);M.close()};for await(const re of I.samples(this._startTimestamp,this._endTimestamp)){if(this._synchronizer.shouldWait(e.id,re.timestamp)&&await this._synchronizer.wait(re.timestamp),this._canceled){M?.close();return}let oe=Math.max(re.timestamp-this._startTimestamp,0);if(Y=oe+re.duration,A!==void 0){const ie=Math.floor(oe*A)/A;if(M!==null)if(ie<=W){M.close(),M=re,W=ie;continue}else await rt(ie);oe=ie,re.setDuration(1/A)}re.setTimestamp(oe),await v.add(re),A!==void 0?(M=re,W=oe):re.close()}M&&(m(Y!==null),m(A!==void 0),await rt(Math.floor(Y*A)/A)),v.close(),this._synchronizer.closeTrack(e.id)})())}this.output.addVideoTrack(i,{frameRate:r.frameRate,languageCode:Dt(e.languageCode)?e.languageCode:void 0,name:e.name??void 0,rotation:k?0:a}),this._addedCounts.video++,this._totalTrackCount++,this.utilizedTracks.push(e)}async _processAudioTrack(e,r){const n=e.codec;if(!n){this.discardedTracks.push({track:e,reason:"unknown_source_codec"});return}let i;const a=e.numberOfChannels,s=e.sampleRate,o=await e.getFirstTimestamp();let c=r.numberOfChannels??a,l=r.sampleRate??s,u=c!==a||l!==s||this._startTimestamp>0||o<0,d=this.output.format.getSupportedAudioCodecs();if(!r.forceTranscode&&!r.bitrate&&!u&&d.includes(n)&&(!r.codec||r.codec===n)){const h=new Lc(n);i=h,this._trackPromises.push((async()=>{await this._started;const f=new Ot(e),g={decoderConfig:await e.getDecoderConfig()??void 0},b=Number.isFinite(this._endTimestamp)?await f.getPacket(this._endTimestamp,{metadataOnly:!0})??void 0:void 0;for await(const w of f.packets(void 0,b)){if(this._synchronizer.shouldWait(e.id,w.timestamp)&&await this._synchronizer.wait(w.timestamp),this._canceled)return;await h.add(w,g),this._reportProgress(e.id,w.timestamp+w.duration)}h.close(),this._synchronizer.closeTrack(e.id)})())}else{if(!await e.canDecode()){this.discardedTracks.push({track:e,reason:"undecodable_source_codec"});return}let f=null;r.codec&&(d=d.filter(b=>b===r.codec));const p=r.bitrate??Un,g=await Wn(d,{numberOfChannels:c,sampleRate:l,bitrate:p});if(!g.some(b=>At.includes(b))&&d.some(b=>At.includes(b))&&(c!==_r||l!==Er)){const w=(await Wn(d,{numberOfChannels:_r,sampleRate:Er,bitrate:p})).find(k=>At.includes(k));w&&(u=!0,f=w,c=_r,l=Er)}else f=g[0]??null;if(f===null){this.discardedTracks.push({track:e,reason:"no_encodable_target_codec"});return}if(u)i=this._resampleAudio(e,f,c,l,p);else{const b=new Hn({codec:f,bitrate:p,onEncodedPacket:w=>this._reportProgress(e.id,w.timestamp+w.duration)});i=b,this._trackPromises.push((async()=>{await this._started;const w=new En(e);for await(const k of w.samples(void 0,this._endTimestamp)){if(this._synchronizer.shouldWait(e.id,k.timestamp)&&await this._synchronizer.wait(k.timestamp),this._canceled)return;await b.add(k),k.close()}b.close(),this._synchronizer.closeTrack(e.id)})())}}this.output.addAudioTrack(i,{languageCode:Dt(e.languageCode)?e.languageCode:void 0,name:e.name??void 0}),this._addedCounts.audio++,this._totalTrackCount++,this.utilizedTracks.push(e)}_resampleAudio(e,r,n,i,a){const s=new Hn({codec:r,bitrate:a,onEncodedPacket:o=>this._reportProgress(e.id,o.timestamp+o.duration)});return this._trackPromises.push((async()=>{await this._started;const o=new Kc({targetNumberOfChannels:n,targetSampleRate:i,startTime:this._startTimestamp,endTime:this._endTimestamp,onSample:u=>s.add(u)}),l=new En(e).samples(this._startTimestamp,this._endTimestamp);for await(const u of l){if(this._synchronizer.shouldWait(e.id,u.timestamp)&&await this._synchronizer.wait(u.timestamp),this._canceled)return;await o.add(u)}await o.finalize(),s.close(),this._synchronizer.closeTrack(e.id)})()),s}_reportProgress(e,r){if(!this._computeProgress)return;m(this._totalDuration!==null),this._maxTimestamps.set(e,Math.max(r,this._maxTimestamps.get(e)));const n=Math.min(...this._maxTimestamps.values()),i=G(n/this._totalDuration,0,1);i!==this._lastProgress&&(this._lastProgress=i,this.onProgress?.(i))}}const jn=5;class jc{constructor(){this.maxTimestamps=new Map,this.resolvers=[]}computeMinAndMaybeResolve(){let e=1/0;for(const[,r]of this.maxTimestamps)e=Math.min(e,r);for(let r=0;r<this.resolvers.length;r++){const n=this.resolvers[r];n.timestamp-e<jn&&(n.resolve(),this.resolvers.splice(r,1),r--)}return e}shouldWait(e,r){this.maxTimestamps.set(e,Math.max(r,this.maxTimestamps.get(e)??-1/0));const n=this.computeMinAndMaybeResolve();return r-n>=jn}wait(e){const{promise:r,resolve:n}=ee();return this.resolvers.push({timestamp:e,resolve:n}),r}closeTrack(e){this.maxTimestamps.delete(e),this.computeMinAndMaybeResolve()}}class Kc{constructor(e){this.sourceSampleRate=null,this.sourceNumberOfChannels=null,this.targetSampleRate=e.targetSampleRate,this.targetNumberOfChannels=e.targetNumberOfChannels,this.startTime=e.startTime,this.endTime=e.endTime,this.onSample=e.onSample,this.bufferSizeInFrames=Math.floor(this.targetSampleRate*5),this.bufferSizeInSamples=this.bufferSizeInFrames*this.targetNumberOfChannels,this.outputBuffer=new Float32Array(this.bufferSizeInSamples),this.bufferStartFrame=0,this.maxWrittenFrame=-1}doChannelMixerSetup(){m(this.sourceNumberOfChannels!==null);const e=this.sourceNumberOfChannels,r=this.targetNumberOfChannels;e===1&&r===2?this.channelMixer=(n,i)=>n[i*e]:e===1&&r===4?this.channelMixer=(n,i,a)=>n[i*e]*+(a<2):e===1&&r===6?this.channelMixer=(n,i,a)=>n[i*e]*+(a===2):e===2&&r===1?this.channelMixer=(n,i)=>{const a=i*e;return .5*(n[a]+n[a+1])}:e===2&&r===4?this.channelMixer=(n,i,a)=>n[i*e+a]*+(a<2):e===2&&r===6?this.channelMixer=(n,i,a)=>n[i*e+a]*+(a<2):e===4&&r===1?this.channelMixer=(n,i)=>{const a=i*e;return .25*(n[a]+n[a+1]+n[a+2]+n[a+3])}:e===4&&r===2?this.channelMixer=(n,i,a)=>{const s=i*e;return .5*(n[s+a]+n[s+a+2])}:e===4&&r===6?this.channelMixer=(n,i,a)=>{const s=i*e;return a<2?n[s+a]:a===2||a===3?0:n[s+a-2]}:e===6&&r===1?this.channelMixer=(n,i)=>{const a=i*e;return Math.SQRT1_2*(n[a]+n[a+1])+n[a+2]+.5*(n[a+4]+n[a+5])}:e===6&&r===2?this.channelMixer=(n,i,a)=>{const s=i*e;return n[s+a]+Math.SQRT1_2*(n[s+2]+n[s+a+4])}:e===6&&r===4?this.channelMixer=(n,i,a)=>{const s=i*e;return a<2?n[s+a]+Math.SQRT1_2*n[s+2]:n[s+a+2]}:this.channelMixer=(n,i,a)=>a<e?n[i*e+a]:0}ensureTempBufferSize(e){let r=this.tempSourceBuffer.length;for(;r<e;)r*=2;if(r!==this.tempSourceBuffer.length){const n=new Float32Array(r);n.set(this.tempSourceBuffer),this.tempSourceBuffer=n}}async add(e){this.sourceSampleRate===null&&(this.sourceSampleRate=e.sampleRate,this.sourceNumberOfChannels=e.numberOfChannels,this.tempSourceBuffer=new Float32Array(this.sourceSampleRate*this.sourceNumberOfChannels),this.doChannelMixerSetup());const r=e.numberOfFrames*e.numberOfChannels;this.ensureTempBufferSize(r);const n=e.allocationSize({planeIndex:0,format:"f32"}),i=new Float32Array(this.tempSourceBuffer.buffer,0,n/4);e.copyTo(i,{planeIndex:0,format:"f32"});const a=e.timestamp-this.startTime,s=e.numberOfFrames/this.sourceSampleRate,o=Math.min(a+s,this.endTime-this.startTime),c=Math.floor(a*this.targetSampleRate),l=Math.ceil(o*this.targetSampleRate);for(let u=c;u<l;u++){if(u<this.bufferStartFrame)continue;for(;u>=this.bufferStartFrame+this.bufferSizeInFrames;)await this.finalizeCurrentBuffer(),this.bufferStartFrame+=this.bufferSizeInFrames;const d=u-this.bufferStartFrame;m(d<this.bufferSizeInFrames);const p=(u/this.targetSampleRate-a)*this.sourceSampleRate,g=Math.floor(p),b=Math.ceil(p),w=p-g;for(let k=0;k<this.targetNumberOfChannels;k++){let T=0,y=0;g>=0&&g<e.numberOfFrames&&(T=this.channelMixer(i,g,k)),b>=0&&b<e.numberOfFrames&&(y=this.channelMixer(i,b,k));const x=T+w*(y-T),_=d*this.targetNumberOfChannels+k;this.outputBuffer[_]+=x}this.maxWrittenFrame=Math.max(this.maxWrittenFrame,d)}}async finalizeCurrentBuffer(){if(this.maxWrittenFrame<0)return;const e=(this.maxWrittenFrame+1)*this.targetNumberOfChannels,r=new Float32Array(e);r.set(this.outputBuffer.subarray(0,e));const n=this.bufferStartFrame/this.targetSampleRate,i=new Se({format:"f32",sampleRate:this.targetSampleRate,numberOfChannels:this.targetNumberOfChannels,timestamp:n,data:r});await this.onSample(i),this.outputBuffer.fill(0),this.maxWrittenFrame=-1}finalize(){return this.finalizeCurrentBuffer()}}const Qc=document.querySelector("#select-file"),Gc=document.querySelector("#load-url"),Xc=document.querySelector("#file-name"),Yc=document.querySelector("hr");document.querySelector("#progress-bar-container");const Zc=document.querySelector("#progress-bar"),Kn=document.querySelector("#speedometer"),ot=document.querySelector("video"),Jc=document.querySelector("#compression-facts"),Qn=document.querySelector("#error-element"),Gn=document.querySelector("#error-message"),el=document.querySelector("#file-info-section"),tl=document.querySelector("#original-size"),rl=document.querySelector("#file-duration"),Kt=document.querySelector("#file-resolution"),Qt=document.querySelector("#progress-container"),nl=document.querySelector("#progress-percentage"),Xn=document.querySelector("#eta"),Ir=document.querySelector("#success-info"),il=document.querySelector("#original-file-size"),sl=document.querySelector("#compressed-file-size"),al=document.querySelector("#space-saved"),ol=document.querySelector("#download-btn"),et=document.querySelector("#drop-zone"),Yn=document.querySelectorAll(".preset-btn");let Gr="medium",Et=null,Gt=-1,Rt=null,ct=0;const cl={low:{targetSize:3,videoBitrateFactor:.7,audioBitrate:32},medium:{targetSize:7.2,videoBitrateFactor:.9,audioBitrate:64},high:{targetSize:8,videoBitrateFactor:1,audioBitrate:128}},Xt=t=>{if(t===0)return"0 B";const e=1024,r=["B","KB","MB","GB"],n=Math.floor(Math.log(t)/Math.log(e));return`${parseFloat((t/Math.pow(e,n)).toFixed(1))} ${r[n]}`},ll=t=>{const e=Math.floor(t/60),r=Math.floor(t%60);return`${e}:${r.toString().padStart(2,"0")}`};Yn.forEach(t=>{t.addEventListener("click",()=>{Yn.forEach(e=>e.classList.remove("active","ring-2","ring-blue-500")),t.classList.add("active","ring-2","ring-blue-500"),Gr=t.dataset.preset})});document.querySelector('[data-preset="medium"]')?.classList.add("ring-2","ring-blue-500");const fn=async t=>{clearInterval(Gt),await Et?.cancel(),Xc.textContent=t instanceof File?t.name:t,el.style.display="block",Yc.style.display="block",Qt.style.display="none",ot.style.display="none",ot.src="",Qn.style.display="none",Ir.style.display="none",Gn.textContent="";try{const e=t instanceof File?new mo(t):new go(t),r=new Wi({source:e,formats:fo});ct=await e.getSize();const n=ct/(1024*1024),i=await r.getPrimaryVideoTrack(),a=await i?.computeDuration(),s=await i?.computePacketStats();tl.textContent=` Size: ${Xt(ct)}`,rl.textContent=a?` Duration: ${ll(a)}`:" Duration: -";try{Kt.textContent=" Resolution: Processing...";const v=s?.width||0,I=s?.height||0;v&&I?Kt.textContent=` Resolution: ${v}x${I}`:Kt.textContent=" Resolution: Unknown"}catch{Kt.textContent=" Resolution: Unknown"}const o=t instanceof File?t.name:t,c=[".mp4",".avi",".mov",".mkv",".webm",".wmv",".flv",".m4v"];if(!c.some(v=>o.toLowerCase().endsWith(v)))throw new Error(`Unsupported file format. Please use: ${c.join(", ")}`);const u=new Qr({target:new ts,format:new cn}),d=await r.computeDuration(),h=cl[Gr],p=h.targetSize*1024*1024*8*.9,g=h.audioBitrate*1e3,b=g*d,w=p-b,k=Math.max(1e5,Math.round(w/d*h.videoBitrateFactor));console.log(`Duration: ${d}s`),console.log(`Preset: ${Gr}`),console.log(`Target size: ${h.targetSize.toFixed(1)}MB`),console.log(`Audio bitrate: ${h.audioBitrate}kbps`),console.log(`Video bitrate: ${(k/1e3).toFixed(0)}kbps`),Qt.style.display="block",Et=await hn.init({input:r,output:u,video:{width:1280,bitrate:k,frameRate:24},audio:{bitrate:g}});let T=0;const y=performance.now();Et.onProgress=v=>{T=v};const x=()=>{const v=Math.round(T*100);Zc.style.width=`${v}%`,nl.textContent=`${v}%`;const A=(performance.now()-y)/1e3;if(T>0){const M=d/(A/T);Kn.textContent=`Speed: ~${M.toPrecision(3)}x realtime`;const W=A/T*(1-T);Xn.textContent=`ETA: ${Math.max(0,Math.round(W))}s`}else Kn.textContent="Speed: -",Xn.textContent="ETA: -"};Gt=window.setInterval(x,1e3/30),await Et.execute(),clearInterval(Gt),x(),Rt=new Blob([u.target.buffer],{type:u.format.mimeType}),Qt.style.display="none",ot.style.display="block",ot.src=URL.createObjectURL(Rt),Ir.style.display="block";const _=Rt.size,C=_/ct*100,F=ct-_;il.textContent=Xt(ct),sl.textContent=Xt(_),Jc.textContent=`${C.toFixed(1)}% of original size`,al.textContent=Xt(F),ot.play()}catch(e){console.error(e),await Et?.cancel(),clearInterval(Gt),Gn.textContent=String(e),Qn.style.display="block",Qt.style.display="none",Ir.style.display="none",ot.style.display="none"}};ol.addEventListener("click",()=>{if(!Rt)return;const t=URL.createObjectURL(Rt),e=document.createElement("a");e.href=t,e.download=`compressed_video_${Date.now()}.mp4`,document.body.appendChild(e),e.click(),document.body.removeChild(e),URL.revokeObjectURL(t)});let or=0;et.addEventListener("dragenter",t=>{t.preventDefault(),or++,et.classList.add("border-blue-500","bg-blue-50","dark:bg-blue-900/20")});et.addEventListener("dragleave",t=>{t.preventDefault(),or--,or===0&&et.classList.remove("border-blue-500","bg-blue-50","dark:bg-blue-900/20")});et.addEventListener("dragover",t=>{t.preventDefault(),t.dataTransfer.dropEffect="copy"});et.addEventListener("drop",t=>{t.preventDefault(),or=0,et.classList.remove("border-blue-500","bg-blue-50","dark:bg-blue-900/20");const e=t.dataTransfer?.files,r=e&&e.length>0?e[0]:void 0;r&&fn(r)});Qc.addEventListener("click",()=>{const t=document.createElement("input");t.type="file",t.accept="video/*,video/x-matroska,audio/*,audio/aac",t.addEventListener("change",()=>{const e=t.files?.[0];e&&fn(e)}),t.click()});Gc.addEventListener("click",()=>{const t=prompt("Please enter a URL of a media file. Note that it must be HTTPS and support cross-origin requests, so have the right CORS headers set.","https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4");t&&fn(t)});
