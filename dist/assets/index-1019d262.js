(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const s of i)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function r(i){const s={};return i.integrity&&(s.integrity=i.integrity),i.referrerPolicy&&(s.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?s.credentials="include":i.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(i){if(i.ep)return;i.ep=!0;const s=r(i);fetch(i.href,s)}})();/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */function h(t){if(!t)throw new Error("Assertion failed.")}const vn=t=>{const e=(t%360+360)%360;if(e===0||e===90||e===180||e===270)return e;throw new Error(`Invalid rotation ${t}.`)},ue=t=>t&&t[t.length-1],qt=t=>t>=0&&t<2**32;class de{constructor(e){this.bytes=e,this.pos=0}seekToByte(e){this.pos=8*e}readBit(){const e=Math.floor(this.pos/8),r=this.bytes[e]??0,n=7-(this.pos&7),i=(r&1<<n)>>n;return this.pos++,i}readBits(e){if(e===1)return this.readBit();let r=0;for(let n=0;n<e;n++)r<<=1,r|=this.readBit();return r}writeBits(e,r){const n=this.pos+e;for(let i=this.pos;i<n;i++){const s=Math.floor(i/8);let a=this.bytes[s];const o=7-(i&7);a&=~(1<<o),a|=(r&1<<n-i-1)>>n-i-1<<o,this.bytes[s]=a}this.pos=n}readAlignedByte(){if(this.pos%8!==0)throw new Error("Bitstream is not byte-aligned.");const e=this.pos/8,r=this.bytes[e]??0;return this.pos+=8,r}skipBits(e){this.pos+=e}getBitsLeft(){return this.bytes.length*8-this.pos}clone(){const e=new de(this.bytes);return e.pos=this.pos,e}}const V=t=>{let e=0;for(;t.readBits(1)===0&&e<32;)e++;if(e>=32)throw new Error("Invalid exponential-Golomb code.");return(1<<e)-1+t.readBits(e)},sr=t=>{const e=V(t);return e&1?e+1>>1:-(e>>1)},$e=t=>t.constructor===Uint8Array?t:t instanceof ArrayBuffer?new Uint8Array(t):new Uint8Array(t.buffer,t.byteOffset,t.byteLength),Te=t=>t.constructor===DataView?t:t instanceof ArrayBuffer?new DataView(t):new DataView(t.buffer,t.byteOffset,t.byteLength),Be=new TextDecoder,He=new TextEncoder,En=t=>Object.fromEntries(Object.entries(t).map(([e,r])=>[r,e])),mr={bt709:1,bt470bg:5,smpte170m:6,bt2020:9,smpte432:12},Ii=En(mr),pr={bt709:1,smpte170m:6,linear:8,"iec61966-2-1":13,pg:16,hlg:18},Fi=En(pr),gr={rgb:0,bt709:1,bt470bg:5,smpte170m:6,"bt2020-ncl":9},Ai=En(gr),Vs=t=>!!t&&!!t.primaries&&!!t.transfer&&!!t.matrix&&t.fullRange!==void 0,Mr=t=>t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer||ArrayBuffer.isView(t);class wt{constructor(){this.currentPromise=Promise.resolve()}async acquire(){let e;const r=new Promise(i=>{e=i}),n=this.currentPromise;return this.currentPromise=r,await n,e}}const $n=t=>[...t].map(e=>e.toString(16).padStart(2,"0")).join(""),jn=t=>(t=t>>1&1431655765|(t&1431655765)<<1,t=t>>2&858993459|(t&858993459)<<2,t=t>>4&252645135|(t&252645135)<<4,t=t>>8&16711935|(t&16711935)<<8,t=t>>16&65535|(t&65535)<<16,t>>>0),fe=(t,e,r)=>{let n=0,i=t.length-1,s=-1;for(;n<=i;){const a=n+i>>1,o=r(t[a]);o===e?(s=a,i=a-1):o<e?n=a+1:i=a-1}return s},te=(t,e,r)=>{let n=0,i=t.length-1,s=-1;for(;n<=i;){const a=n+(i-n+1)/2|0;r(t[a])<=e?(s=a,n=a+1):i=a-1}return s},pt=(t,e,r)=>{const n=te(t,r(e),r);t.splice(n+1,0,e)},ke=()=>{let t,e;return{promise:new Promise((n,i)=>{t=n,e=i}),resolve:t,reject:e}},Bi=(t,e)=>{for(let r=t.length-1;r>=0;r--)if(e(t[r]))return t[r]},zi=(t,e)=>{for(let r=t.length-1;r>=0;r--)if(e(t[r]))return r;return-1},Us=async function*(t){Symbol.iterator in t?yield*t[Symbol.iterator]():yield*t[Symbol.asyncIterator]()},Ws=t=>{if(!(Symbol.iterator in t)&&!(Symbol.asyncIterator in t))throw new TypeError("Argument must be an iterable or async iterable.")},bt=t=>{throw new Error(`Unexpected value: ${t}`)},Nr=(t,e,r)=>{const n=t.getUint8(e),i=t.getUint8(e+1),s=t.getUint8(e+2);return r?n|i<<8|s<<16:n<<16|i<<8|s},Ls=(t,e,r)=>Nr(t,e,r)<<8>>8,Ri=(t,e,r,n)=>{r=r>>>0,r=r&16777215,n?(t.setUint8(e,r&255),t.setUint8(e+1,r>>>8&255),t.setUint8(e+2,r>>>16&255)):(t.setUint8(e,r>>>16&255),t.setUint8(e+1,r>>>8&255),t.setUint8(e+2,r&255))},Hs=(t,e,r,n)=>{r=pe(r,-8388608,8388607),r<0&&(r=r+16777216&16777215),Ri(t,e,r,n)},Kn=(t,e)=>({async next(){const r=await t.next();return r.done?{value:void 0,done:!0}:{value:e(r.value),done:!1}},return(){return t.return()},throw(r){return t.throw(r)},[Symbol.asyncIterator](){return this}}),pe=(t,e,r)=>Math.max(e,Math.min(r,t)),Fe="und",vr=(t,e)=>{const r=10**e;return Math.round(t*r)/r},qs=(t,e)=>Math.round(t/e)*e,$s=t=>{let e=0;for(;t;)e++,t>>=1;return e},js=/^[a-z]{3}$/,ur=t=>js.test(t),ht=1e6*(1+Number.EPSILON),Qn=(t,e)=>{const r={...t,...e};if(t.headers||e.headers){const n=t.headers?Gn(t.headers):{},i=e.headers?Gn(e.headers):{},s={...n};Object.entries(i).forEach(([a,o])=>{const c=Object.keys(s).find(l=>l.toLowerCase()===a.toLowerCase());c&&delete s[c],s[a]=o}),r.headers=s}return r},Gn=t=>{if(t instanceof Headers){const e={};return t.forEach((r,n)=>{e[n]=r}),e}if(Array.isArray(t)){const e={};return t.forEach(([r,n])=>{e[r]=n}),e}return t},Xn=async(t,e,r,n)=>{let i=0;for(;;)try{return await t(e,r)}catch(s){i++;const a=n(i,s);if(a===null)throw s;if(console.error("Retrying failed fetch. Error:",s),!Number.isFinite(a)||a<0)throw new TypeError("Retry delay must be a non-negative finite number.");a>0&&await new Promise(o=>setTimeout(o,1e3*a))}},Ks=(t,e)=>{const r=t<0?-1:1;t=Math.abs(t);let n=0,i=1,s=1,a=0,o=t;for(;;){const c=Math.floor(o),l=c*s+n,u=c*a+i;if(u>e)return{numerator:r*s,denominator:a};if(n=s,i=a,s=l,a=u,o=1/(o-c),!isFinite(o))break}return{numerator:r*s,denominator:a}};class Or{constructor(){this.currentPromise=Promise.resolve()}call(e){return this.currentPromise=this.currentPromise.then(e)}}let Lr=null;const Hr=()=>{var e,r,n,i;if(Lr!==null)return Lr;const t=!!(typeof navigator<"u"&&((e=navigator.vendor)!=null&&e.match(/apple/i))&&!((r=navigator.userAgent)!=null&&r.match(/crios/i))&&!((n=navigator.userAgent)!=null&&n.match(/fxios/i))&&!((i=navigator.userAgent)!=null&&i.match(/Opera|OPT\//)));return Lr=t,t};let qr=null;const dr=()=>{var t;return qr!==null?qr:qr=typeof navigator<"u"&&((t=navigator.userAgent)==null?void 0:t.includes("Firefox"))},zt=(t,e)=>t!==-1?t:e,on=(t,e,r,n)=>t<=n&&r<=e,Di=function*(t){for(const e in t){const r=t[e];r!==void 0&&(yield{key:e,value:r})}},Qs=t=>{const e=atob(t),r=new Uint8Array(e.length);for(let n=0;n<e.length;n++)r[n]=e.charCodeAt(n);return r},Mi=()=>{Symbol.dispose??(Symbol.dispose=Symbol("Symbol.dispose"))};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Ut{constructor(e,r){if(this.data=e,this.mimeType=r,!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if(typeof r!="string")throw new TypeError("mimeType must be a string.")}}class Ni{constructor(e,r,n,i){if(this.data=e,this.mimeType=r,this.name=n,this.description=i,!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if(r!==void 0&&typeof r!="string")throw new TypeError("mimeType, when provided, must be a string.");if(n!==void 0&&typeof n!="string")throw new TypeError("name, when provided, must be a string.");if(i!==void 0&&typeof i!="string")throw new TypeError("description, when provided, must be a string.")}}const cn=t=>{if(!t||typeof t!="object")throw new TypeError("tags must be an object.");if(t.title!==void 0&&typeof t.title!="string")throw new TypeError("tags.title, when provided, must be a string.");if(t.description!==void 0&&typeof t.description!="string")throw new TypeError("tags.description, when provided, must be a string.");if(t.artist!==void 0&&typeof t.artist!="string")throw new TypeError("tags.artist, when provided, must be a string.");if(t.album!==void 0&&typeof t.album!="string")throw new TypeError("tags.album, when provided, must be a string.");if(t.albumArtist!==void 0&&typeof t.albumArtist!="string")throw new TypeError("tags.albumArtist, when provided, must be a string.");if(t.trackNumber!==void 0&&(!Number.isInteger(t.trackNumber)||t.trackNumber<=0))throw new TypeError("tags.trackNumber, when provided, must be a positive integer.");if(t.tracksTotal!==void 0&&(!Number.isInteger(t.tracksTotal)||t.tracksTotal<=0))throw new TypeError("tags.tracksTotal, when provided, must be a positive integer.");if(t.discNumber!==void 0&&(!Number.isInteger(t.discNumber)||t.discNumber<=0))throw new TypeError("tags.discNumber, when provided, must be a positive integer.");if(t.discsTotal!==void 0&&(!Number.isInteger(t.discsTotal)||t.discsTotal<=0))throw new TypeError("tags.discsTotal, when provided, must be a positive integer.");if(t.genre!==void 0&&typeof t.genre!="string")throw new TypeError("tags.genre, when provided, must be a string.");if(t.date!==void 0&&(!(t.date instanceof Date)||Number.isNaN(t.date.getTime())))throw new TypeError("tags.date, when provided, must be a valid Date.");if(t.lyrics!==void 0&&typeof t.lyrics!="string")throw new TypeError("tags.lyrics, when provided, must be a string.");if(t.images!==void 0){if(!Array.isArray(t.images))throw new TypeError("tags.images, when provided, must be an array.");for(const e of t.images){if(!e||typeof e!="object")throw new TypeError("Each image in tags.images must be an object.");if(!(e.data instanceof Uint8Array))throw new TypeError("Each image.data must be a Uint8Array.");if(typeof e.mimeType!="string")throw new TypeError("Each image.mimeType must be a string.");if(!["coverFront","coverBack","unknown"].includes(e.kind))throw new TypeError("Each image.kind must be 'coverFront', 'coverBack', or 'unknown'.")}}if(t.comment!==void 0&&typeof t.comment!="string")throw new TypeError("tags.comment, when provided, must be a string.");if(t.raw!==void 0){if(!t.raw||typeof t.raw!="object")throw new TypeError("tags.raw, when provided, must be an object.");for(const e of Object.values(t.raw))if(e!==null&&typeof e!="string"&&!(e instanceof Uint8Array)&&!(e instanceof Ut)&&!(e instanceof Ni))throw new TypeError("Each value in tags.raw must be a string, Uint8Array, RichImageData, AttachedFile, or null.")}};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const je=["avc","hevc","vp9","av1","vp8"],ye=["pcm-s16","pcm-s16be","pcm-s24","pcm-s24be","pcm-s32","pcm-s32be","pcm-f32","pcm-f32be","pcm-f64","pcm-f64be","pcm-u8","pcm-s8","ulaw","alaw"],ar=["aac","opus","mp3","vorbis","flac"],Ke=[...ar,...ye],Er=["webvtt"],Yn=[{maxMacroblocks:99,maxBitrate:64e3,level:10},{maxMacroblocks:396,maxBitrate:192e3,level:11},{maxMacroblocks:396,maxBitrate:384e3,level:12},{maxMacroblocks:396,maxBitrate:768e3,level:13},{maxMacroblocks:396,maxBitrate:2e6,level:20},{maxMacroblocks:792,maxBitrate:4e6,level:21},{maxMacroblocks:1620,maxBitrate:4e6,level:22},{maxMacroblocks:1620,maxBitrate:1e7,level:30},{maxMacroblocks:3600,maxBitrate:14e6,level:31},{maxMacroblocks:5120,maxBitrate:2e7,level:32},{maxMacroblocks:8192,maxBitrate:2e7,level:40},{maxMacroblocks:8192,maxBitrate:5e7,level:41},{maxMacroblocks:8704,maxBitrate:5e7,level:42},{maxMacroblocks:22080,maxBitrate:135e6,level:50},{maxMacroblocks:36864,maxBitrate:24e7,level:51},{maxMacroblocks:36864,maxBitrate:24e7,level:52},{maxMacroblocks:139264,maxBitrate:24e7,level:60},{maxMacroblocks:139264,maxBitrate:48e7,level:61},{maxMacroblocks:139264,maxBitrate:8e8,level:62}],Zn=[{maxPictureSize:36864,maxBitrate:128e3,tier:"L",level:30},{maxPictureSize:122880,maxBitrate:15e5,tier:"L",level:60},{maxPictureSize:245760,maxBitrate:3e6,tier:"L",level:63},{maxPictureSize:552960,maxBitrate:6e6,tier:"L",level:90},{maxPictureSize:983040,maxBitrate:1e7,tier:"L",level:93},{maxPictureSize:2228224,maxBitrate:12e6,tier:"L",level:120},{maxPictureSize:2228224,maxBitrate:3e7,tier:"H",level:120},{maxPictureSize:2228224,maxBitrate:2e7,tier:"L",level:123},{maxPictureSize:2228224,maxBitrate:5e7,tier:"H",level:123},{maxPictureSize:8912896,maxBitrate:25e6,tier:"L",level:150},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:150},{maxPictureSize:8912896,maxBitrate:4e7,tier:"L",level:153},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:153},{maxPictureSize:8912896,maxBitrate:6e7,tier:"L",level:156},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:156},{maxPictureSize:35651584,maxBitrate:6e7,tier:"L",level:180},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:180},{maxPictureSize:35651584,maxBitrate:12e7,tier:"L",level:183},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:183},{maxPictureSize:35651584,maxBitrate:24e7,tier:"L",level:186},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:186}],ft=[{maxPictureSize:36864,maxBitrate:2e5,level:10},{maxPictureSize:73728,maxBitrate:8e5,level:11},{maxPictureSize:122880,maxBitrate:18e5,level:20},{maxPictureSize:245760,maxBitrate:36e5,level:21},{maxPictureSize:552960,maxBitrate:72e5,level:30},{maxPictureSize:983040,maxBitrate:12e6,level:31},{maxPictureSize:2228224,maxBitrate:18e6,level:40},{maxPictureSize:2228224,maxBitrate:3e7,level:41},{maxPictureSize:8912896,maxBitrate:6e7,level:50},{maxPictureSize:8912896,maxBitrate:12e7,level:51},{maxPictureSize:8912896,maxBitrate:18e7,level:52},{maxPictureSize:35651584,maxBitrate:18e7,level:60},{maxPictureSize:35651584,maxBitrate:24e7,level:61},{maxPictureSize:35651584,maxBitrate:48e7,level:62}],Jn=[{maxPictureSize:147456,maxBitrate:15e5,tier:"M",level:0},{maxPictureSize:278784,maxBitrate:3e6,tier:"M",level:1},{maxPictureSize:665856,maxBitrate:6e6,tier:"M",level:4},{maxPictureSize:1065024,maxBitrate:1e7,tier:"M",level:5},{maxPictureSize:2359296,maxBitrate:12e6,tier:"M",level:8},{maxPictureSize:2359296,maxBitrate:3e7,tier:"H",level:8},{maxPictureSize:2359296,maxBitrate:2e7,tier:"M",level:9},{maxPictureSize:2359296,maxBitrate:5e7,tier:"H",level:9},{maxPictureSize:8912896,maxBitrate:3e7,tier:"M",level:12},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:12},{maxPictureSize:8912896,maxBitrate:4e7,tier:"M",level:13},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:13},{maxPictureSize:8912896,maxBitrate:6e7,tier:"M",level:14},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:14},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:15},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:15},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:16},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:16},{maxPictureSize:35651584,maxBitrate:1e8,tier:"M",level:17},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:17},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:18},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:18},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:19},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:19}],ei=".01.01.01.01.00",ti=".0.110.01.01.01.0",Gs=(t,e,r,n)=>{if(t==="avc"){const s=Math.ceil(e/16)*Math.ceil(r/16),a=Yn.find(d=>s<=d.maxMacroblocks&&n<=d.maxBitrate)??ue(Yn),o=a?a.level:0,c=100 .toString(16).padStart(2,"0"),l="00",u=o.toString(16).padStart(2,"0");return`avc1.${c}${l}${u}`}else if(t==="hevc"){const i="",a="6",o=e*r,c=Zn.find(u=>o<=u.maxPictureSize&&n<=u.maxBitrate)??ue(Zn),l="B0";return`hev1.${i}1.${a}.${c.tier}${c.level}.${l}`}else{if(t==="vp8")return"vp8";if(t==="vp9"){const i="00",s=e*r,a=ft.find(c=>s<=c.maxPictureSize&&n<=c.maxBitrate)??ue(ft),o="08";return`vp09.${i}.${a.level.toString().padStart(2,"0")}.${o}`}else if(t==="av1"){const s=e*r,a=Jn.find(l=>s<=l.maxPictureSize&&n<=l.maxBitrate)??ue(Jn),o=a.level.toString().padStart(2,"0"),c="08";return`av01.0.${o}${a.tier}.${c}`}}throw new TypeError(`Unhandled codec '${t}'.`)},Xs=t=>{const e=t.split("."),r=1,n=1,i=(r<<7)+n,s=Number(e[1]),a=e[2],o=Number(a.slice(0,-1)),c=(s<<5)+o,l=a.slice(-1)==="H"?1:0,d=Number(e[3])===8?0:1,p=0,g=e[4]?Number(e[4]):0,w=e[5]?Number(e[5][0]):1,m=e[5]?Number(e[5][1]):1,k=e[5]?Number(e[5][2]):0,T=(l<<7)+(d<<6)+(p<<5)+(g<<4)+(w<<3)+(m<<2)+k;return[i,c,T,0]},Oi=t=>{const{codec:e,codecDescription:r,colorSpace:n,avcCodecInfo:i,hevcCodecInfo:s,vp9CodecInfo:a,av1CodecInfo:o}=t;if(e==="avc"){if(i){const c=new Uint8Array([i.avcProfileIndication,i.profileCompatibility,i.avcLevelIndication]);return`avc1.${$n(c)}`}if(!r||r.byteLength<4)throw new TypeError("AVC decoder description is not provided or is not at least 4 bytes long.");return`avc1.${$n(r.subarray(1,4))}`}else if(e==="hevc"){let c,l,u,d,p,g;if(s)c=s.generalProfileSpace,l=s.generalProfileIdc,u=jn(s.generalProfileCompatibilityFlags),d=s.generalTierFlag,p=s.generalLevelIdc,g=[...s.generalConstraintIndicatorFlags];else{if(!r||r.byteLength<23)throw new TypeError("HEVC decoder description is not provided or is not at least 23 bytes long.");const m=Te(r),k=m.getUint8(1);c=k>>6&3,l=k&31,u=jn(m.getUint32(2)),d=k>>5&1,p=m.getUint8(12),g=[];for(let T=0;T<6;T++)g.push(m.getUint8(6+T))}let w="hev1.";for(w+=["","A","B","C"][c]+l,w+=".",w+=u.toString(16).toUpperCase(),w+=".",w+=d===0?"L":"H",w+=p;g.length>0&&g[g.length-1]===0;)g.pop();return g.length>0&&(w+=".",w+=g.map(m=>m.toString(16).toUpperCase()).join(".")),w}else{if(e==="vp8")return"vp8";if(e==="vp9"){if(!a){const T=t.width*t.height;let b=ue(ft).level;for(const y of ft)if(T<=y.maxPictureSize){b=y.level;break}return`vp09.00.${b.toString().padStart(2,"0")}.08`}const c=a.profile.toString().padStart(2,"0"),l=a.level.toString().padStart(2,"0"),u=a.bitDepth.toString().padStart(2,"0"),d=a.chromaSubsampling.toString().padStart(2,"0"),p=a.colourPrimaries.toString().padStart(2,"0"),g=a.transferCharacteristics.toString().padStart(2,"0"),w=a.matrixCoefficients.toString().padStart(2,"0"),m=a.videoFullRangeFlag.toString().padStart(2,"0");let k=`vp09.${c}.${l}.${u}.${d}`;return k+=`.${p}.${g}.${w}.${m}`,k.endsWith(ei)&&(k=k.slice(0,-ei.length)),k}else if(e==="av1"){if(!o){const y=t.width*t.height;let S=ue(ft).level;for(const x of ft)if(y<=x.maxPictureSize){S=x.level;break}return`av01.0.${S.toString().padStart(2,"0")}M.08`}const c=o.profile,l=o.level.toString().padStart(2,"0"),u=o.tier?"H":"M",d=o.bitDepth.toString().padStart(2,"0"),p=o.monochrome?"1":"0",g=100*o.chromaSubsamplingX+10*o.chromaSubsamplingY+1*(o.chromaSubsamplingX&&o.chromaSubsamplingY?o.chromaSamplePosition:0),w=n!=null&&n.primaries?mr[n.primaries]:1,m=n!=null&&n.transfer?pr[n.transfer]:1,k=n!=null&&n.matrix?gr[n.matrix]:1,T=n!=null&&n.fullRange?1:0;let b=`av01.${c}.${l}${u}.${d}`;return b+=`.${p}.${g.toString().padStart(3,"0")}`,b+=`.${w.toString().padStart(2,"0")}`,b+=`.${m.toString().padStart(2,"0")}`,b+=`.${k.toString().padStart(2,"0")}`,b+=`.${T}`,b.endsWith(ti)&&(b=b.slice(0,-ti.length)),b}}throw new TypeError(`Unhandled codec '${e}'.`)},Ys=(t,e,r)=>{if(t==="aac")return e>=2&&r<=24e3?"mp4a.40.29":r<=24e3?"mp4a.40.5":"mp4a.40.2";if(t==="mp3")return"mp3";if(t==="opus")return"opus";if(t==="vorbis")return"vorbis";if(t==="flac")return"flac";if(ye.includes(t))return t;throw new TypeError(`Unhandled codec '${t}'.`)},Vi=t=>{const{codec:e,codecDescription:r,aacCodecInfo:n}=t;if(e==="aac"){if(!n)throw new TypeError("AAC codec info must be provided.");return n.isMpeg2?"mp4a.67":`mp4a.40.${Wi(r).objectType}`}else{if(e==="mp3")return"mp3";if(e==="opus")return"opus";if(e==="vorbis")return"vorbis";if(e==="flac")return"flac";if(e&&ye.includes(e))return e}throw new TypeError(`Unhandled codec '${e}'.`)},Ir=[96e3,88200,64e3,48e3,44100,32e3,24e3,22050,16e3,12e3,11025,8e3,7350],Ui=[-1,1,2,3,4,5,6,8],Wi=t=>{if(!t||t.byteLength<2)throw new TypeError("AAC description must be at least 2 bytes long.");const e=new de(t);let r=e.readBits(5);r===31&&(r=32+e.readBits(6));const n=e.readBits(4);let i=null;n===15?i=e.readBits(24):n<Ir.length&&(i=Ir[n]);const s=e.readBits(4);let a=null;return s>=1&&s<=7&&(a=Ui[s]),{objectType:r,frequencyIndex:n,sampleRate:i,channelConfiguration:s,numberOfChannels:a}},Vr=48e3,Li=/^pcm-([usf])(\d+)+(be)?$/,kt=t=>{if(h(ye.includes(t)),t==="ulaw")return{dataType:"ulaw",sampleSize:1,littleEndian:!0,silentValue:255};if(t==="alaw")return{dataType:"alaw",sampleSize:1,littleEndian:!0,silentValue:213};const e=Li.exec(t);h(e);let r;e[1]==="u"?r="unsigned":e[1]==="s"?r="signed":r="float";const n=Number(e[2])/8,i=e[3]!=="be",s=t==="pcm-u8"?2**7:0;return{dataType:r,sampleSize:n,littleEndian:i,silentValue:s}},Hi=t=>t.startsWith("avc1")||t.startsWith("avc3")?"avc":t.startsWith("hev1")||t.startsWith("hvc1")?"hevc":t==="vp8"?"vp8":t.startsWith("vp09")?"vp9":t.startsWith("av01")?"av1":t.startsWith("mp4a.40")||t==="mp4a.67"?"aac":t==="mp3"||t==="mp4a.69"||t==="mp4a.6B"||t==="mp4a.6b"?"mp3":t==="opus"?"opus":t==="vorbis"?"vorbis":t==="flac"?"flac":t==="ulaw"?"ulaw":t==="alaw"?"alaw":Li.test(t)?t:t==="webvtt"?"webvtt":null,Zs=t=>t==="avc"?{avc:{format:"avc"}}:t==="hevc"?{hevc:{format:"hevc"}}:{},Js=t=>t==="aac"?{aac:{format:"aac"}}:t==="opus"?{opus:{format:"opus"}}:{},ea=["avc1","avc3","hev1","hvc1","vp8","vp09","av01"],ta=/^(avc1|avc3)\.[0-9a-fA-F]{6}$/,ra=/^(hev1|hvc1)\.(?:[ABC]?\d+)\.[0-9a-fA-F]{1,8}\.[LH]\d+(?:\.[0-9a-fA-F]{1,2}){0,6}$/,na=/^vp09(?:\.\d{2}){3}(?:(?:\.\d{2}){5})?$/,ia=/^av01\.\d\.\d{2}[MH]\.\d{2}(?:\.\d\.\d{3}\.\d{2}\.\d{2}\.\d{2}\.\d)?$/,sa=t=>{if(!t)throw new TypeError("Video chunk metadata must be provided.");if(typeof t!="object")throw new TypeError("Video chunk metadata must be an object.");if(!t.decoderConfig)throw new TypeError("Video chunk metadata must include a decoder configuration.");if(typeof t.decoderConfig!="object")throw new TypeError("Video chunk metadata decoder configuration must be an object.");if(typeof t.decoderConfig.codec!="string")throw new TypeError("Video chunk metadata decoder configuration must specify a codec string.");if(!ea.some(e=>t.decoderConfig.codec.startsWith(e)))throw new TypeError("Video chunk metadata decoder configuration codec string must be a valid video codec string as specified in the WebCodecs Codec Registry.");if(!Number.isInteger(t.decoderConfig.codedWidth)||t.decoderConfig.codedWidth<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedWidth (positive integer).");if(!Number.isInteger(t.decoderConfig.codedHeight)||t.decoderConfig.codedHeight<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedHeight (positive integer).");if(t.decoderConfig.description!==void 0&&!Mr(t.decoderConfig.description))throw new TypeError("Video chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(t.decoderConfig.colorSpace!==void 0){const{colorSpace:e}=t.decoderConfig;if(typeof e!="object")throw new TypeError("Video chunk metadata decoder configuration colorSpace, when provided, must be an object.");const r=Object.keys(mr);if(e.primaries!=null&&!r.includes(e.primaries))throw new TypeError(`Video chunk metadata decoder configuration colorSpace primaries, when defined, must be one of ${r.join(", ")}.`);const n=Object.keys(pr);if(e.transfer!=null&&!n.includes(e.transfer))throw new TypeError(`Video chunk metadata decoder configuration colorSpace transfer, when defined, must be one of ${n.join(", ")}.`);const i=Object.keys(gr);if(e.matrix!=null&&!i.includes(e.matrix))throw new TypeError(`Video chunk metadata decoder configuration colorSpace matrix, when defined, must be one of ${i.join(", ")}.`);if(e.fullRange!=null&&typeof e.fullRange!="boolean")throw new TypeError("Video chunk metadata decoder configuration colorSpace fullRange, when defined, must be a boolean.")}if(t.decoderConfig.codec.startsWith("avc1")||t.decoderConfig.codec.startsWith("avc3")){if(!ta.test(t.decoderConfig.codec))throw new TypeError("Video chunk metadata decoder configuration codec string for AVC must be a valid AVC codec string as specified in Section 3.4 of RFC 6381.")}else if(t.decoderConfig.codec.startsWith("hev1")||t.decoderConfig.codec.startsWith("hvc1")){if(!ra.test(t.decoderConfig.codec))throw new TypeError("Video chunk metadata decoder configuration codec string for HEVC must be a valid HEVC codec string as specified in Section E.3 of ISO 14496-15.")}else if(t.decoderConfig.codec.startsWith("vp8")){if(t.decoderConfig.codec!=="vp8")throw new TypeError('Video chunk metadata decoder configuration codec string for VP8 must be "vp8".')}else if(t.decoderConfig.codec.startsWith("vp09")){if(!na.test(t.decoderConfig.codec))throw new TypeError('Video chunk metadata decoder configuration codec string for VP9 must be a valid VP9 codec string as specified in Section "Codecs Parameter String" of https://www.webmproject.org/vp9/mp4/.')}else if(t.decoderConfig.codec.startsWith("av01")&&!ia.test(t.decoderConfig.codec))throw new TypeError('Video chunk metadata decoder configuration codec string for AV1 must be a valid AV1 codec string as specified in Section "Codecs Parameter String" of https://aomediacodec.github.io/av1-isobmff/.')},aa=["mp4a","mp3","opus","vorbis","flac","ulaw","alaw","pcm"],oa=t=>{if(!t)throw new TypeError("Audio chunk metadata must be provided.");if(typeof t!="object")throw new TypeError("Audio chunk metadata must be an object.");if(!t.decoderConfig)throw new TypeError("Audio chunk metadata must include a decoder configuration.");if(typeof t.decoderConfig!="object")throw new TypeError("Audio chunk metadata decoder configuration must be an object.");if(typeof t.decoderConfig.codec!="string")throw new TypeError("Audio chunk metadata decoder configuration must specify a codec string.");if(!aa.some(e=>t.decoderConfig.codec.startsWith(e)))throw new TypeError("Audio chunk metadata decoder configuration codec string must be a valid audio codec string as specified in the WebCodecs Codec Registry.");if(!Number.isInteger(t.decoderConfig.sampleRate)||t.decoderConfig.sampleRate<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid sampleRate (positive integer).");if(!Number.isInteger(t.decoderConfig.numberOfChannels)||t.decoderConfig.numberOfChannels<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid numberOfChannels (positive integer).");if(t.decoderConfig.description!==void 0&&!Mr(t.decoderConfig.description))throw new TypeError("Audio chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(t.decoderConfig.codec.startsWith("mp4a")&&t.decoderConfig.codec!=="mp4a.69"&&t.decoderConfig.codec!=="mp4a.6B"&&t.decoderConfig.codec!=="mp4a.6b"){if(!["mp4a.40.2","mp4a.40.02","mp4a.40.5","mp4a.40.05","mp4a.40.29","mp4a.67"].includes(t.decoderConfig.codec))throw new TypeError("Audio chunk metadata decoder configuration codec string for AAC must be a valid AAC codec string as specified in https://www.w3.org/TR/webcodecs-aac-codec-registration/.");if(!t.decoderConfig.description)throw new TypeError("Audio chunk metadata decoder configuration for AAC must include a description, which is expected to be an AudioSpecificConfig as specified in ISO 14496-3.")}else if(t.decoderConfig.codec.startsWith("mp3")||t.decoderConfig.codec.startsWith("mp4a")){if(t.decoderConfig.codec!=="mp3"&&t.decoderConfig.codec!=="mp4a.69"&&t.decoderConfig.codec!=="mp4a.6B"&&t.decoderConfig.codec!=="mp4a.6b")throw new TypeError('Audio chunk metadata decoder configuration codec string for MP3 must be "mp3", "mp4a.69" or "mp4a.6B".')}else if(t.decoderConfig.codec.startsWith("opus")){if(t.decoderConfig.codec!=="opus")throw new TypeError('Audio chunk metadata decoder configuration codec string for Opus must be "opus".');if(t.decoderConfig.description&&t.decoderConfig.description.byteLength<18)throw new TypeError("Audio chunk metadata decoder configuration description, when specified, is expected to be an Identification Header as specified in Section 5.1 of RFC 7845.")}else if(t.decoderConfig.codec.startsWith("vorbis")){if(t.decoderConfig.codec!=="vorbis")throw new TypeError('Audio chunk metadata decoder configuration codec string for Vorbis must be "vorbis".');if(!t.decoderConfig.description)throw new TypeError("Audio chunk metadata decoder configuration for Vorbis must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-vorbis-codec-registration/.")}else if(t.decoderConfig.codec.startsWith("flac")){if(t.decoderConfig.codec!=="flac")throw new TypeError('Audio chunk metadata decoder configuration codec string for FLAC must be "flac".');const e=4+4+34;if(!t.decoderConfig.description||t.decoderConfig.description.byteLength<e)throw new TypeError("Audio chunk metadata decoder configuration for FLAC must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-flac-codec-registration/.")}else if((t.decoderConfig.codec.startsWith("pcm")||t.decoderConfig.codec.startsWith("ulaw")||t.decoderConfig.codec.startsWith("alaw"))&&!ye.includes(t.decoderConfig.codec))throw new TypeError(`Audio chunk metadata decoder configuration codec string for PCM must be one of the supported PCM codecs (${ye.join(", ")}).`)},ca=t=>{if(!t)throw new TypeError("Subtitle metadata must be provided.");if(typeof t!="object")throw new TypeError("Subtitle metadata must be an object.");if(!t.config)throw new TypeError("Subtitle metadata must include a config object.");if(typeof t.config!="object")throw new TypeError("Subtitle metadata config must be an object.");if(typeof t.config.description!="string")throw new TypeError("Subtitle metadata config description must be a string.")};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class la{constructor(e){this.mutex=new wt,this.firstMediaStreamTimestamp=null,this.trackTimestampInfo=new WeakMap,this.output=e}onTrackClose(e){}validateAndNormalizeTimestamp(e,r,n){r+=e.source._timestampOffset;let i=this.trackTimestampInfo.get(e);if(!i){if(!n)throw new Error("First frame must be a key frame.");i={maxTimestamp:r,maxTimestampBeforeLastKeyFrame:r},this.trackTimestampInfo.set(e,i)}if(r<0)throw new Error(`Timestamps must be non-negative (got ${r}s).`);if(n&&(i.maxTimestampBeforeLastKeyFrame=i.maxTimestamp),r<i.maxTimestampBeforeLastKeyFrame)throw new Error(`Timestamps cannot be smaller than the highest timestamp of the previous GOP (a GOP begins with a key frame and ends right before the next key frame). Got ${r}s, but highest timestamp is ${i.maxTimestampBeforeLastKeyFrame}s.`);return i.maxTimestamp=Math.max(i.maxTimestamp,r),r}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */var Wt;(function(t){t[t.IDR=5]="IDR",t[t.SPS=7]="SPS",t[t.PPS=8]="PPS",t[t.SPS_EXT=13]="SPS_EXT"})(Wt||(Wt={}));var Se;(function(t){t[t.RASL_N=8]="RASL_N",t[t.RASL_R=9]="RASL_R",t[t.BLA_W_LP=16]="BLA_W_LP",t[t.RSV_IRAP_VCL23=23]="RSV_IRAP_VCL23",t[t.VPS_NUT=32]="VPS_NUT",t[t.SPS_NUT=33]="SPS_NUT",t[t.PPS_NUT=34]="PPS_NUT",t[t.PREFIX_SEI_NUT=39]="PREFIX_SEI_NUT",t[t.SUFFIX_SEI_NUT=40]="SUFFIX_SEI_NUT"})(Se||(Se={}));const br=t=>{const e=[];let r=0;for(;r<t.length;){let n=-1,i=0;for(let s=r;s<t.length-3;s++){if(t[s]===0&&t[s+1]===0&&t[s+2]===1){n=s,i=3;break}if(s<t.length-4&&t[s]===0&&t[s+1]===0&&t[s+2]===0&&t[s+3]===1){n=s,i=4;break}}if(n===-1)break;if(r>0&&n>r){const s=t.subarray(r,n);s.length>0&&e.push(s)}r=n+i}if(r<t.length){const n=t.subarray(r);n.length>0&&e.push(n)}return e},qi=(t,e)=>{const r=[];let n=0;const i=new DataView(t.buffer,t.byteOffset,t.byteLength);for(;n+e<=t.length;){let s;e===1?s=i.getUint8(n):e===2?s=i.getUint16(n,!1):e===3?s=Nr(i,n,!1):e===4?s=i.getUint32(n,!1):(bt(e),h(!1)),n+=e;const a=t.subarray(n,n+s);r.push(a),n+=s}return r},ln=t=>{const e=[],r=t.length;for(let n=0;n<r;n++)n+2<r&&t[n]===0&&t[n+1]===0&&t[n+2]===3?(e.push(0,0),n+=2):e.push(t[n]);return new Uint8Array(e)},ua=t=>{const r=br(t);if(r.length===0)return null;let n=0;for(const o of r)n+=4+o.byteLength;const i=new Uint8Array(n),s=new DataView(i.buffer);let a=0;for(const o of r){const c=o.byteLength;s.setUint32(a,c,!1),a+=4,i.set(o,a),a+=o.byteLength}return i},da=(t,e)=>{if(e.description){const i=($e(e.description)[4]&3)+1;return qi(t,i)}else return br(t)},Pr=t=>t[0]&31,$i=t=>{try{const e=br(t),r=e.filter(p=>Pr(p)===Wt.SPS),n=e.filter(p=>Pr(p)===Wt.PPS),i=e.filter(p=>Pr(p)===Wt.SPS_EXT);if(r.length===0||n.length===0)return null;const s=r[0],a=new de(ln(s));if(a.skipBits(1),a.skipBits(2),a.readBits(5)!==7)return console.error("Invalid SPS NAL unit type"),null;const c=a.readAlignedByte(),l=a.readAlignedByte(),u=a.readAlignedByte(),d={configurationVersion:1,avcProfileIndication:c,profileCompatibility:l,avcLevelIndication:u,lengthSizeMinusOne:3,sequenceParameterSets:r,pictureParameterSets:n,chromaFormat:null,bitDepthLumaMinus8:null,bitDepthChromaMinus8:null,sequenceParameterSetExt:null};if(c===100||c===110||c===122||c===144){V(a);const p=V(a);p===3&&a.skipBits(1);const g=V(a),w=V(a);d.chromaFormat=p,d.bitDepthLumaMinus8=g,d.bitDepthChromaMinus8=w,d.sequenceParameterSetExt=i}return d}catch(e){return console.error("Error building AVC Decoder Configuration Record:",e),null}},ha=t=>{const e=[];e.push(t.configurationVersion),e.push(t.avcProfileIndication),e.push(t.profileCompatibility),e.push(t.avcLevelIndication),e.push(252|t.lengthSizeMinusOne&3),e.push(224|t.sequenceParameterSets.length&31);for(const r of t.sequenceParameterSets){const n=r.byteLength;e.push(n>>8),e.push(n&255);for(let i=0;i<n;i++)e.push(r[i])}e.push(t.pictureParameterSets.length);for(const r of t.pictureParameterSets){const n=r.byteLength;e.push(n>>8),e.push(n&255);for(let i=0;i<n;i++)e.push(r[i])}if(t.avcProfileIndication===100||t.avcProfileIndication===110||t.avcProfileIndication===122||t.avcProfileIndication===144){h(t.chromaFormat!==null),h(t.bitDepthLumaMinus8!==null),h(t.bitDepthChromaMinus8!==null),h(t.sequenceParameterSetExt!==null),e.push(252|t.chromaFormat&3),e.push(248|t.bitDepthLumaMinus8&7),e.push(248|t.bitDepthChromaMinus8&7),e.push(t.sequenceParameterSetExt.length);for(const r of t.sequenceParameterSetExt){const n=r.byteLength;e.push(n>>8),e.push(n&255);for(let i=0;i<n;i++)e.push(r[i])}}return new Uint8Array(e)},ji=(t,e)=>{if(e.description){const i=($e(e.description)[21]&3)+1;return qi(t,i)}else return br(t)},lt=t=>t[0]>>1&63,Ki=t=>{try{const e=br(t),r=e.filter(z=>lt(z)===Se.VPS_NUT),n=e.filter(z=>lt(z)===Se.SPS_NUT),i=e.filter(z=>lt(z)===Se.PPS_NUT),s=e.filter(z=>lt(z)===Se.PREFIX_SEI_NUT||lt(z)===Se.SUFFIX_SEI_NUT);if(n.length===0||i.length===0)return null;const a=n[0],o=new de(ln(a));o.skipBits(16),o.readBits(4);const c=o.readBits(3),l=o.readBits(1),{general_profile_space:u,general_tier_flag:d,general_profile_idc:p,general_profile_compatibility_flags:g,general_constraint_indicator_flags:w,general_level_idc:m}=fa(o,c);V(o);const k=V(o);k===3&&o.skipBits(1),V(o),V(o),o.readBits(1)&&(V(o),V(o),V(o),V(o));const T=V(o),b=V(o);V(o);const S=o.readBits(1)?0:c;for(let z=S;z<=c;z++)V(o),V(o),V(o);V(o),V(o),V(o),V(o),V(o),V(o),o.readBits(1)&&o.readBits(1)&&ma(o),o.skipBits(1),o.skipBits(1),o.readBits(1)&&(o.skipBits(4),o.skipBits(4),V(o),V(o),o.skipBits(1));const x=V(o);if(pa(o,x),o.readBits(1)){const z=V(o);for(let O=0;O<z;O++)V(o),o.skipBits(1)}o.skipBits(1),o.skipBits(1);let _=0;o.readBits(1)&&(_=ba(o,c));let P=0;if(i.length>0){const z=i[0],O=new de(ln(z));O.skipBits(16),V(O),V(O),O.skipBits(1),O.skipBits(1),O.skipBits(3),O.skipBits(1),O.skipBits(1),V(O),V(O),sr(O),O.skipBits(1),O.skipBits(1),O.readBits(1)&&V(O),sr(O),sr(O),O.skipBits(1),O.skipBits(1),O.skipBits(1),O.skipBits(1);const L=O.readBits(1),X=O.readBits(1);!L&&!X?P=0:L&&!X?P=2:!L&&X?P=3:P=0}const M=[...r.length?[{arrayCompleteness:1,nalUnitType:Se.VPS_NUT,nalUnits:r}]:[],...n.length?[{arrayCompleteness:1,nalUnitType:Se.SPS_NUT,nalUnits:n}]:[],...i.length?[{arrayCompleteness:1,nalUnitType:Se.PPS_NUT,nalUnits:i}]:[],...s.length?[{arrayCompleteness:1,nalUnitType:lt(s[0]),nalUnits:s}]:[]];return{configurationVersion:1,generalProfileSpace:u,generalTierFlag:d,generalProfileIdc:p,generalProfileCompatibilityFlags:g,generalConstraintIndicatorFlags:w,generalLevelIdc:m,minSpatialSegmentationIdc:_,parallelismType:P,chromaFormatIdc:k,bitDepthLumaMinus8:T,bitDepthChromaMinus8:b,avgFrameRate:0,constantFrameRate:0,numTemporalLayers:c+1,temporalIdNested:l,lengthSizeMinusOne:3,arrays:M}}catch(e){return console.error("Error building HEVC Decoder Configuration Record:",e),null}},fa=(t,e)=>{const r=t.readBits(2),n=t.readBits(1),i=t.readBits(5);let s=0;for(let u=0;u<32;u++)s=s<<1|t.readBits(1);const a=new Uint8Array(6);for(let u=0;u<6;u++)a[u]=t.readBits(8);const o=t.readBits(8),c=[],l=[];for(let u=0;u<e;u++)c.push(t.readBits(1)),l.push(t.readBits(1));if(e>0)for(let u=e;u<8;u++)t.skipBits(2);for(let u=0;u<e;u++)c[u]&&t.skipBits(88),l[u]&&t.skipBits(8);return{general_profile_space:r,general_tier_flag:n,general_profile_idc:i,general_profile_compatibility_flags:s,general_constraint_indicator_flags:a,general_level_idc:o}},ma=t=>{for(let e=0;e<4;e++)for(let r=0;r<(e===3?2:6);r++)if(!t.readBits(1))V(t);else{const i=Math.min(64,1<<4+(e<<1));e>1&&sr(t);for(let s=0;s<i;s++)sr(t)}},pa=(t,e)=>{const r=[];for(let n=0;n<e;n++)r[n]=ga(t,n,e,r)},ga=(t,e,r,n)=>{let i=0,s=0,a=0;if(e!==0&&(s=t.readBits(1)),s){if(e===r){const c=V(t);a=e-(c+1)}else a=e-1;t.readBits(1),V(t);const o=n[a]??0;for(let c=0;c<=o;c++)t.readBits(1)||t.readBits(1);i=n[a]}else{const o=V(t),c=V(t);for(let l=0;l<o;l++)V(t),t.readBits(1);for(let l=0;l<c;l++)V(t),t.readBits(1);i=o+c}return i},ba=(t,e)=>{if(t.readBits(1)&&t.readBits(8)===255&&(t.readBits(16),t.readBits(16)),t.readBits(1)&&t.readBits(1),t.readBits(1)&&(t.readBits(3),t.readBits(1),t.readBits(1)&&(t.readBits(8),t.readBits(8),t.readBits(8))),t.readBits(1)&&(V(t),V(t)),t.readBits(1),t.readBits(1),t.readBits(1),t.readBits(1)&&(V(t),V(t),V(t),V(t)),t.readBits(1)&&(t.readBits(32),t.readBits(32),t.readBits(1)&&V(t),t.readBits(1)&&wa(t,!0,e)),t.readBits(1)){t.readBits(1),t.readBits(1),t.readBits(1);const r=V(t);return V(t),V(t),V(t),V(t),r}return 0},wa=(t,e,r)=>{let n=!1,i=!1,s=!1;e&&(n=t.readBits(1)===1,i=t.readBits(1)===1,(n||i)&&(s=t.readBits(1)===1,s&&(t.readBits(8),t.readBits(5),t.readBits(1),t.readBits(5)),t.readBits(4),t.readBits(4),s&&t.readBits(4),t.readBits(5),t.readBits(5),t.readBits(5)));for(let a=0;a<=r;a++){const o=t.readBits(1)===1;let c=!0;o||(c=t.readBits(1)===1);let l=!1;c?V(t):l=t.readBits(1)===1;let u=1;l||(u=V(t)+1),n&&ri(t,u,s),i&&ri(t,u,s)}},ri=(t,e,r)=>{for(let n=0;n<e;n++)V(t),V(t),r&&(V(t),V(t)),t.readBits(1)},ka=t=>{const e=[];e.push(t.configurationVersion),e.push((t.generalProfileSpace&3)<<6|(t.generalTierFlag&1)<<5|t.generalProfileIdc&31),e.push(t.generalProfileCompatibilityFlags>>>24&255),e.push(t.generalProfileCompatibilityFlags>>>16&255),e.push(t.generalProfileCompatibilityFlags>>>8&255),e.push(t.generalProfileCompatibilityFlags&255),e.push(...t.generalConstraintIndicatorFlags),e.push(t.generalLevelIdc&255),e.push(240|t.minSpatialSegmentationIdc>>8&15),e.push(t.minSpatialSegmentationIdc&255),e.push(252|t.parallelismType&3),e.push(252|t.chromaFormatIdc&3),e.push(248|t.bitDepthLumaMinus8&7),e.push(248|t.bitDepthChromaMinus8&7),e.push(t.avgFrameRate>>8&255),e.push(t.avgFrameRate&255),e.push((t.constantFrameRate&3)<<6|(t.numTemporalLayers&7)<<3|(t.temporalIdNested&1)<<2|t.lengthSizeMinusOne&3),e.push(t.arrays.length&255);for(const r of t.arrays){e.push((r.arrayCompleteness&1)<<7|0|r.nalUnitType&63),e.push(r.nalUnits.length>>8&255),e.push(r.nalUnits.length&255);for(const n of r.nalUnits){e.push(n.length>>8&255),e.push(n.length&255);for(let i=0;i<n.length;i++)e.push(n[i])}}return new Uint8Array(e)},Qi=t=>{const e=new de(t);if(e.readBits(2)!==2)return null;const n=e.readBits(1),s=(e.readBits(1)<<1)+n;if(s===3&&e.skipBits(1),e.readBits(1)===1||e.readBits(1)!==0||(e.skipBits(2),e.readBits(24)!==4817730))return null;let l=8;s>=2&&(l=e.readBits(1)?12:10);const u=e.readBits(3);let d=0,p=0;if(u!==7)if(p=e.readBits(1),s===1||s===3){const P=e.readBits(1),M=e.readBits(1);d=!P&&!M?3:P&&!M?2:1,e.skipBits(1)}else d=1;else d=3,p=1;const g=e.readBits(16),w=e.readBits(16),m=g+1,k=w+1,T=m*k;let b=ue(ft).level;for(const _ of ft)if(T<=_.maxPictureSize){b=_.level;break}return{profile:s,level:b,bitDepth:l,chromaSubsampling:d,videoFullRangeFlag:p,colourPrimaries:u===2?1:u===1?6:2,transferCharacteristics:u===2?1:u===1?6:2,matrixCoefficients:u===7?0:u===2?1:u===1?6:2}},Gi=function*(t){const e=new de(t),r=()=>{let n=0;for(let i=0;i<8;i++){const s=e.readAlignedByte();if(n|=(s&127)<<i*7,!(s&128))break;if(i===7&&s&128)return null}return n>=2**32-1?null:n};for(;e.getBitsLeft()>=8;){e.skipBits(1);const n=e.readBits(4),i=e.readBits(1),s=e.readBits(1);e.skipBits(1),i&&e.skipBits(8);let a;if(s){const o=r();if(o===null)return;a=o}else a=Math.floor(e.getBitsLeft()/8);h(e.pos%8===0),yield{type:n,data:t.subarray(e.pos/8,e.pos/8+a)},e.skipBits(a*8)}},Xi=t=>{for(const{type:e,data:r}of Gi(t)){if(e!==1)continue;const n=new de(r),i=n.readBits(3);n.readBits(1);const s=n.readBits(1);let a=0,o=0,c=0;if(s)a=n.readBits(5);else{if(n.readBits(1)&&(n.skipBits(32),n.skipBits(32),n.readBits(1)))return null;const k=n.readBits(1);k&&(c=n.readBits(5),n.skipBits(32),n.skipBits(5),n.skipBits(5));const T=n.readBits(5);for(let b=0;b<=T;b++){n.skipBits(12);const y=n.readBits(5);if(b===0&&(a=y),y>7){const x=n.readBits(1);b===0&&(o=x)}if(k&&n.readBits(1)){const _=c+1;n.skipBits(_),n.skipBits(_),n.skipBits(1)}n.readBits(1)&&n.skipBits(4)}}const l=n.readBits(1);let u=8;i===2&&l?u=n.readBits(1)?12:10:i<=2&&(u=l?10:8);let d=0;i!==1&&(d=n.readBits(1));let p=1,g=1,w=0;return d||(i===0?(p=1,g=1):i===1?(p=0,g=0):u===12&&(p=n.readBits(1),p&&(g=n.readBits(1))),p&&g&&(w=n.readBits(2))),{profile:i,level:a,tier:o,bitDepth:u,monochrome:d,chromaSubsamplingX:p,chromaSubsamplingY:g,chromaSamplePosition:w}}return null},Yi=t=>{const e=Te(t),r=e.getUint8(9),n=e.getUint16(10,!0),i=e.getUint32(12,!0),s=e.getInt16(16,!0),a=e.getUint8(18);let o=null;return a&&(o=t.subarray(19,19+2+r)),{outputChannelCount:r,preSkip:n,inputSampleRate:i,outputGain:s,channelMappingFamily:a,channelMappingTable:o}},Ta=[480,960,1920,2880,480,960,1920,2880,480,960,1920,2880,480,960,480,960,120,240,480,960,120,240,480,960,120,240,480,960,120,240,480,960],ya=t=>{const e=t[0]>>3;return{durationInSamples:Ta[e]}},Sa=t=>{if(t.length<7)throw new Error("Setup header is too short.");if(t[0]!==5)throw new Error("Wrong packet type in Setup header.");if(String.fromCharCode(...t.slice(1,7))!=="vorbis")throw new Error("Invalid packet signature in Setup header.");const r=t.length,n=new Uint8Array(r);for(let d=0;d<r;d++)n[d]=t[r-1-d];const i=new de(n);let s=0;for(;i.getBitsLeft()>97;)if(i.readBits(1)===1){s=i.pos;break}if(s===0)throw new Error("Invalid Setup header: framing bit not found.");let a=0,o=!1,c=0;for(;i.getBitsLeft()>=97;){const d=i.pos,p=i.readBits(8),g=i.readBits(16),w=i.readBits(16);if(p>63||g!==0||w!==0){i.pos=d;break}if(i.skipBits(1),a++,a>64)break;i.clone().readBits(6)+1===a&&(o=!0,c=a)}if(!o)throw new Error("Invalid Setup header: mode header not found.");if(c>63)throw new Error(`Unsupported mode count: ${c}.`);const l=c;i.pos=0,i.skipBits(s);const u=Array(l).fill(0);for(let d=l-1;d>=0;d--)i.skipBits(40),u[d]=i.readBits(1);return{modeBlockflags:u}},Zi=(t,e,r)=>{switch(t){case"avc":return da(r,e).some(s=>Pr(s)===Wt.IDR)?"key":"delta";case"hevc":return ji(r,e).some(s=>{const a=lt(s);return Se.BLA_W_LP<=a&&a<=Se.RSV_IRAP_VCL23})?"key":"delta";case"vp8":return(r[0]&1)===0?"key":"delta";case"vp9":{const n=new de(r);if(n.readBits(2)!==2)return null;const i=n.readBits(1);return(n.readBits(1)<<1)+i===3&&n.skipBits(1),n.readBits(1)?null:n.readBits(1)===0?"key":"delta"}case"av1":{let n=!1;for(const{type:i,data:s}of Gi(r))if(i===1){const a=new de(s);a.skipBits(4),n=!!a.readBits(1)}else if(i===3||i===6||i===7){if(n)return"key";const a=new de(s);return a.readBits(1)?null:a.readBits(2)===0?"key":"delta"}return null}default:bt(t),h(!1)}};var Lt;(function(t){t[t.STREAMINFO=0]="STREAMINFO",t[t.VORBIS_COMMENT=4]="VORBIS_COMMENT",t[t.PICTURE=6]="PICTURE"})(Lt||(Lt={}));const un=(t,e)=>{var o,c;const r=Te(t);let n=0;const i=r.getUint32(n,!0);n+=4;const s=Be.decode(t.subarray(n,n+i));n+=i,i>0&&(e.raw??(e.raw={}),(o=e.raw).vendor??(o.vendor=s));const a=r.getUint32(n,!0);n+=4;for(let l=0;l<a;l++){const u=r.getUint32(n,!0);n+=4;const d=Be.decode(t.subarray(n,n+u));n+=u;const p=d.indexOf("=");if(p===-1)continue;const g=d.slice(0,p).toUpperCase(),w=d.slice(p+1);switch(e.raw??(e.raw={}),(c=e.raw)[g]??(c[g]=w),g){case"TITLE":e.title??(e.title=w);break;case"DESCRIPTION":e.description??(e.description=w);break;case"ARTIST":e.artist??(e.artist=w);break;case"ALBUM":e.album??(e.album=w);break;case"ALBUMARTIST":e.albumArtist??(e.albumArtist=w);break;case"COMMENT":e.comment??(e.comment=w);break;case"LYRICS":e.lyrics??(e.lyrics=w);break;case"TRACKNUMBER":{const m=w.split("/"),k=Number.parseInt(m[0],10),T=m[1]&&Number.parseInt(m[1],10);Number.isInteger(k)&&k>0&&(e.trackNumber??(e.trackNumber=k)),T&&Number.isInteger(T)&&T>0&&(e.tracksTotal??(e.tracksTotal=T))}break;case"TRACKTOTAL":{const m=Number.parseInt(w,10);Number.isInteger(m)&&m>0&&(e.tracksTotal??(e.tracksTotal=m))}break;case"DISCNUMBER":{const m=w.split("/"),k=Number.parseInt(m[0],10),T=m[1]&&Number.parseInt(m[1],10);Number.isInteger(k)&&k>0&&(e.discNumber??(e.discNumber=k)),T&&Number.isInteger(T)&&T>0&&(e.discsTotal??(e.discsTotal=T))}break;case"DISCTOTAL":{const m=Number.parseInt(w,10);Number.isInteger(m)&&m>0&&(e.discsTotal??(e.discsTotal=m))}break;case"DATE":{const m=new Date(w);Number.isNaN(m.getTime())||(e.date??(e.date=m))}break;case"GENRE":e.genre??(e.genre=w);break;case"METADATA_BLOCK_PICTURE":{const m=Qs(w),k=Te(m),T=k.getUint32(0,!1),b=k.getUint32(4,!1),y=String.fromCharCode(...m.subarray(8,8+b)),S=k.getUint32(8+b,!1),x=Be.decode(m.subarray(12+b,12+b+S)),_=k.getUint32(b+S+28),P=m.subarray(b+S+32,b+S+32+_);e.images??(e.images=[]),e.images.push({data:P,mimeType:y,kind:T===3?"coverFront":T===4?"coverBack":"unknown",name:void 0,description:x||void 0})}break}}};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class _t{constructor(e){this.input=e}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Ji=[],es=[],dn=[],hn=[];/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const ze=new Uint8Array(0);class ie{constructor(e,r,n,i,s=-1,a,o){if(this.data=e,this.type=r,this.timestamp=n,this.duration=i,this.sequenceNumber=s,e===ze&&a===void 0)throw new Error("Internal error: byteLength must be explicitly provided when constructing metadata-only packets.");if(a===void 0&&(a=e.byteLength),!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if(r!=="key"&&r!=="delta")throw new TypeError('type must be either "key" or "delta".');if(!Number.isFinite(n))throw new TypeError("timestamp must be a number.");if(!Number.isFinite(i)||i<0)throw new TypeError("duration must be a non-negative number.");if(!Number.isFinite(s))throw new TypeError("sequenceNumber must be a number.");if(!Number.isInteger(a)||a<0)throw new TypeError("byteLength must be a non-negative integer.");if(o!==void 0&&(typeof o!="object"||!o))throw new TypeError("sideData, when provided, must be an object.");if((o==null?void 0:o.alpha)!==void 0&&!(o.alpha instanceof Uint8Array))throw new TypeError("sideData.alpha, when provided, must be a Uint8Array.");if((o==null?void 0:o.alphaByteLength)!==void 0&&(!Number.isInteger(o.alphaByteLength)||o.alphaByteLength<0))throw new TypeError("sideData.alphaByteLength, when provided, must be a non-negative integer.");this.byteLength=a,this.sideData=o??{},this.sideData.alpha&&this.sideData.alphaByteLength===void 0&&(this.sideData.alphaByteLength=this.sideData.alpha.byteLength)}get isMetadataOnly(){return this.data===ze}get microsecondTimestamp(){return Math.trunc(ht*this.timestamp)}get microsecondDuration(){return Math.trunc(ht*this.duration)}toEncodedVideoChunk(){if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to a video chunk.");if(typeof EncodedVideoChunk>"u")throw new Error("Your browser does not support EncodedVideoChunk.");return new EncodedVideoChunk({data:this.data,type:this.type,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}alphaToEncodedVideoChunk(e=this.type){if(!this.sideData.alpha)throw new TypeError("This packet does not contain alpha side data.");if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to a video chunk.");if(typeof EncodedVideoChunk>"u")throw new Error("Your browser does not support EncodedVideoChunk.");return new EncodedVideoChunk({data:this.sideData.alpha,type:e,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}toEncodedAudioChunk(){if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to an audio chunk.");if(typeof EncodedAudioChunk>"u")throw new Error("Your browser does not support EncodedAudioChunk.");return new EncodedAudioChunk({data:this.data,type:this.type,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}static fromEncodedChunk(e,r){if(!(e instanceof EncodedVideoChunk||e instanceof EncodedAudioChunk))throw new TypeError("chunk must be an EncodedVideoChunk or EncodedAudioChunk.");const n=new Uint8Array(e.byteLength);return e.copyTo(n),new ie(n,e.type,e.timestamp/1e6,(e.duration??0)/1e6,void 0,void 0,r)}clone(e){if(e!==void 0&&(typeof e!="object"||e===null))throw new TypeError("options, when provided, must be an object.");if((e==null?void 0:e.timestamp)!==void 0&&!Number.isFinite(e.timestamp))throw new TypeError("options.timestamp, when provided, must be a number.");if((e==null?void 0:e.duration)!==void 0&&!Number.isFinite(e.duration))throw new TypeError("options.duration, when provided, must be a number.");return new ie(this.data,this.type,(e==null?void 0:e.timestamp)??this.timestamp,(e==null?void 0:e.duration)??this.duration,this.sequenceNumber,this.byteLength)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const xa=t=>{let n=t,i=4096,s=0,a=12,o=0;for(n<0&&(n=-n,s=128),n+=33,n>8191&&(n=8191);(n&i)!==i&&a>=5;)i>>=1,a--;return o=n>>a-4&15,~(s|a-5<<4|o)&255},Ca=t=>{let r=0,n=0,i=~t;i&128&&(i&=-129,r=-1),n=((i&240)>>4)+5;const s=(1<<n|(i&15)<<n-4|1<<n-5)-33;return r===0?s:-s},Pa=t=>{let r=2048,n=0,i=11,s=0,a=t;for(a<0&&(a=-a,n=128),a>4095&&(a=4095);(a&r)!==r&&i>=5;)r>>=1,i--;return s=a>>(i===4?1:i-4)&15,(n|i-4<<4|s)^85},_a=t=>{let e=0,r=0,n=t^85;n&128&&(n&=-129,e=-1),r=((n&240)>>4)+4;let i=0;return r!==4?i=1<<r|(n&15)<<r-4|1<<r-5:i=n<<1|1,e===0?i:-i};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */Mi();class Ae{get displayWidth(){return this.rotation%180===0?this.codedWidth:this.codedHeight}get displayHeight(){return this.rotation%180===0?this.codedHeight:this.codedWidth}get microsecondTimestamp(){return Math.trunc(ht*this.timestamp)}get microsecondDuration(){return Math.trunc(ht*this.duration)}get hasAlpha(){return this.format&&this.format.includes("A")}constructor(e,r){if(this._closed=!1,e instanceof ArrayBuffer||ArrayBuffer.isView(e)){if(!r||typeof r!="object")throw new TypeError("init must be an object.");if(!("format"in r)||typeof r.format!="string")throw new TypeError("init.format must be a string.");if(!Number.isInteger(r.codedWidth)||r.codedWidth<=0)throw new TypeError("init.codedWidth must be a positive integer.");if(!Number.isInteger(r.codedHeight)||r.codedHeight<=0)throw new TypeError("init.codedHeight must be a positive integer.");if(r.rotation!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(!Number.isFinite(r.timestamp))throw new TypeError("init.timestamp must be a number.");if(r.duration!==void 0&&(!Number.isFinite(r.duration)||r.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");this._data=$e(e).slice(),this.format=r.format,this.codedWidth=r.codedWidth,this.codedHeight=r.codedHeight,this.rotation=r.rotation??0,this.timestamp=r.timestamp,this.duration=r.duration??0,this.colorSpace=new VideoColorSpace(r.colorSpace)}else if(typeof VideoFrame<"u"&&e instanceof VideoFrame){if((r==null?void 0:r.rotation)!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if((r==null?void 0:r.timestamp)!==void 0&&!Number.isFinite(r==null?void 0:r.timestamp))throw new TypeError("init.timestamp, when provided, must be a number.");if((r==null?void 0:r.duration)!==void 0&&(!Number.isFinite(r.duration)||r.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");this._data=e,this.format=e.format,this.codedWidth=e.displayWidth,this.codedHeight=e.displayHeight,this.rotation=(r==null?void 0:r.rotation)??0,this.timestamp=(r==null?void 0:r.timestamp)??e.timestamp/1e6,this.duration=(r==null?void 0:r.duration)??(e.duration??0)/1e6,this.colorSpace=e.colorSpace}else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof SVGImageElement<"u"&&e instanceof SVGImageElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap||typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&e instanceof OffscreenCanvas){if(!r||typeof r!="object")throw new TypeError("init must be an object.");if(r.rotation!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(!Number.isFinite(r.timestamp))throw new TypeError("init.timestamp must be a number.");if(r.duration!==void 0&&(!Number.isFinite(r.duration)||r.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");if(typeof VideoFrame<"u")return new Ae(new VideoFrame(e,{timestamp:Math.trunc(r.timestamp*ht),duration:Math.trunc((r.duration??0)*ht)||void 0}),r);let n=0,i=0;if("naturalWidth"in e?(n=e.naturalWidth,i=e.naturalHeight):"videoWidth"in e?(n=e.videoWidth,i=e.videoHeight):"width"in e&&(n=Number(e.width),i=Number(e.height)),!n||!i)throw new TypeError("Could not determine dimensions.");const s=new OffscreenCanvas(n,i),a=s.getContext("2d",{alpha:dr(),willReadFrequently:!0});h(a),a.drawImage(e,0,0),this._data=s,this.format="RGBX",this.codedWidth=n,this.codedHeight=i,this.rotation=r.rotation??0,this.timestamp=r.timestamp,this.duration=r.duration??0,this.colorSpace=new VideoColorSpace({matrix:"rgb",primaries:"bt709",transfer:"iec61966-2-1",fullRange:!0})}else throw new TypeError("Invalid data type: Must be a BufferSource or CanvasImageSource.")}clone(){if(this._closed)throw new Error("VideoSample is closed.");return h(this._data!==null),Zt(this._data)?new Ae(this._data.clone(),{timestamp:this.timestamp,duration:this.duration,rotation:this.rotation}):this._data instanceof Uint8Array?new Ae(this._data.slice(),{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.timestamp,duration:this.duration,colorSpace:this.colorSpace,rotation:this.rotation}):new Ae(this._data,{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.timestamp,duration:this.duration,colorSpace:this.colorSpace,rotation:this.rotation})}close(){this._closed||(Zt(this._data)?this._data.close():this._data=null,this._closed=!0)}allocationSize(){if(this._closed)throw new Error("VideoSample is closed.");return h(this._data!==null),Zt(this._data)?this._data.allocationSize():this._data instanceof Uint8Array?this._data.byteLength:this.codedWidth*this.codedHeight*4}async copyTo(e){if(!Mr(e))throw new TypeError("destination must be an ArrayBuffer or an ArrayBuffer view.");if(this._closed)throw new Error("VideoSample is closed.");if(h(this._data!==null),Zt(this._data))await this._data.copyTo(e);else if(this._data instanceof Uint8Array)$e(e).set(this._data);else{const n=this._data.getContext("2d");h(n);const i=n.getImageData(0,0,this.codedWidth,this.codedHeight);$e(e).set(i.data)}}toVideoFrame(){if(this._closed)throw new Error("VideoSample is closed.");return h(this._data!==null),Zt(this._data)?new VideoFrame(this._data,{timestamp:this.microsecondTimestamp,duration:this.microsecondDuration||void 0}):this._data instanceof Uint8Array?new VideoFrame(this._data,{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration||void 0,colorSpace:this.colorSpace}):new VideoFrame(this._data,{timestamp:this.microsecondTimestamp,duration:this.microsecondDuration||void 0})}draw(e,r,n,i,s,a,o,c,l){let u=0,d=0,p=this.displayWidth,g=this.displayHeight,w=0,m=0,k=this.displayWidth,T=this.displayHeight;if(a!==void 0?(u=r,d=n,p=i,g=s,w=a,m=o,c!==void 0?(k=c,T=l):(k=p,T=g)):(w=r,m=n,i!==void 0&&(k=i,T=s)),!(typeof CanvasRenderingContext2D<"u"&&e instanceof CanvasRenderingContext2D||typeof OffscreenCanvasRenderingContext2D<"u"&&e instanceof OffscreenCanvasRenderingContext2D))throw new TypeError("context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.");if(!Number.isFinite(u))throw new TypeError("sx must be a number.");if(!Number.isFinite(d))throw new TypeError("sy must be a number.");if(!Number.isFinite(p)||p<0)throw new TypeError("sWidth must be a non-negative number.");if(!Number.isFinite(g)||g<0)throw new TypeError("sHeight must be a non-negative number.");if(!Number.isFinite(w))throw new TypeError("dx must be a number.");if(!Number.isFinite(m))throw new TypeError("dy must be a number.");if(!Number.isFinite(k)||k<0)throw new TypeError("dWidth must be a non-negative number.");if(!Number.isFinite(T)||T<0)throw new TypeError("dHeight must be a non-negative number.");if(this._closed)throw new Error("VideoSample is closed.");({sx:u,sy:d,sWidth:p,sHeight:g}=this._rotateSourceRegion(u,d,p,g,this.rotation));const b=this.toCanvasImageSource();e.save();const y=w+k/2,S=m+T/2;e.translate(y,S),e.rotate(this.rotation*Math.PI/180);const x=this.rotation%180===0?1:k/T;e.scale(1/x,x),e.drawImage(b,u,d,p,g,-k/2,-T/2,k,T),e.restore()}drawWithFit(e,r){var T,b,y,S;if(!(typeof CanvasRenderingContext2D<"u"&&e instanceof CanvasRenderingContext2D||typeof OffscreenCanvasRenderingContext2D<"u"&&e instanceof OffscreenCanvasRenderingContext2D))throw new TypeError("context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.");if(!r||typeof r!="object")throw new TypeError("options must be an object.");if(!["fill","contain","cover"].includes(r.fit))throw new TypeError("options.fit must be 'fill', 'contain', or 'cover'.");if(r.rotation!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError("options.rotation, when provided, must be 0, 90, 180, or 270.");r.crop!==void 0&&Fn(r.crop,"options.");const n=e.canvas.width,i=e.canvas.height,s=r.rotation??this.rotation,[a,o]=s%180===0?[this.codedWidth,this.codedHeight]:[this.codedHeight,this.codedWidth];r.crop&&In(r.crop,a,o);let c,l,u,d;const{sx:p,sy:g,sWidth:w,sHeight:m}=this._rotateSourceRegion(((T=r.crop)==null?void 0:T.left)??0,((b=r.crop)==null?void 0:b.top)??0,((y=r.crop)==null?void 0:y.width)??a,((S=r.crop)==null?void 0:S.height)??o,s);if(r.fit==="fill")c=0,l=0,u=n,d=i;else{const[x,_]=r.crop?[r.crop.width,r.crop.height]:[a,o],P=r.fit==="contain"?Math.min(n/x,i/_):Math.max(n/x,i/_);u=x*P,d=_*P,c=(n-u)/2,l=(i-d)/2}const k=s%180===0?1:u/d;e.translate(n/2,i/2),e.rotate(s*Math.PI/180),e.scale(1/k,k),e.translate(-n/2,-i/2),e.drawImage(this.toCanvasImageSource(),p,g,w,m,c,l,u,d)}_rotateSourceRegion(e,r,n,i,s){return s===90?[e,r,n,i]=[r,this.codedHeight-e-n,i,n]:s===180?[e,r]=[this.codedWidth-e-n,this.codedHeight-r-i]:s===270&&([e,r,n,i]=[this.codedWidth-r-i,e,i,n]),{sx:e,sy:r,sWidth:n,sHeight:i}}toCanvasImageSource(){if(this._closed)throw new Error("VideoSample is closed.");if(h(this._data!==null),this._data instanceof Uint8Array){const e=this.toVideoFrame();return queueMicrotask(()=>e.close()),e}else return this._data}setRotation(e){if(![0,90,180,270].includes(e))throw new TypeError("newRotation must be 0, 90, 180, or 270.");this.rotation=e}setTimestamp(e){if(!Number.isFinite(e))throw new TypeError("newTimestamp must be a number.");this.timestamp=e}setDuration(e){if(!Number.isFinite(e)||e<0)throw new TypeError("newDuration must be a non-negative number.");this.duration=e}[Symbol.dispose](){this.close()}}const Zt=t=>typeof VideoFrame<"u"&&t instanceof VideoFrame,In=(t,e,r)=>{t.left=Math.min(t.left,e),t.top=Math.min(t.top,r),t.width=Math.min(t.width,e-t.left),t.height=Math.min(t.height,r-t.top),h(t.width>=0),h(t.height>=0)},Fn=(t,e)=>{if(!t||typeof t!="object")throw new TypeError(e+"crop, when provided, must be an object.");if(!Number.isInteger(t.left)||t.left<0)throw new TypeError(e+"crop.left must be a non-negative integer.");if(!Number.isInteger(t.top)||t.top<0)throw new TypeError(e+"crop.top must be a non-negative integer.");if(!Number.isInteger(t.width)||t.width<0)throw new TypeError(e+"crop.width must be a non-negative integer.");if(!Number.isInteger(t.height)||t.height<0)throw new TypeError(e+"crop.height must be a non-negative integer.")},$r=new Set(["f32","f32-planar","s16","s16-planar","s32","s32-planar","u8","u8-planar"]);class qe{get microsecondTimestamp(){return Math.trunc(ht*this.timestamp)}get microsecondDuration(){return Math.trunc(ht*this.duration)}constructor(e){if(this._closed=!1,er(e)){if(e.format===null)throw new TypeError("AudioData with null format is not supported.");this._data=e,this.format=e.format,this.sampleRate=e.sampleRate,this.numberOfFrames=e.numberOfFrames,this.numberOfChannels=e.numberOfChannels,this.timestamp=e.timestamp/1e6,this.duration=e.numberOfFrames/e.sampleRate}else{if(!e||typeof e!="object")throw new TypeError("Invalid AudioDataInit: must be an object.");if(!$r.has(e.format))throw new TypeError("Invalid AudioDataInit: invalid format.");if(!Number.isFinite(e.sampleRate)||e.sampleRate<=0)throw new TypeError("Invalid AudioDataInit: sampleRate must be > 0.");if(!Number.isInteger(e.numberOfChannels)||e.numberOfChannels===0)throw new TypeError("Invalid AudioDataInit: numberOfChannels must be an integer > 0.");if(!Number.isFinite(e==null?void 0:e.timestamp))throw new TypeError("init.timestamp must be a number.");const r=e.data.byteLength/(Jt(e.format)*e.numberOfChannels);if(!Number.isInteger(r))throw new TypeError("Invalid AudioDataInit: data size is not a multiple of frame size.");this.format=e.format,this.sampleRate=e.sampleRate,this.numberOfFrames=r,this.numberOfChannels=e.numberOfChannels,this.timestamp=e.timestamp,this.duration=r/e.sampleRate;let n;if(e.data instanceof ArrayBuffer)n=new Uint8Array(e.data);else if(ArrayBuffer.isView(e.data))n=new Uint8Array(e.data.buffer,e.data.byteOffset,e.data.byteLength);else throw new TypeError("Invalid AudioDataInit: data is not a BufferSource.");const i=this.numberOfFrames*this.numberOfChannels*Jt(this.format);if(n.byteLength<i)throw new TypeError("Invalid AudioDataInit: insufficient data size.");this._data=n}}allocationSize(e){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(!Number.isInteger(e.planeIndex)||e.planeIndex<0)throw new TypeError("planeIndex must be a non-negative integer.");if(e.format!==void 0&&!$r.has(e.format))throw new TypeError("Invalid format.");if(e.frameOffset!==void 0&&(!Number.isInteger(e.frameOffset)||e.frameOffset<0))throw new TypeError("frameOffset must be a non-negative integer.");if(e.frameCount!==void 0&&(!Number.isInteger(e.frameCount)||e.frameCount<0))throw new TypeError("frameCount must be a non-negative integer.");if(this._closed)throw new Error("AudioSample is closed.");const r=e.format??this.format,n=e.frameOffset??0;if(n>=this.numberOfFrames)throw new RangeError("frameOffset out of range");const i=e.frameCount!==void 0?e.frameCount:this.numberOfFrames-n;if(i>this.numberOfFrames-n)throw new RangeError("frameCount out of range");const s=Jt(r),a=kr(r);if(a&&e.planeIndex>=this.numberOfChannels)throw new RangeError("planeIndex out of range");if(!a&&e.planeIndex!==0)throw new RangeError("planeIndex out of range");return(a?i:i*this.numberOfChannels)*s}copyTo(e,r){if(!Mr(e))throw new TypeError("destination must be an ArrayBuffer or an ArrayBuffer view.");if(!r||typeof r!="object")throw new TypeError("options must be an object.");if(!Number.isInteger(r.planeIndex)||r.planeIndex<0)throw new TypeError("planeIndex must be a non-negative integer.");if(r.format!==void 0&&!$r.has(r.format))throw new TypeError("Invalid format.");if(r.frameOffset!==void 0&&(!Number.isInteger(r.frameOffset)||r.frameOffset<0))throw new TypeError("frameOffset must be a non-negative integer.");if(r.frameCount!==void 0&&(!Number.isInteger(r.frameCount)||r.frameCount<0))throw new TypeError("frameCount must be a non-negative integer.");if(this._closed)throw new Error("AudioSample is closed.");const{planeIndex:n,format:i,frameCount:s,frameOffset:a}=r,o=i??this.format;if(!o)throw new Error("Destination format not determined");const c=this.numberOfFrames,l=this.numberOfChannels,u=a??0;if(u>=c)throw new RangeError("frameOffset out of range");const d=s!==void 0?s:c-u;if(d>c-u)throw new RangeError("frameCount out of range");const p=Jt(o),g=kr(o);if(g&&n>=l)throw new RangeError("planeIndex out of range");if(!g&&n!==0)throw new RangeError("planeIndex out of range");const m=(g?d:d*l)*p;if(e.byteLength<m)throw new RangeError("Destination buffer is too small");const k=Te(e),T=Ea(o);if(er(this._data))if(g)if(o==="f32-planar")this._data.copyTo(e,{planeIndex:n,frameOffset:u,frameCount:d,format:"f32-planar"});else{const b=new ArrayBuffer(d*4),y=new Float32Array(b);this._data.copyTo(y,{planeIndex:n,frameOffset:u,frameCount:d,format:"f32-planar"});const S=new DataView(b);for(let x=0;x<d;x++){const _=x*p,P=S.getFloat32(x*4,!0);T(k,_,P)}}else{const b=l,y=new Float32Array(d);for(let S=0;S<b;S++){this._data.copyTo(y,{planeIndex:S,frameOffset:u,frameCount:d,format:"f32-planar"});for(let x=0;x<d;x++){const P=(x*b+S)*p;T(k,P,y[x])}}}else{const b=this._data,y=new DataView(b.buffer,b.byteOffset,b.byteLength),S=this.format,x=va(S),_=Jt(S),P=kr(S);for(let M=0;M<d;M++)if(g){const F=M*p;let z;P?z=(n*c+(M+u))*_:z=((M+u)*l+n)*_;const O=x(y,z);T(k,F,O)}else for(let F=0;F<l;F++){const O=(M*l+F)*p;let L;P?L=(F*c+(M+u))*_:L=((M+u)*l+F)*_;const X=x(y,L);T(k,O,X)}}}clone(){if(this._closed)throw new Error("AudioSample is closed.");if(er(this._data)){const e=new qe(this._data.clone());return e.setTimestamp(this.timestamp),e}else return new qe({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.timestamp,data:this._data})}close(){this._closed||(er(this._data)?this._data.close():this._data=new Uint8Array(0),this._closed=!0)}toAudioData(){if(this._closed)throw new Error("AudioSample is closed.");if(er(this._data)){if(this._data.timestamp===this.microsecondTimestamp)return this._data.clone();if(kr(this.format)){const e=this.allocationSize({planeIndex:0,format:this.format}),r=new ArrayBuffer(e*this.numberOfChannels);for(let n=0;n<this.numberOfChannels;n++)this.copyTo(new Uint8Array(r,n*e,e),{planeIndex:n,format:this.format});return new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:r})}else{const e=new ArrayBuffer(this.allocationSize({planeIndex:0,format:this.format}));return this.copyTo(e,{planeIndex:0,format:this.format}),new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:e})}}else return new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:this._data})}toAudioBuffer(){if(this._closed)throw new Error("AudioSample is closed.");const e=new AudioBuffer({numberOfChannels:this.numberOfChannels,length:this.numberOfFrames,sampleRate:this.sampleRate}),r=new Float32Array(this.allocationSize({planeIndex:0,format:"f32-planar"})/4);for(let n=0;n<this.numberOfChannels;n++)this.copyTo(r,{planeIndex:n,format:"f32-planar"}),e.copyToChannel(r,n);return e}setTimestamp(e){if(!Number.isFinite(e))throw new TypeError("newTimestamp must be a number.");this.timestamp=e}[Symbol.dispose](){this.close()}static*_fromAudioBuffer(e,r){if(!(e instanceof AudioBuffer))throw new TypeError("audioBuffer must be an AudioBuffer.");const n=48e3*5,i=e.numberOfChannels,s=e.sampleRate,a=e.length,o=Math.floor(n/i);let c=0,l=a;for(;l>0;){const u=Math.min(o,l),d=new Float32Array(i*u);for(let p=0;p<i;p++)e.copyFromChannel(d.subarray(p*u,(p+1)*u),p,c);yield new qe({format:"f32-planar",sampleRate:s,numberOfFrames:u,numberOfChannels:i,timestamp:r+c/s,data:d}),c+=u,l-=u}}static fromAudioBuffer(e,r){if(!(e instanceof AudioBuffer))throw new TypeError("audioBuffer must be an AudioBuffer.");const n=48e3*5,i=e.numberOfChannels,s=e.sampleRate,a=e.length,o=Math.floor(n/i);let c=0,l=a;const u=[];for(;l>0;){const d=Math.min(o,l),p=new Float32Array(i*d);for(let w=0;w<i;w++)e.copyFromChannel(p.subarray(w*d,(w+1)*d),w,c);const g=new qe({format:"f32-planar",sampleRate:s,numberOfFrames:d,numberOfChannels:i,timestamp:r+c/s,data:p});u.push(g),c+=d,l-=d}return u}}const Jt=t=>{switch(t){case"u8":case"u8-planar":return 1;case"s16":case"s16-planar":return 2;case"s32":case"s32-planar":return 4;case"f32":case"f32-planar":return 4;default:throw new Error("Unknown AudioSampleFormat")}},kr=t=>{switch(t){case"u8-planar":case"s16-planar":case"s32-planar":case"f32-planar":return!0;default:return!1}},va=t=>{switch(t){case"u8":case"u8-planar":return(e,r)=>(e.getUint8(r)-128)/128;case"s16":case"s16-planar":return(e,r)=>e.getInt16(r,!0)/32768;case"s32":case"s32-planar":return(e,r)=>e.getInt32(r,!0)/2147483648;case"f32":case"f32-planar":return(e,r)=>e.getFloat32(r,!0)}},Ea=t=>{switch(t){case"u8":case"u8-planar":return(e,r,n)=>e.setUint8(r,pe((n+1)*127.5,0,255));case"s16":case"s16-planar":return(e,r,n)=>e.setInt16(r,pe(Math.round(n*32767),-32768,32767),!0);case"s32":case"s32-planar":return(e,r,n)=>e.setInt32(r,pe(Math.round(n*2147483647),-2147483648,2147483647),!0);case"f32":case"f32-planar":return(e,r,n)=>e.setFloat32(r,n,!0)}},er=t=>typeof AudioData<"u"&&t instanceof AudioData;/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Et=t=>{if(!t||typeof t!="object")throw new TypeError("options must be an object.");if(t.metadataOnly!==void 0&&typeof t.metadataOnly!="boolean")throw new TypeError("options.metadataOnly, when defined, must be a boolean.");if(t.verifyKeyPackets!==void 0&&typeof t.verifyKeyPackets!="boolean")throw new TypeError("options.verifyKeyPackets, when defined, must be a boolean.");if(t.verifyKeyPackets&&t.metadataOnly)throw new TypeError("options.verifyKeyPackets and options.metadataOnly cannot be enabled together.")},gt=t=>{if(typeof t!="number"||Number.isNaN(t))throw new TypeError("timestamp must be a number.")},jr=(t,e,r)=>r.verifyKeyPackets?e.then(async n=>{if(!n||n.type==="delta")return n;const i=await t.determinePacketType(n);return i&&(n.type=i),n}):e;class hr{constructor(e){if(!(e instanceof Bn))throw new TypeError("track must be an InputTrack.");this._track=e}getFirstPacket(e={}){if(Et(e),this._track.input._disposed)throw new _e;return jr(this._track,this._track._backing.getFirstPacket(e),e)}getPacket(e,r={}){if(gt(e),Et(r),this._track.input._disposed)throw new _e;return jr(this._track,this._track._backing.getPacket(e,r),r)}getNextPacket(e,r={}){if(!(e instanceof ie))throw new TypeError("packet must be an EncodedPacket.");if(Et(r),this._track.input._disposed)throw new _e;return jr(this._track,this._track._backing.getNextPacket(e,r),r)}async getKeyPacket(e,r={}){if(gt(e),Et(r),this._track.input._disposed)throw new _e;if(!r.verifyKeyPackets)return this._track._backing.getKeyPacket(e,r);const n=await this._track._backing.getKeyPacket(e,r);return!n||n.type==="delta"?n:await this._track.determinePacketType(n)==="delta"?this.getKeyPacket(n.timestamp-1/this._track.timeResolution,r):n}async getNextKeyPacket(e,r={}){if(!(e instanceof ie))throw new TypeError("packet must be an EncodedPacket.");if(Et(r),this._track.input._disposed)throw new _e;if(!r.verifyKeyPackets)return this._track._backing.getNextKeyPacket(e,r);const n=await this._track._backing.getNextKeyPacket(e,r);return!n||n.type==="delta"?n:await this._track.determinePacketType(n)==="delta"?this.getNextKeyPacket(n,r):n}packets(e,r,n={}){if(e!==void 0&&!(e instanceof ie))throw new TypeError("startPacket must be an EncodedPacket.");if(e!==void 0&&e.isMetadataOnly&&!(n!=null&&n.metadataOnly))throw new TypeError("startPacket can only be metadata-only if options.metadataOnly is enabled.");if(r!==void 0&&!(r instanceof ie))throw new TypeError("endPacket must be an EncodedPacket.");if(Et(n),this._track.input._disposed)throw new _e;const i=[];let{promise:s,resolve:a}=ke(),{promise:o,resolve:c}=ke(),l=!1,u=!1,d=null;const p=[],g=()=>Math.max(2,p.length);(async()=>{let m=e??await this.getFirstPacket(n);for(;m&&!u&&!this._track.input._disposed&&!(r&&m.sequenceNumber>=(r==null?void 0:r.sequenceNumber));){if(i.length>g()){({promise:o,resolve:c}=ke()),await o;continue}i.push(m),a(),{promise:s,resolve:a}=ke(),m=await this.getNextPacket(m,n)}l=!0,a()})().catch(m=>{d||(d=m,a())});const w=this._track;return{async next(){for(;;){if(w.input._disposed)throw new _e;if(u)return{value:void 0,done:!0};if(d)throw d;if(i.length>0){const m=i.shift(),k=performance.now();for(p.push(k);p.length>0&&k-p[0]>=1e3;)p.shift();return c(),{value:m,done:!1}}else{if(l)return{value:void 0,done:!0};await s}}},async return(){return u=!0,c(),a(),{value:void 0,done:!0}},async throw(m){throw m},[Symbol.asyncIterator](){return this}}}}class An{constructor(e,r){this.onSample=e,this.onError=r}}class ts{mediaSamplesInRange(e=0,r=1/0){gt(e),gt(r);const n=[];let i=!1,s=null,{promise:a,resolve:o}=ke(),{promise:c,resolve:l}=ke(),u=!1,d=!1,p=!1,g=null;(async()=>{const k=new Error,T=await this._createDecoder(P=>{if(l(),P.timestamp>=r&&(d=!0),d){P.close();return}s&&(P.timestamp>e?(n.push(s),i=!0):s.close()),P.timestamp>=e&&(n.push(P),i=!0),s=i?null:P,n.length>0&&(o(),{promise:a,resolve:o}=ke())},P=>{g||(P.stack=k.stack,g=P,o())}),b=this._createPacketSink(),y=await b.getKeyPacket(e,{verifyKeyPackets:!0})??await b.getFirstPacket();if(!y)return;let S=y,x;if(r<1/0){const P=await b.getPacket(r),M=P?P.type==="key"&&P.timestamp===r?P:await b.getNextKeyPacket(P,{verifyKeyPackets:!0}):null;M&&(x=M)}const _=b.packets(y,x);for(await _.next();S&&!d&&!this._track.input._disposed;){const P=ni(n.length);if(n.length+T.getDecodeQueueSize()>P){({promise:c,resolve:l}=ke()),await c;continue}T.decode(S);const M=await _.next();if(M.done)break;S=M.value}await _.return(),!p&&!this._track.input._disposed&&await T.flush(),T.close(),!i&&s&&n.push(s),u=!0,o()})().catch(k=>{g||(g=k,o())});const w=this._track,m=()=>{s==null||s.close();for(const k of n)k.close()};return{async next(){for(;;){if(w.input._disposed)throw m(),new _e;if(p)return{value:void 0,done:!0};if(g)throw m(),g;if(n.length>0){const k=n.shift();return l(),{value:k,done:!1}}else if(!u)await a;else return{value:void 0,done:!0}}},async return(){return p=!0,d=!0,l(),o(),m(),{value:void 0,done:!0}},async throw(k){throw k},[Symbol.asyncIterator](){return this}}}mediaSamplesAtTimestamps(e){Ws(e);const r=Us(e),n=[],i=[];let{promise:s,resolve:a}=ke(),{promise:o,resolve:c}=ke(),l=!1,u=!1,d=null;const p=m=>{i.push(m),a(),{promise:s,resolve:a}=ke()};(async()=>{const m=new Error,k=await this._createDecoder(P=>{if(c(),u){P.close();return}let M=0;for(;n.length>0&&P.timestamp-n[0]>-1e-10;)M++,n.shift();if(M>0)for(let F=0;F<M;F++)p(F<M-1?P.clone():P);else P.close()},P=>{d||(P.stack=m.stack,d=P,a())}),T=this._createPacketSink();let b=null,y=null,S=-1;const x=async()=>{h(y);let P=y;for(k.decode(P);P.sequenceNumber<S;){const M=ni(i.length);for(;i.length+k.getDecodeQueueSize()>M&&!u;)({promise:o,resolve:c}=ke()),await o;if(u)break;const F=await T.getNextPacket(P);h(F),k.decode(F),P=F}S=-1},_=async()=>{await k.flush();for(let P=0;P<n.length;P++)p(null);n.length=0};for await(const P of r){if(gt(P),u||this._track.input._disposed)break;const M=await T.getPacket(P),F=M&&await T.getKeyPacket(P,{verifyKeyPackets:!0});if(!F){S!==-1&&(await x(),await _()),p(null),b=null;continue}b&&(F.sequenceNumber!==y.sequenceNumber||M.timestamp<b.timestamp)&&(await x(),await _()),n.push(M.timestamp),S=Math.max(M.sequenceNumber,S),b=M,y=F}!u&&!this._track.input._disposed&&(S!==-1&&await x(),await _()),k.close(),l=!0,a()})().catch(m=>{d||(d=m,a())});const g=this._track,w=()=>{for(const m of i)m==null||m.close()};return{async next(){for(;;){if(g.input._disposed)throw w(),new _e;if(u)return{value:void 0,done:!0};if(d)throw w(),d;if(i.length>0){const m=i.shift();return h(m!==void 0),c(),{value:m,done:!1}}else if(!l)await s;else return{value:void 0,done:!0}}},async return(){return u=!0,c(),a(),w(),{value:void 0,done:!0}},async throw(m){throw m},[Symbol.asyncIterator](){return this}}}}const ni=t=>t===0?40:8;class Ia extends An{constructor(e,r,n,i,s,a){super(e,r),this.codec=n,this.decoderConfig=i,this.rotation=s,this.timeResolution=a,this.decoder=null,this.customDecoder=null,this.customDecoderCallSerializer=new Or,this.customDecoderQueueSize=0,this.inputTimestamps=[],this.sampleQueue=[],this.currentPacketIndex=0,this.raslSkipped=!1,this.alphaDecoder=null,this.alphaHadKeyframe=!1,this.colorQueue=[],this.alphaQueue=[],this.merger=null,this.mergerCreationFailed=!1,this.decodedAlphaChunkCount=0,this.alphaDecoderQueueSize=0,this.nullAlphaFrameQueue=[],this.currentAlphaPacketIndex=0,this.alphaRaslSkipped=!1;const o=Ji.find(c=>c.supports(n,i));if(o)this.customDecoder=new o,this.customDecoder.codec=n,this.customDecoder.config=i,this.customDecoder.onSample=c=>{if(!(c instanceof Ae))throw new TypeError("The argument passed to onSample must be a VideoSample.");this.finalizeAndEmitSample(c)},this.customDecoderCallSerializer.call(()=>this.customDecoder.init());else{const c=l=>{if(this.alphaQueue.length>0){const u=this.alphaQueue.shift();h(u!==void 0),this.mergeAlpha(l,u)}else this.colorQueue.push(l)};this.decoder=new VideoDecoder({output:l=>{try{c(l)}catch(u){this.onError(u)}},error:r}),this.decoder.configure(i)}}getDecodeQueueSize(){var e;return this.customDecoder?this.customDecoderQueueSize:(h(this.decoder),Math.max(this.decoder.decodeQueueSize,((e=this.alphaDecoder)==null?void 0:e.decodeQueueSize)??0))}decode(e){if(this.codec==="hevc"&&this.currentPacketIndex>0&&!this.raslSkipped){if(this.hasHevcRaslPicture(e.data))return;this.raslSkipped=!0}this.currentPacketIndex++,this.customDecoder?(this.customDecoderQueueSize++,this.customDecoderCallSerializer.call(()=>this.customDecoder.decode(e)).then(()=>this.customDecoderQueueSize--)):(h(this.decoder),Hr()||pt(this.inputTimestamps,e.timestamp,r=>r),this.decoder.decode(e.toEncodedVideoChunk()),this.decodeAlphaData(e))}decodeAlphaData(e){if(!e.sideData.alpha||this.mergerCreationFailed){this.pushNullAlphaFrame();return}if(!this.merger)try{this.merger=new Fa}catch(n){console.error("Due to an error, only color data will be decoded.",n),this.mergerCreationFailed=!0,this.decodeAlphaData(e);return}if(!this.alphaDecoder){const n=i=>{if(this.alphaDecoderQueueSize--,this.colorQueue.length>0){const s=this.colorQueue.shift();h(s!==void 0),this.mergeAlpha(s,i)}else this.alphaQueue.push(i);for(this.decodedAlphaChunkCount++;this.nullAlphaFrameQueue.length>0&&this.nullAlphaFrameQueue[0]===this.decodedAlphaChunkCount;)if(this.nullAlphaFrameQueue.shift(),this.colorQueue.length>0){const s=this.colorQueue.shift();h(s!==void 0),this.mergeAlpha(s,null)}else this.alphaQueue.push(null)};this.alphaDecoder=new VideoDecoder({output:i=>{try{n(i)}catch(s){this.onError(s)}},error:this.onError}),this.alphaDecoder.configure(this.decoderConfig)}const r=Zi(this.codec,this.decoderConfig,e.sideData.alpha);if(this.alphaHadKeyframe||(this.alphaHadKeyframe=r==="key"),this.alphaHadKeyframe){if(this.codec==="hevc"&&this.currentAlphaPacketIndex>0&&!this.alphaRaslSkipped){if(this.hasHevcRaslPicture(e.sideData.alpha)){this.pushNullAlphaFrame();return}this.alphaRaslSkipped=!0}this.currentAlphaPacketIndex++,this.alphaDecoder.decode(e.alphaToEncodedVideoChunk(r??e.type)),this.alphaDecoderQueueSize++}else this.pushNullAlphaFrame()}pushNullAlphaFrame(){this.alphaDecoderQueueSize===0?this.alphaQueue.push(null):this.nullAlphaFrameQueue.push(this.decodedAlphaChunkCount+this.alphaDecoderQueueSize)}hasHevcRaslPicture(e){return ji(e,this.decoderConfig).some(n=>{const i=lt(n);return i===Se.RASL_N||i===Se.RASL_R})}sampleHandler(e){if(Hr()){if(this.sampleQueue.length>0&&e.timestamp>=ue(this.sampleQueue).timestamp){for(const r of this.sampleQueue)this.finalizeAndEmitSample(r);this.sampleQueue.length=0}pt(this.sampleQueue,e,r=>r.timestamp)}else{const r=this.inputTimestamps.shift();h(r!==void 0),e.setTimestamp(r),this.finalizeAndEmitSample(e)}}finalizeAndEmitSample(e){e.setTimestamp(Math.round(e.timestamp*this.timeResolution)/this.timeResolution),e.setDuration(Math.round(e.duration*this.timeResolution)/this.timeResolution),e.setRotation(this.rotation),this.onSample(e)}mergeAlpha(e,r){if(!r){const s=new Ae(e);this.sampleHandler(s);return}h(this.merger),this.merger.update(e,r),e.close(),r.close();const n=new VideoFrame(this.merger.canvas,{timestamp:e.timestamp,duration:e.duration??void 0}),i=new Ae(n);this.sampleHandler(i)}async flush(){var e;if(this.customDecoder?await this.customDecoderCallSerializer.call(()=>this.customDecoder.flush()):(h(this.decoder),await Promise.all([this.decoder.flush(),(e=this.alphaDecoder)==null?void 0:e.flush()]),this.colorQueue.forEach(r=>r.close()),this.colorQueue.length=0,this.alphaQueue.forEach(r=>r==null?void 0:r.close()),this.alphaQueue.length=0,this.alphaHadKeyframe=!1,this.decodedAlphaChunkCount=0,this.alphaDecoderQueueSize=0,this.nullAlphaFrameQueue.length=0,this.currentAlphaPacketIndex=0,this.alphaRaslSkipped=!1),Hr()){for(const r of this.sampleQueue)this.finalizeAndEmitSample(r);this.sampleQueue.length=0}this.currentPacketIndex=0,this.raslSkipped=!1}close(){var e,r;this.customDecoder?this.customDecoderCallSerializer.call(()=>this.customDecoder.close()):(h(this.decoder),this.decoder.close(),(e=this.alphaDecoder)==null||e.close(),this.colorQueue.forEach(n=>n.close()),this.colorQueue.length=0,this.alphaQueue.forEach(n=>n==null?void 0:n.close()),this.alphaQueue.length=0,(r=this.merger)==null||r.close());for(const n of this.sampleQueue)n.close();this.sampleQueue.length=0}}class Fa{constructor(){typeof OffscreenCanvas<"u"?this.canvas=new OffscreenCanvas(300,150):this.canvas=document.createElement("canvas");const e=this.canvas.getContext("webgl2",{premultipliedAlpha:!1});if(!e)throw new Error("Couldn't acquire WebGL 2 context.");this.gl=e,this.program=this.createProgram(),this.vao=this.createVAO(),this.colorTexture=this.createTexture(),this.alphaTexture=this.createTexture(),this.gl.useProgram(this.program),this.gl.uniform1i(this.gl.getUniformLocation(this.program,"u_colorTexture"),0),this.gl.uniform1i(this.gl.getUniformLocation(this.program,"u_alphaTexture"),1)}createProgram(){const e=this.createShader(this.gl.VERTEX_SHADER,`#version 300 es
			in vec2 a_position;
			in vec2 a_texCoord;
			out vec2 v_texCoord;
			
			void main() {
				gl_Position = vec4(a_position, 0.0, 1.0);
				v_texCoord = a_texCoord;
			}
		`),r=this.createShader(this.gl.FRAGMENT_SHADER,`#version 300 es
			precision highp float;
			
			uniform sampler2D u_colorTexture;
			uniform sampler2D u_alphaTexture;
			in vec2 v_texCoord;
			out vec4 fragColor;
			
			void main() {
				vec3 color = texture(u_colorTexture, v_texCoord).rgb;
				float alpha = texture(u_alphaTexture, v_texCoord).r;
				fragColor = vec4(color, alpha);
			}
		`),n=this.gl.createProgram();return this.gl.attachShader(n,e),this.gl.attachShader(n,r),this.gl.linkProgram(n),n}createShader(e,r){const n=this.gl.createShader(e);return this.gl.shaderSource(n,r),this.gl.compileShader(n),n}createVAO(){const e=this.gl.createVertexArray();this.gl.bindVertexArray(e);const r=new Float32Array([-1,-1,0,1,1,-1,1,1,-1,1,0,0,1,1,1,0]),n=this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER,n),this.gl.bufferData(this.gl.ARRAY_BUFFER,r,this.gl.STATIC_DRAW);const i=this.gl.getAttribLocation(this.program,"a_position"),s=this.gl.getAttribLocation(this.program,"a_texCoord");return this.gl.enableVertexAttribArray(i),this.gl.vertexAttribPointer(i,2,this.gl.FLOAT,!1,16,0),this.gl.enableVertexAttribArray(s),this.gl.vertexAttribPointer(s,2,this.gl.FLOAT,!1,16,8),e}createTexture(){const e=this.gl.createTexture();return this.gl.bindTexture(this.gl.TEXTURE_2D,e),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR),e}update(e,r){(e.displayWidth!==this.canvas.width||e.displayHeight!==this.canvas.height)&&(this.canvas.width=e.displayWidth,this.canvas.height=e.displayHeight),this.gl.activeTexture(this.gl.TEXTURE0),this.gl.bindTexture(this.gl.TEXTURE_2D,this.colorTexture),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,e),this.gl.activeTexture(this.gl.TEXTURE1),this.gl.bindTexture(this.gl.TEXTURE_2D,this.alphaTexture),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,r),this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.gl.bindVertexArray(this.vao),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4)}close(){var e;(e=this.gl.getExtension("WEBGL_lose_context"))==null||e.loseContext(),this.gl=null}}class fn extends ts{constructor(e){if(!(e instanceof wr))throw new TypeError("videoTrack must be an InputVideoTrack.");super(),this._track=e}async _createDecoder(e,r){if(!await this._track.canDecode())throw new Error("This video track cannot be decoded by this browser. Make sure to check decodability before using a track.");const n=this._track.codec,i=this._track.rotation,s=await this._track.getDecoderConfig(),a=this._track.timeResolution;return h(n&&s),new Ia(e,r,n,s,i,a)}_createPacketSink(){return new hr(this._track)}async getSample(e){gt(e);for await(const r of this.mediaSamplesAtTimestamps([e]))return r;throw new Error("Internal error: Iterator returned nothing.")}samples(e=0,r=1/0){return this.mediaSamplesInRange(e,r)}samplesAtTimestamps(e){return this.mediaSamplesAtTimestamps(e)}}class Aa{constructor(e,r={}){if(this._nextCanvasIndex=0,!(e instanceof wr))throw new TypeError("videoTrack must be an InputVideoTrack.");if(r&&typeof r!="object")throw new TypeError("options must be an object.");if(r.alpha!==void 0&&typeof r.alpha!="boolean")throw new TypeError("options.alpha, when provided, must be a boolean.");if(r.width!==void 0&&(!Number.isInteger(r.width)||r.width<=0))throw new TypeError("options.width, when defined, must be a positive integer.");if(r.height!==void 0&&(!Number.isInteger(r.height)||r.height<=0))throw new TypeError("options.height, when defined, must be a positive integer.");if(r.fit!==void 0&&!["fill","contain","cover"].includes(r.fit))throw new TypeError('options.fit, when provided, must be one of "fill", "contain", or "cover".');if(r.width!==void 0&&r.height!==void 0&&r.fit===void 0)throw new TypeError("When both options.width and options.height are provided, options.fit must also be provided.");if(r.rotation!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError("options.rotation, when provided, must be 0, 90, 180 or 270.");if(r.crop!==void 0&&Fn(r.crop,"options."),r.poolSize!==void 0&&(typeof r.poolSize!="number"||!Number.isInteger(r.poolSize)||r.poolSize<0))throw new TypeError("poolSize must be a non-negative integer.");const n=r.rotation??e.rotation,[i,s]=n%180===0?[e.codedWidth,e.codedHeight]:[e.codedHeight,e.codedWidth],a=r.crop;a&&In(a,i,s);let[o,c]=a?[a.width,a.height]:[i,s];const l=o/c;r.width!==void 0&&r.height===void 0?(o=r.width,c=Math.round(o/l)):r.width===void 0&&r.height!==void 0?(c=r.height,o=Math.round(c*l)):r.width!==void 0&&r.height!==void 0&&(o=r.width,c=r.height),this._videoTrack=e,this._alpha=r.alpha??!1,this._width=o,this._height=c,this._rotation=n,this._crop=a,this._fit=r.fit??"fill",this._videoSampleSink=new fn(e),this._canvasPool=Array.from({length:r.poolSize??0},()=>null)}_videoSampleToWrappedCanvas(e){let r=this._canvasPool[this._nextCanvasIndex],n=!1;r||(typeof document<"u"?(r=document.createElement("canvas"),r.width=this._width,r.height=this._height):r=new OffscreenCanvas(this._width,this._height),this._canvasPool.length>0&&(this._canvasPool[this._nextCanvasIndex]=r),n=!0),this._canvasPool.length>0&&(this._nextCanvasIndex=(this._nextCanvasIndex+1)%this._canvasPool.length);const i=r.getContext("2d",{alpha:this._alpha||dr()});h(i),i.resetTransform(),n||(!this._alpha&&dr()?(i.fillStyle="black",i.fillRect(0,0,this._width,this._height)):i.clearRect(0,0,this._width,this._height)),e.drawWithFit(i,{fit:this._fit,rotation:this._rotation,crop:this._crop});const s={canvas:r,timestamp:e.timestamp,duration:e.duration};return e.close(),s}async getCanvas(e){gt(e);const r=await this._videoSampleSink.getSample(e);return r&&this._videoSampleToWrappedCanvas(r)}canvases(e=0,r=1/0){return Kn(this._videoSampleSink.samples(e,r),n=>this._videoSampleToWrappedCanvas(n))}canvasesAtTimestamps(e){return Kn(this._videoSampleSink.samplesAtTimestamps(e),r=>r&&this._videoSampleToWrappedCanvas(r))}}class Ba extends An{constructor(e,r,n,i){super(e,r),this.decoder=null,this.customDecoder=null,this.customDecoderCallSerializer=new Or,this.customDecoderQueueSize=0,this.currentTimestamp=null;const s=o=>{(this.currentTimestamp===null||Math.abs(o.timestamp-this.currentTimestamp)>=o.duration)&&(this.currentTimestamp=o.timestamp);const c=this.currentTimestamp;if(this.currentTimestamp+=o.duration,o.numberOfFrames===0){o.close();return}const l=i.sampleRate;o.setTimestamp(Math.round(c*l)/l),e(o)},a=es.find(o=>o.supports(n,i));a?(this.customDecoder=new a,this.customDecoder.codec=n,this.customDecoder.config=i,this.customDecoder.onSample=o=>{if(!(o instanceof qe))throw new TypeError("The argument passed to onSample must be an AudioSample.");s(o)},this.customDecoderCallSerializer.call(()=>this.customDecoder.init())):(this.decoder=new AudioDecoder({output:o=>{try{s(new qe(o))}catch(c){this.onError(c)}},error:r}),this.decoder.configure(i))}getDecodeQueueSize(){return this.customDecoder?this.customDecoderQueueSize:(h(this.decoder),this.decoder.decodeQueueSize)}decode(e){this.customDecoder?(this.customDecoderQueueSize++,this.customDecoderCallSerializer.call(()=>this.customDecoder.decode(e)).then(()=>this.customDecoderQueueSize--)):(h(this.decoder),this.decoder.decode(e.toEncodedAudioChunk()))}flush(){return this.customDecoder?this.customDecoderCallSerializer.call(()=>this.customDecoder.flush()):(h(this.decoder),this.decoder.flush())}close(){this.customDecoder?this.customDecoderCallSerializer.call(()=>this.customDecoder.close()):(h(this.decoder),this.decoder.close())}}class za extends An{constructor(e,r,n){super(e,r),this.decoderConfig=n,this.currentTimestamp=null,h(ye.includes(n.codec)),this.codec=n.codec;const{dataType:i,sampleSize:s,littleEndian:a}=kt(this.codec);switch(this.inputSampleSize=s,s){case 1:i==="unsigned"?this.readInputValue=(o,c)=>o.getUint8(c)-2**7:i==="signed"?this.readInputValue=(o,c)=>o.getInt8(c):i==="ulaw"?this.readInputValue=(o,c)=>Ca(o.getUint8(c)):i==="alaw"?this.readInputValue=(o,c)=>_a(o.getUint8(c)):h(!1);break;case 2:i==="unsigned"?this.readInputValue=(o,c)=>o.getUint16(c,a)-2**15:i==="signed"?this.readInputValue=(o,c)=>o.getInt16(c,a):h(!1);break;case 3:i==="unsigned"?this.readInputValue=(o,c)=>Nr(o,c,a)-2**23:i==="signed"?this.readInputValue=(o,c)=>Ls(o,c,a):h(!1);break;case 4:i==="unsigned"?this.readInputValue=(o,c)=>o.getUint32(c,a)-2**31:i==="signed"?this.readInputValue=(o,c)=>o.getInt32(c,a):i==="float"?this.readInputValue=(o,c)=>o.getFloat32(c,a):h(!1);break;case 8:i==="float"?this.readInputValue=(o,c)=>o.getFloat64(c,a):h(!1);break;default:bt(s),h(!1)}switch(s){case 1:i==="ulaw"||i==="alaw"?(this.outputSampleSize=2,this.outputFormat="s16",this.writeOutputValue=(o,c,l)=>o.setInt16(c,l,!0)):(this.outputSampleSize=1,this.outputFormat="u8",this.writeOutputValue=(o,c,l)=>o.setUint8(c,l+2**7));break;case 2:this.outputSampleSize=2,this.outputFormat="s16",this.writeOutputValue=(o,c,l)=>o.setInt16(c,l,!0);break;case 3:this.outputSampleSize=4,this.outputFormat="s32",this.writeOutputValue=(o,c,l)=>o.setInt32(c,l<<8,!0);break;case 4:this.outputSampleSize=4,i==="float"?(this.outputFormat="f32",this.writeOutputValue=(o,c,l)=>o.setFloat32(c,l,!0)):(this.outputFormat="s32",this.writeOutputValue=(o,c,l)=>o.setInt32(c,l,!0));break;case 8:this.outputSampleSize=4,this.outputFormat="f32",this.writeOutputValue=(o,c,l)=>o.setFloat32(c,l,!0);break;default:bt(s),h(!1)}}getDecodeQueueSize(){return 0}decode(e){const r=Te(e.data),n=e.byteLength/this.decoderConfig.numberOfChannels/this.inputSampleSize,i=n*this.decoderConfig.numberOfChannels*this.outputSampleSize,s=new ArrayBuffer(i),a=new DataView(s);for(let u=0;u<n*this.decoderConfig.numberOfChannels;u++){const d=u*this.inputSampleSize,p=u*this.outputSampleSize,g=this.readInputValue(r,d);this.writeOutputValue(a,p,g)}const o=n/this.decoderConfig.sampleRate;(this.currentTimestamp===null||Math.abs(e.timestamp-this.currentTimestamp)>=o)&&(this.currentTimestamp=e.timestamp);const c=this.currentTimestamp;this.currentTimestamp+=o;const l=new qe({format:this.outputFormat,data:s,numberOfChannels:this.decoderConfig.numberOfChannels,sampleRate:this.decoderConfig.sampleRate,numberOfFrames:n,timestamp:c});this.onSample(l)}async flush(){}close(){}}class ii extends ts{constructor(e){if(!(e instanceof rt))throw new TypeError("audioTrack must be an InputAudioTrack.");super(),this._track=e}async _createDecoder(e,r){if(!await this._track.canDecode())throw new Error("This audio track cannot be decoded by this browser. Make sure to check decodability before using a track.");const n=this._track.codec,i=await this._track.getDecoderConfig();return h(n&&i),ye.includes(i.codec)?new za(e,r,i):new Ba(e,r,n,i)}_createPacketSink(){return new hr(this._track)}async getSample(e){gt(e);for await(const r of this.mediaSamplesAtTimestamps([e]))return r;throw new Error("Internal error: Iterator returned nothing.")}samples(e=0,r=1/0){return this.mediaSamplesInRange(e,r)}samplesAtTimestamps(e){return this.mediaSamplesAtTimestamps(e)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Bn{constructor(e,r){this.input=e,this._backing=r}isVideoTrack(){return this instanceof wr}isAudioTrack(){return this instanceof rt}get id(){return this._backing.getId()}get internalCodecId(){return this._backing.getInternalCodecId()}get languageCode(){return this._backing.getLanguageCode()}get name(){return this._backing.getName()}get timeResolution(){return this._backing.getTimeResolution()}getFirstTimestamp(){return this._backing.getFirstTimestamp()}computeDuration(){return this._backing.computeDuration()}async computePacketStats(e=1/0){const r=new hr(this);let n=1/0,i=-1/0,s=0,a=0;for await(const o of r.packets(void 0,void 0,{metadataOnly:!0})){if(s>=e&&o.timestamp>=i)break;n=Math.min(n,o.timestamp),i=Math.max(i,o.timestamp+o.duration),s++,a+=o.byteLength}return{packetCount:s,averagePacketRate:s?Number((s/(i-n)).toPrecision(16)):0,averageBitrate:s?Number((8*a/(i-n)).toPrecision(16)):0}}}class wr extends Bn{constructor(e,r){super(e,r),this._backing=r}get type(){return"video"}get codec(){return this._backing.getCodec()}get codedWidth(){return this._backing.getCodedWidth()}get codedHeight(){return this._backing.getCodedHeight()}get rotation(){return this._backing.getRotation()}get displayWidth(){return this._backing.getRotation()%180===0?this._backing.getCodedWidth():this._backing.getCodedHeight()}get displayHeight(){return this._backing.getRotation()%180===0?this._backing.getCodedHeight():this._backing.getCodedWidth()}getColorSpace(){return this._backing.getColorSpace()}async hasHighDynamicRange(){const e=await this._backing.getColorSpace();return e.primaries==="bt2020"||e.primaries==="smpte432"||e.transfer==="pg"||e.transfer==="hlg"||e.matrix==="bt2020-ncl"}canBeTransparent(){return this._backing.canBeTransparent()}getDecoderConfig(){return this._backing.getDecoderConfig()}async getCodecParameterString(){const e=await this._backing.getDecoderConfig();return(e==null?void 0:e.codec)??null}async canDecode(){try{const e=await this._backing.getDecoderConfig();if(!e)return!1;const r=this._backing.getCodec();return h(r!==null),Ji.some(i=>i.supports(r,e))?!0:typeof VideoDecoder>"u"?!1:(await VideoDecoder.isConfigSupported(e)).supported===!0}catch(e){return console.error("Error during decodability check:",e),!1}}async determinePacketType(e){if(!(e instanceof ie))throw new TypeError("packet must be an EncodedPacket.");if(e.isMetadataOnly)throw new TypeError("packet must not be metadata-only to determine its type.");if(this.codec===null)return null;const r=await this.getDecoderConfig();return h(r),Zi(this.codec,r,e.data)}}class rt extends Bn{constructor(e,r){super(e,r),this._backing=r}get type(){return"audio"}get codec(){return this._backing.getCodec()}get numberOfChannels(){return this._backing.getNumberOfChannels()}get sampleRate(){return this._backing.getSampleRate()}getDecoderConfig(){return this._backing.getDecoderConfig()}async getCodecParameterString(){const e=await this._backing.getDecoderConfig();return(e==null?void 0:e.codec)??null}async canDecode(){try{const e=await this._backing.getDecoderConfig();if(!e)return!1;const r=this._backing.getCodec();return h(r!==null),es.some(n=>n.supports(r,e))||e.codec.startsWith("pcm-")?!0:typeof AudioDecoder>"u"?!1:(await AudioDecoder.isConfigSupported(e)).supported===!0}catch(e){return console.error("Error during decodability check:",e),!1}}async determinePacketType(e){if(!(e instanceof ie))throw new TypeError("packet must be an EncodedPacket.");return this.codec===null?null:"key"}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const rs=t=>{let r=(t.hasVideo?"video/":t.hasAudio?"audio/":"application/")+(t.isQuickTime?"quicktime":"mp4");if(t.codecStrings.length>0){const n=[...new Set(t.codecStrings)];r+=`; codecs="${n.join(", ")}"`}return r};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Ne=8,ut=16,Xe=t=>{let e=R(t);const r=ge(t,4);let n=8;e===1&&(e=Me(t),n=16);const s=e-n;return s<0?null:{name:r,totalSize:e,headerSize:n,contentSize:s}},yt=t=>xt(t)/65536,Kr=t=>xt(t)/1073741824,Qr=t=>{let e=0;for(let r=0;r<4;r++){e<<=7;const n=U(t);if(e|=n&127,!(n&128))break}return e},Ve=t=>{let e=be(t);return t.skip(2),e=Math.min(e,t.remainingLength),Be.decode($(t,e))},Ra=t=>{const e=Xe(t);if(!e||e.name!=="data")return null;const r=R(t);t.skip(4);const n=$(t,e.contentSize-8);switch(r){case 1:return Be.decode(n);case 2:return new TextDecoder("utf-16be").decode(n);case 13:return new Ut(n,"image/jpeg");case 14:return new Ut(n,"image/png");case 27:return new Ut(n,"image/bmp");default:return n}};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Da extends _t{constructor(e){super(e),this.moovSlice=null,this.currentTrack=null,this.tracks=[],this.metadataPromise=null,this.movieTimescale=-1,this.movieDurationInTimescale=-1,this.isQuickTime=!1,this.metadataTags={},this.currentMetadataKeys=null,this.isFragmented=!1,this.fragmentTrackDefaults=[],this.fragments=[],this.currentFragment=null,this.fragmentLookupMutex=new wt,this.reader=e._reader}async computeDuration(){const e=await this.getTracks(),r=await Promise.all(e.map(n=>n.computeDuration()));return Math.max(0,...r)}async getTracks(){return await this.readMetadata(),this.tracks.map(e=>e.inputTrack)}async getMimeType(){await this.readMetadata();const e=await Promise.all(this.tracks.map(r=>r.inputTrack.getCodecParameterString()));return rs({isQuickTime:this.isQuickTime,hasVideo:this.tracks.some(r=>{var n;return((n=r.info)==null?void 0:n.type)==="video"}),hasAudio:this.tracks.some(r=>{var n;return((n=r.info)==null?void 0:n.type)==="audio"}),codecStrings:e.filter(Boolean)})}async getMetadataTags(){return await this.readMetadata(),this.metadataTags}readMetadata(){return this.metadataPromise??(this.metadataPromise=(async()=>{let e=0;for(;;){let r=this.reader.requestSliceRange(e,Ne,ut);if(r instanceof Promise&&(r=await r),!r)break;const n=e,i=Xe(r);if(!i)break;if(i.name==="ftyp"){const s=ge(r,4);this.isQuickTime=s==="qt  "}else if(i.name==="moov"){let s=this.reader.requestSlice(r.filePos,i.contentSize);if(s instanceof Promise&&(s=await s),!s)break;this.moovSlice=s,this.readContiguousBoxes(this.moovSlice);for(const a of this.tracks){const o=a.editListPreviousSegmentDurations/this.movieTimescale;a.editListOffset-=Math.round(o*a.timescale)}break}e=n+i.totalSize}if(this.isFragmented&&this.reader.fileSize!==null){let r=this.reader.requestSlice(this.reader.fileSize-4,4);r instanceof Promise&&(r=await r),h(r);const n=R(r),i=this.reader.fileSize-n;if(i>=0&&i<=this.reader.fileSize-ut){let s=this.reader.requestSliceRange(i,Ne,ut);if(s instanceof Promise&&(s=await s),s){const a=Xe(s);if(a&&a.name==="mfra"){let o=this.reader.requestSlice(s.filePos,a.contentSize);o instanceof Promise&&(o=await o),o&&this.readContiguousBoxes(o)}}}}})())}getSampleTableForTrack(e){var s,a;if(e.sampleTable)return e.sampleTable;const r={sampleTimingEntries:[],sampleCompositionTimeOffsets:[],sampleSizes:[],keySampleIndices:null,chunkOffsets:[],sampleToChunk:[],presentationTimestamps:null,presentationTimestampIndexMap:null};e.sampleTable=r,h(this.moovSlice);const n=this.moovSlice.slice(e.sampleTableByteOffset);if(this.currentTrack=e,this.traverseBox(n),this.currentTrack=null,((s=e.info)==null?void 0:s.type)==="audio"&&e.info.codec&&ye.includes(e.info.codec)&&r.sampleCompositionTimeOffsets.length===0){h(((a=e.info)==null?void 0:a.type)==="audio");const o=kt(e.info.codec),c=[],l=[];for(let u=0;u<r.sampleToChunk.length;u++){const d=r.sampleToChunk[u],p=r.sampleToChunk[u+1],g=(p?p.startChunkIndex:r.chunkOffsets.length)-d.startChunkIndex;for(let w=0;w<g;w++){const m=d.startSampleIndex+w*d.samplesPerChunk,k=m+d.samplesPerChunk,T=te(r.sampleTimingEntries,m,z=>z.startIndex),b=r.sampleTimingEntries[T],y=te(r.sampleTimingEntries,k,z=>z.startIndex),S=r.sampleTimingEntries[y],x=b.startDecodeTimestamp+(m-b.startIndex)*b.delta,P=S.startDecodeTimestamp+(k-S.startIndex)*S.delta-x,M=ue(c);M&&M.delta===P?M.count++:c.push({startIndex:d.startChunkIndex+w,startDecodeTimestamp:x,count:1,delta:P});const F=d.samplesPerChunk*o.sampleSize*e.info.numberOfChannels;l.push(F)}d.startSampleIndex=d.startChunkIndex,d.samplesPerChunk=1}r.sampleTimingEntries=c,r.sampleSizes=l}if(r.sampleCompositionTimeOffsets.length>0){r.presentationTimestamps=[];for(const o of r.sampleTimingEntries)for(let c=0;c<o.count;c++)r.presentationTimestamps.push({presentationTimestamp:o.startDecodeTimestamp+c*o.delta,sampleIndex:o.startIndex+c});for(const o of r.sampleCompositionTimeOffsets)for(let c=0;c<o.count;c++){const l=o.startIndex+c,u=r.presentationTimestamps[l];u&&(u.presentationTimestamp+=o.offset)}r.presentationTimestamps.sort((o,c)=>o.presentationTimestamp-c.presentationTimestamp),r.presentationTimestampIndexMap=Array(r.presentationTimestamps.length).fill(-1);for(let o=0;o<r.presentationTimestamps.length;o++)r.presentationTimestampIndexMap[r.presentationTimestamps[o].sampleIndex]=o}return r}async readFragment(e){let r=this.reader.requestSliceRange(e,Ne,ut);r instanceof Promise&&(r=await r),h(r);const n=Xe(r);h((n==null?void 0:n.name)==="moof");let i=this.reader.requestSlice(e,n.totalSize);i instanceof Promise&&(i=await i),h(i),this.traverseBox(i);const s=fe(this.fragments,e,o=>o.moofOffset);h(s!==-1);const a=this.fragments[s];h(a.moofOffset===e);for(const[o,c]of a.trackData){if(c.startTimestampIsFinal)continue;const l=this.tracks.find(m=>m.id===o);let u=0,d=null,p=null;const g=te(l.fragments,e-1,m=>m.moofOffset);g!==-1&&(d=l.fragments[g],p=d,u=d.moofOffset+d.moofSize);let w=u===0;for(;u<=e-Ne;){if(d!=null&&d.nextFragment)d=d.nextFragment,u=d.moofOffset+d.moofSize;else{let m=this.reader.requestSliceRange(u,Ne,ut);if(m instanceof Promise&&(m=await m),!m)break;const k=u,T=Xe(m);if(!T)break;if(T.name==="moof"){const b=fe(this.fragments,k,S=>S.moofOffset);let y;b===-1?y=await this.readFragment(k):y=this.fragments[b],d&&(d.nextFragment=y),d=y,w&&(y.isKnownToBeFirstFragment=!0,w=!1)}u=k+T.totalSize}d&&d.trackData.has(o)&&(p=d)}if(p){const m=p.trackData.get(o);h(m.startTimestampIsFinal),ai(c,m.endTimestamp)}c.startTimestampIsFinal=!0}return a}readContiguousBoxes(e){const r=e.filePos;for(;e.filePos-r<=e.length-Ne&&this.traverseBox(e););}*iterateContiguousBoxes(e){const r=e.filePos;for(;e.filePos-r<=e.length-Ne;){const n=e.filePos,i=Xe(e);if(!i)break;yield{boxInfo:i,slice:e},e.filePos=n+i.totalSize}}traverseBox(e){var a,o,c,l,u,d,p,g,w,m,k,T,b,y,S,x,_,P,M,F,z,O,L,X,se,ve,oe,he,ce,Ee,Ce,it,Oe,jt,Kt,Qt,Gt,Xt,Yt,N,Q;const r=e.filePos,n=Xe(e);if(!n)return!1;const i=e.filePos,s=r+n.totalSize;switch(n.name){case"mdia":case"minf":case"dinf":case"mfra":case"edts":this.readContiguousBoxes(e.slice(i,n.contentSize));break;case"mvhd":{const f=U(e);e.skip(3),f===1?(e.skip(8+8),this.movieTimescale=R(e),this.movieDurationInTimescale=Me(e)):(e.skip(4+4),this.movieTimescale=R(e),this.movieDurationInTimescale=R(e))}break;case"trak":{const f={id:-1,demuxer:this,inputTrack:null,info:null,timescale:-1,durationInMovieTimescale:-1,durationInMediaTimescale:-1,rotation:0,internalCodecId:null,name:null,languageCode:Fe,sampleTableByteOffset:-1,sampleTable:null,fragmentLookupTable:null,currentFragmentState:null,fragments:[],fragmentsWithKeyFrame:[],editListPreviousSegmentDurations:0,editListOffset:0};if(this.currentTrack=f,this.readContiguousBoxes(e.slice(i,n.contentSize)),f.id!==-1&&f.timescale!==-1&&f.info!==null){if(f.info.type==="video"&&f.info.width!==-1){const I=f;f.inputTrack=new wr(this.input,new Ma(I)),this.tracks.push(f)}else if(f.info.type==="audio"&&f.info.numberOfChannels!==-1){const I=f;f.inputTrack=new rt(this.input,new Na(I)),this.tracks.push(f)}}this.currentTrack=null}break;case"tkhd":{const f=this.currentTrack;if(!f)break;const I=U(e);if(!((Dt(e)&1)!==0))break;if(I===0)e.skip(8),f.id=R(e),e.skip(4),f.durationInMovieTimescale=R(e);else if(I===1)e.skip(16),f.id=R(e),e.skip(4),f.durationInMovieTimescale=Me(e);else throw new Error(`Incorrect track header version ${I}.`);e.skip(2*4+2+2+2+2);const H=[yt(e),yt(e),Kr(e),yt(e),yt(e),Kr(e),yt(e),yt(e),Kr(e)],A=vn(qs(Wa(H),90));h(A===0||A===90||A===180||A===270),f.rotation=A}break;case"elst":{const f=this.currentTrack;if(!f)break;const I=U(e);e.skip(3);let E=!1,v=0;const H=R(e);for(let A=0;A<H;A++){const D=I===1?Me(e):R(e),G=I===1?Yo(e):xt(e),K=yt(e);if(D!==0){if(E){console.warn("Unsupported edit list: multiple edits are not currently supported. Only using first edit.");break}if(G===-1){v+=D;continue}if(K!==1){console.warn("Unsupported edit list entry: media rate must be 1.");break}f.editListPreviousSegmentDurations=v,f.editListOffset=G,E=!0}}}break;case"mdhd":{const f=this.currentTrack;if(!f)break;const I=U(e);e.skip(3),I===0?(e.skip(8),f.timescale=R(e),f.durationInMediaTimescale=R(e)):I===1&&(e.skip(16),f.timescale=R(e),f.durationInMediaTimescale=Me(e));let E=be(e);if(E>0){f.languageCode="";for(let v=0;v<3;v++)f.languageCode=String.fromCharCode(96+(E&31))+f.languageCode,E>>=5;ur(f.languageCode)||(f.languageCode=Fe)}}break;case"hdlr":{const f=this.currentTrack;if(!f)break;e.skip(8);const I=ge(e,4);I==="vide"?f.info={type:"video",width:-1,height:-1,codec:null,codecDescription:null,colorSpace:null,avcCodecInfo:null,hevcCodecInfo:null,vp9CodecInfo:null,av1CodecInfo:null}:I==="soun"&&(f.info={type:"audio",numberOfChannels:-1,sampleRate:-1,codec:null,codecDescription:null,aacCodecInfo:null})}break;case"stbl":{const f=this.currentTrack;if(!f)break;f.sampleTableByteOffset=r,this.readContiguousBoxes(e.slice(i,n.contentSize))}break;case"stsd":{const f=this.currentTrack;if(!f||f.info===null||f.sampleTable)break;const I=U(e);e.skip(3);const E=R(e);for(let v=0;v<E;v++){const H=e.filePos,A=Xe(e);if(!A)break;f.internalCodecId=A.name;const D=A.name.toLowerCase();if(f.info.type==="video")D==="avc1"?f.info.codec="avc":D==="hvc1"||D==="hev1"?f.info.codec="hevc":D==="vp08"?f.info.codec="vp8":D==="vp09"?f.info.codec="vp9":D==="av01"?f.info.codec="av1":console.warn(`Unsupported video codec (sample entry type '${A.name}').`),e.skip(6*1+2+2+2+3*4),f.info.width=be(e),f.info.height=be(e),e.skip(4+4+4+2+32+2+2),this.readContiguousBoxes(e.slice(e.filePos,H+A.totalSize-e.filePos));else{D==="mp4a"||(D==="opus"?f.info.codec="opus":D==="flac"?f.info.codec="flac":D==="twos"||D==="sowt"||D==="raw "||D==="in24"||D==="in32"||D==="fl32"||D==="fl64"||D==="lpcm"||D==="ipcm"||D==="fpcm"||(D==="ulaw"?f.info.codec="ulaw":D==="alaw"?f.info.codec="alaw":console.warn(`Unsupported audio codec (sample entry type '${A.name}').`))),e.skip(6*1+2);const G=be(e);e.skip(3*2);let K=be(e),j=be(e);e.skip(2*2);let ee=R(e)/65536;if(I===0&&G>0){if(G===1)e.skip(4),j=8*R(e),e.skip(2*4);else if(G===2){e.skip(4),ee=ks(e),K=R(e),e.skip(4),j=R(e);const le=R(e);if(e.skip(2*4),D==="lpcm"){const re=j+7>>3,st=!!(le&1),ne=!!(le&2),Ur=le&4?-1:0;j>0&&j<=64&&(st?j===32&&(f.info.codec=ne?"pcm-f32be":"pcm-f32"):Ur&1<<re-1?re===1?f.info.codec="pcm-s8":re===2?f.info.codec=ne?"pcm-s16be":"pcm-s16":re===3?f.info.codec=ne?"pcm-s24be":"pcm-s24":re===4&&(f.info.codec=ne?"pcm-s32be":"pcm-s32"):re===1&&(f.info.codec="pcm-u8")),f.info.codec===null&&console.warn("Unsupported PCM format.")}}}f.info.codec==="opus"&&(ee=Vr),f.info.numberOfChannels=K,f.info.sampleRate=ee,D==="twos"?j===8?f.info.codec="pcm-s8":j===16?f.info.codec="pcm-s16be":(console.warn(`Unsupported sample size ${j} for codec 'twos'.`),f.info.codec=null):D==="sowt"?j===8?f.info.codec="pcm-s8":j===16?f.info.codec="pcm-s16":(console.warn(`Unsupported sample size ${j} for codec 'sowt'.`),f.info.codec=null):D==="raw "?f.info.codec="pcm-u8":D==="in24"?f.info.codec="pcm-s24be":D==="in32"?f.info.codec="pcm-s32be":D==="fl32"?f.info.codec="pcm-f32be":D==="fl64"?f.info.codec="pcm-f64be":D==="ipcm"?f.info.codec="pcm-s16be":D==="fpcm"&&(f.info.codec="pcm-f32be"),this.readContiguousBoxes(e.slice(e.filePos,H+A.totalSize-e.filePos))}}}break;case"avcC":{const f=this.currentTrack;if(!f)break;h(f.info),f.info.codecDescription=$(e,n.contentSize)}break;case"hvcC":{const f=this.currentTrack;if(!f)break;h(f.info),f.info.codecDescription=$(e,n.contentSize)}break;case"vpcC":{const f=this.currentTrack;if(!f)break;h(((a=f.info)==null?void 0:a.type)==="video"),e.skip(4);const I=U(e),E=U(e),v=U(e),H=v>>4,A=v>>1&7,D=v&1,G=U(e),K=U(e),j=U(e);f.info.vp9CodecInfo={profile:I,level:E,bitDepth:H,chromaSubsampling:A,videoFullRangeFlag:D,colourPrimaries:G,transferCharacteristics:K,matrixCoefficients:j}}break;case"av1C":{const f=this.currentTrack;if(!f)break;h(((o=f.info)==null?void 0:o.type)==="video"),e.skip(1);const I=U(e),E=I>>5,v=I&31,H=U(e),A=H>>7,D=H>>6&1,G=H>>5&1,K=H>>4&1,j=H>>3&1,ee=H>>2&1,le=H&3,re=E===2&&D?G?12:10:D?10:8;f.info.av1CodecInfo={profile:E,level:v,tier:A,bitDepth:re,monochrome:K,chromaSubsamplingX:j,chromaSubsamplingY:ee,chromaSamplePosition:le}}break;case"colr":{const f=this.currentTrack;if(!f||(h(((c=f.info)==null?void 0:c.type)==="video"),ge(e,4)!=="nclx"))break;const E=be(e),v=be(e),H=be(e),A=!!(U(e)&128);f.info.colorSpace={primaries:Ii[E],transfer:Fi[v],matrix:Ai[H],fullRange:A}}break;case"wave":this.readContiguousBoxes(e.slice(i,n.contentSize));break;case"esds":{const f=this.currentTrack;if(!f)break;h(((l=f.info)==null?void 0:l.type)==="audio"),e.skip(4);const I=U(e);h(I===3),Qr(e),e.skip(2);const E=U(e),v=(E&128)!==0,H=(E&64)!==0,A=(E&32)!==0;if(v&&e.skip(2),H){const ee=U(e);e.skip(ee)}A&&e.skip(2);const D=U(e);h(D===4);const G=Qr(e),K=e.filePos,j=U(e);if(j===64||j===103?(f.info.codec="aac",f.info.aacCodecInfo={isMpeg2:j===103}):j===105||j===107?f.info.codec="mp3":j===221?f.info.codec="vorbis":console.warn(`Unsupported audio codec (objectTypeIndication ${j}) - discarding track.`),e.skip(1+3+4+4),G>e.filePos-K){const ee=U(e);h(ee===5);const le=Qr(e);if(f.info.codecDescription=$(e,le),f.info.codec==="aac"){const re=Wi(f.info.codecDescription);re.numberOfChannels!==null&&(f.info.numberOfChannels=re.numberOfChannels),re.sampleRate!==null&&(f.info.sampleRate=re.sampleRate)}}}break;case"enda":{const f=this.currentTrack;if(!f)break;h(((u=f.info)==null?void 0:u.type)==="audio"),be(e)&255&&(f.info.codec==="pcm-s16be"?f.info.codec="pcm-s16":f.info.codec==="pcm-s24be"?f.info.codec="pcm-s24":f.info.codec==="pcm-s32be"?f.info.codec="pcm-s32":f.info.codec==="pcm-f32be"?f.info.codec="pcm-f32":f.info.codec==="pcm-f64be"&&(f.info.codec="pcm-f64"))}break;case"pcmC":{const f=this.currentTrack;if(!f)break;h(((d=f.info)==null?void 0:d.type)==="audio"),e.skip(1+3);const E=!!(U(e)&1),v=U(e);f.info.codec==="pcm-s16be"?E?v===16?f.info.codec="pcm-s16":v===24?f.info.codec="pcm-s24":v===32?f.info.codec="pcm-s32":(console.warn(`Invalid ipcm sample size ${v}.`),f.info.codec=null):v===16?f.info.codec="pcm-s16be":v===24?f.info.codec="pcm-s24be":v===32?f.info.codec="pcm-s32be":(console.warn(`Invalid ipcm sample size ${v}.`),f.info.codec=null):f.info.codec==="pcm-f32be"&&(E?v===32?f.info.codec="pcm-f32":v===64?f.info.codec="pcm-f64":(console.warn(`Invalid fpcm sample size ${v}.`),f.info.codec=null):v===32?f.info.codec="pcm-f32be":v===64?f.info.codec="pcm-f64be":(console.warn(`Invalid fpcm sample size ${v}.`),f.info.codec=null));break}case"dOps":{const f=this.currentTrack;if(!f)break;h(((p=f.info)==null?void 0:p.type)==="audio"),e.skip(1);const I=U(e),E=be(e),v=R(e),H=yn(e),A=U(e);let D;A!==0?D=$(e,2+I):D=new Uint8Array(0);const G=new Uint8Array(8+1+1+2+4+2+1+D.byteLength),K=new DataView(G.buffer);K.setUint32(0,1332770163,!1),K.setUint32(4,1214603620,!1),K.setUint8(8,1),K.setUint8(9,I),K.setUint16(10,E,!0),K.setUint32(12,v,!0),K.setInt16(16,H,!0),K.setUint8(18,A),G.set(D,19),f.info.codecDescription=G,f.info.numberOfChannels=I}break;case"dfLa":{const f=this.currentTrack;if(!f)break;h(((g=f.info)==null?void 0:g.type)==="audio"),e.skip(4);const I=127,E=128,v=e.filePos;for(;e.filePos<s;){const K=U(e),j=Dt(e);if((K&I)===Lt.STREAMINFO){e.skip(10);const le=R(e),re=le>>>12,st=(le>>9&7)+1;f.info.sampleRate=re,f.info.numberOfChannels=st,e.skip(20)}else e.skip(j);if(K&E)break}const H=e.filePos;e.filePos=v;const A=$(e,H-v),D=new Uint8Array(4+A.byteLength);new DataView(D.buffer).setUint32(0,1716281667,!1),D.set(A,4),f.info.codecDescription=D}break;case"stts":{const f=this.currentTrack;if(!f||!f.sampleTable)break;e.skip(4);const I=R(e);let E=0,v=0;for(let H=0;H<I;H++){const A=R(e),D=R(e);f.sampleTable.sampleTimingEntries.push({startIndex:E,startDecodeTimestamp:v,count:A,delta:D}),E+=A,v+=A*D}}break;case"ctts":{const f=this.currentTrack;if(!f||!f.sampleTable)break;e.skip(1+3);const I=R(e);let E=0;for(let v=0;v<I;v++){const H=R(e),A=xt(e);f.sampleTable.sampleCompositionTimeOffsets.push({startIndex:E,count:H,offset:A}),E+=H}}break;case"stsz":{const f=this.currentTrack;if(!f||!f.sampleTable)break;e.skip(4);const I=R(e),E=R(e);if(I===0)for(let v=0;v<E;v++){const H=R(e);f.sampleTable.sampleSizes.push(H)}else f.sampleTable.sampleSizes.push(I)}break;case"stz2":{const f=this.currentTrack;if(!f||!f.sampleTable)break;e.skip(4),e.skip(3);const I=U(e),E=R(e),v=$(e,Math.ceil(E*I/8)),H=new de(v);for(let A=0;A<E;A++){const D=H.readBits(I);f.sampleTable.sampleSizes.push(D)}}break;case"stss":{const f=this.currentTrack;if(!f||!f.sampleTable)break;e.skip(4),f.sampleTable.keySampleIndices=[];const I=R(e);for(let E=0;E<I;E++){const v=R(e)-1;f.sampleTable.keySampleIndices.push(v)}f.sampleTable.keySampleIndices[0]!==0&&f.sampleTable.keySampleIndices.unshift(0)}break;case"stsc":{const f=this.currentTrack;if(!f||!f.sampleTable)break;e.skip(4);const I=R(e);for(let v=0;v<I;v++){const H=R(e)-1,A=R(e),D=R(e);f.sampleTable.sampleToChunk.push({startSampleIndex:-1,startChunkIndex:H,samplesPerChunk:A,sampleDescriptionIndex:D})}let E=0;for(let v=0;v<f.sampleTable.sampleToChunk.length;v++)if(f.sampleTable.sampleToChunk[v].startSampleIndex=E,v<f.sampleTable.sampleToChunk.length-1){const A=f.sampleTable.sampleToChunk[v+1].startChunkIndex-f.sampleTable.sampleToChunk[v].startChunkIndex;E+=A*f.sampleTable.sampleToChunk[v].samplesPerChunk}}break;case"stco":{const f=this.currentTrack;if(!f||!f.sampleTable)break;e.skip(4);const I=R(e);for(let E=0;E<I;E++){const v=R(e);f.sampleTable.chunkOffsets.push(v)}}break;case"co64":{const f=this.currentTrack;if(!f||!f.sampleTable)break;e.skip(4);const I=R(e);for(let E=0;E<I;E++){const v=Me(e);f.sampleTable.chunkOffsets.push(v)}}break;case"mvex":this.isFragmented=!0,this.readContiguousBoxes(e.slice(i,n.contentSize));break;case"mehd":{const f=U(e);e.skip(3);const I=f===1?Me(e):R(e);this.movieDurationInTimescale=I}break;case"trex":{e.skip(4);const f=R(e),I=R(e),E=R(e),v=R(e),H=R(e);this.fragmentTrackDefaults.push({trackId:f,defaultSampleDescriptionIndex:I,defaultSampleDuration:E,defaultSampleSize:v,defaultSampleFlags:H})}break;case"tfra":{const f=U(e);e.skip(3);const I=R(e),E=this.tracks.find(re=>re.id===I);if(!E)break;E.fragmentLookupTable=[];const v=R(e),H=(v&48)>>4,A=(v&12)>>2,D=v&3,G=[U,be,Dt,R],K=G[H],j=G[A],ee=G[D],le=R(e);for(let re=0;re<le;re++){const st=f===1?Me(e):R(e),ne=f===1?Me(e):R(e);K(e),j(e),ee(e),E.fragmentLookupTable.push({timestamp:st,moofOffset:ne})}}break;case"moof":{this.currentFragment={moofOffset:r,moofSize:n.totalSize,implicitBaseDataOffset:r,trackData:new Map,dataStart:1/0,dataEnd:0,nextFragment:null,isKnownToBeFirstFragment:!1},this.readContiguousBoxes(e.slice(i,n.contentSize)),pt(this.fragments,this.currentFragment,f=>f.moofOffset);for(const[,f]of this.currentFragment.trackData){const I=f.samples[0],E=ue(f.samples);this.currentFragment.dataStart=Math.min(this.currentFragment.dataStart,I.byteOffset),this.currentFragment.dataEnd=Math.max(this.currentFragment.dataEnd,E.byteOffset+E.byteSize)}this.currentFragment=null}break;case"traf":if(h(this.currentFragment),this.readContiguousBoxes(e.slice(i,n.contentSize)),this.currentTrack){const f=this.currentFragment.trackData.get(this.currentTrack.id);if(f){pt(this.currentTrack.fragments,this.currentFragment,v=>v.moofOffset),f.firstKeyFrameTimestamp!==null&&pt(this.currentTrack.fragmentsWithKeyFrame,this.currentFragment,v=>v.moofOffset);const{currentFragmentState:E}=this.currentTrack;h(E),E.startTimestamp!==null&&(ai(f,E.startTimestamp),f.startTimestampIsFinal=!0)}this.currentTrack.currentFragmentState=null,this.currentTrack=null}break;case"tfhd":{h(this.currentFragment),e.skip(1);const f=Dt(e),I=!!(f&1),E=!!(f&2),v=!!(f&8),H=!!(f&16),A=!!(f&32),D=!!(f&65536),G=!!(f&131072),K=R(e),j=this.tracks.find(le=>le.id===K);if(!j)break;const ee=this.fragmentTrackDefaults.find(le=>le.trackId===K);this.currentTrack=j,j.currentFragmentState={baseDataOffset:this.currentFragment.implicitBaseDataOffset,sampleDescriptionIndex:(ee==null?void 0:ee.defaultSampleDescriptionIndex)??null,defaultSampleDuration:(ee==null?void 0:ee.defaultSampleDuration)??null,defaultSampleSize:(ee==null?void 0:ee.defaultSampleSize)??null,defaultSampleFlags:(ee==null?void 0:ee.defaultSampleFlags)??null,startTimestamp:null},I?j.currentFragmentState.baseDataOffset=Me(e):G&&(j.currentFragmentState.baseDataOffset=this.currentFragment.moofOffset),E&&(j.currentFragmentState.sampleDescriptionIndex=R(e)),v&&(j.currentFragmentState.defaultSampleDuration=R(e)),H&&(j.currentFragmentState.defaultSampleSize=R(e)),A&&(j.currentFragmentState.defaultSampleFlags=R(e)),D&&(j.currentFragmentState.defaultSampleDuration=0)}break;case"tfdt":{const f=this.currentTrack;if(!f)break;h(f.currentFragmentState);const I=U(e);e.skip(3);const E=I===0?R(e):Me(e);f.currentFragmentState.startTimestamp=E}break;case"trun":{const f=this.currentTrack;if(!f)break;if(h(this.currentFragment),h(f.currentFragmentState),this.currentFragment.trackData.has(f.id)){console.warn("Can't have two trun boxes for the same track in one fragment. Ignoring...");break}const I=U(e),E=Dt(e),v=!!(E&1),H=!!(E&4),A=!!(E&256),D=!!(E&512),G=!!(E&1024),K=!!(E&2048),j=R(e);let ee=f.currentFragmentState.baseDataOffset;v&&(ee+=xt(e));let le=null;H&&(le=R(e));let re=ee;if(j===0){this.currentFragment.implicitBaseDataOffset=re;break}let st=0;const ne={startTimestamp:0,endTimestamp:0,firstKeyFrameTimestamp:null,samples:[],presentationTimestamps:[],startTimestampIsFinal:!1};this.currentFragment.trackData.set(f.id,ne);for(let Pe=0;Pe<j;Pe++){let Re;A?Re=R(e):(h(f.currentFragmentState.defaultSampleDuration!==null),Re=f.currentFragmentState.defaultSampleDuration);let at;D?at=R(e):(h(f.currentFragmentState.defaultSampleSize!==null),at=f.currentFragmentState.defaultSampleSize);let vt;G?vt=R(e):(h(f.currentFragmentState.defaultSampleFlags!==null),vt=f.currentFragmentState.defaultSampleFlags),Pe===0&&le!==null&&(vt=le);let Wr=0;K&&(I===0?Wr=R(e):Wr=xt(e));const Os=!(vt&65536);ne.samples.push({presentationTimestamp:st+Wr,duration:Re,byteOffset:re,byteSize:at,isKeyFrame:Os}),re+=at,st+=Re}ne.presentationTimestamps=ne.samples.map((Pe,Re)=>({presentationTimestamp:Pe.presentationTimestamp,sampleIndex:Re})).sort((Pe,Re)=>Pe.presentationTimestamp-Re.presentationTimestamp);for(let Pe=0;Pe<ne.presentationTimestamps.length;Pe++){const Re=ne.presentationTimestamps[Pe],at=ne.samples[Re.sampleIndex];if(ne.firstKeyFrameTimestamp===null&&at.isKeyFrame&&(ne.firstKeyFrameTimestamp=at.presentationTimestamp),Pe<ne.presentationTimestamps.length-1){const vt=ne.presentationTimestamps[Pe+1];at.duration=vt.presentationTimestamp-Re.presentationTimestamp}}const Ur=ne.samples[ne.presentationTimestamps[0].sampleIndex],qn=ne.samples[ue(ne.presentationTimestamps).sampleIndex];ne.startTimestamp=Ur.presentationTimestamp,ne.endTimestamp=qn.presentationTimestamp+qn.duration,this.currentFragment.implicitBaseDataOffset=re}break;case"udta":{const f=this.iterateContiguousBoxes(e.slice(i,n.contentSize));for(const{boxInfo:I,slice:E}of f){if(I.name!=="meta"&&!this.currentTrack){const v=E.filePos;(w=this.metadataTags).raw??(w.raw={}),I.name[0]===""?(m=this.metadataTags.raw)[k=I.name]??(m[k]=Ve(E)):(T=this.metadataTags.raw)[b=I.name]??(T[b]=$(E,I.contentSize)),E.filePos=v}switch(I.name){case"meta":E.skip(-I.headerSize),this.traverseBox(E);break;case"nam":case"name":this.currentTrack?this.currentTrack.name=Be.decode($(E,I.contentSize)):(y=this.metadataTags).title??(y.title=Ve(E));break;case"des":this.currentTrack||((S=this.metadataTags).description??(S.description=Ve(E)));break;case"ART":this.currentTrack||((x=this.metadataTags).artist??(x.artist=Ve(E)));break;case"alb":this.currentTrack||((_=this.metadataTags).album??(_.album=Ve(E)));break;case"albr":this.currentTrack||((P=this.metadataTags).albumArtist??(P.albumArtist=Ve(E)));break;case"gen":this.currentTrack||((M=this.metadataTags).genre??(M.genre=Ve(E)));break;case"day":if(!this.currentTrack){const v=new Date(Ve(E));Number.isNaN(v.getTime())||((F=this.metadataTags).date??(F.date=v))}break;case"cmt":this.currentTrack||((z=this.metadataTags).comment??(z.comment=Ve(E)));break;case"lyr":this.currentTrack||((O=this.metadataTags).lyrics??(O.lyrics=Ve(E)));break}}}break;case"meta":{if(this.currentTrack)break;const I=R(e)!==0;this.currentMetadataKeys=new Map,I?this.readContiguousBoxes(e.slice(i,n.contentSize)):this.readContiguousBoxes(e.slice(i+4,n.contentSize-4)),this.currentMetadataKeys=null}break;case"keys":{if(!this.currentMetadataKeys)break;e.skip(4);const f=R(e);for(let I=0;I<f;I++){const E=R(e);e.skip(4);const v=Be.decode($(e,E-8));this.currentMetadataKeys.set(I+1,v)}}break;case"ilst":{if(!this.currentMetadataKeys)break;const f=this.iterateContiguousBoxes(e.slice(i,n.contentSize));for(const{boxInfo:I,slice:E}of f){let v=I.name;const H=(v.charCodeAt(0)<<24)+(v.charCodeAt(1)<<16)+(v.charCodeAt(2)<<8)+v.charCodeAt(3);this.currentMetadataKeys.has(H)&&(v=this.currentMetadataKeys.get(H));const A=Ra(E);switch((L=this.metadataTags).raw??(L.raw={}),(X=this.metadataTags.raw)[v]??(X[v]=A),v){case"nam":case"titl":case"com.apple.quicktime.title":case"title":typeof A=="string"&&((se=this.metadataTags).title??(se.title=A));break;case"des":case"desc":case"dscp":case"com.apple.quicktime.description":case"description":typeof A=="string"&&((ve=this.metadataTags).description??(ve.description=A));break;case"ART":case"com.apple.quicktime.artist":case"artist":typeof A=="string"&&((oe=this.metadataTags).artist??(oe.artist=A));break;case"alb":case"albm":case"com.apple.quicktime.album":case"album":typeof A=="string"&&((he=this.metadataTags).album??(he.album=A));break;case"aART":case"album_artist":typeof A=="string"&&((ce=this.metadataTags).albumArtist??(ce.albumArtist=A));break;case"cmt":case"com.apple.quicktime.comment":case"comment":typeof A=="string"&&((Ee=this.metadataTags).comment??(Ee.comment=A));break;case"gen":case"gnre":case"com.apple.quicktime.genre":case"genre":typeof A=="string"&&((Ce=this.metadataTags).genre??(Ce.genre=A));break;case"lyr":case"lyrics":typeof A=="string"&&((it=this.metadataTags).lyrics??(it.lyrics=A));break;case"day":case"rldt":case"com.apple.quicktime.creationdate":case"date":if(typeof A=="string"){const D=new Date(A);Number.isNaN(D.getTime())||((Oe=this.metadataTags).date??(Oe.date=D))}break;case"covr":case"com.apple.quicktime.artwork":A instanceof Ut?((jt=this.metadataTags).images??(jt.images=[]),this.metadataTags.images.push({data:A.data,kind:"coverFront",mimeType:A.mimeType})):A instanceof Uint8Array&&((Kt=this.metadataTags).images??(Kt.images=[]),this.metadataTags.images.push({data:A,kind:"coverFront",mimeType:"image/*"}));break;case"track":if(typeof A=="string"){const D=A.split("/"),G=Number.parseInt(D[0],10),K=D[1]&&Number.parseInt(D[1],10);Number.isInteger(G)&&G>0&&((Qt=this.metadataTags).trackNumber??(Qt.trackNumber=G)),K&&Number.isInteger(K)&&K>0&&((Gt=this.metadataTags).tracksTotal??(Gt.tracksTotal=K))}break;case"trkn":if(A instanceof Uint8Array&&A.length>=6){const D=Te(A),G=D.getUint16(2,!1),K=D.getUint16(4,!1);G>0&&((Xt=this.metadataTags).trackNumber??(Xt.trackNumber=G)),K>0&&((Yt=this.metadataTags).tracksTotal??(Yt.tracksTotal=K))}break;case"disc":case"disk":if(A instanceof Uint8Array&&A.length>=6){const D=Te(A),G=D.getUint16(2,!1),K=D.getUint16(4,!1);G>0&&((N=this.metadataTags).discNumber??(N.discNumber=G)),K>0&&((Q=this.metadataTags).discsTotal??(Q.discsTotal=K))}break}}}break}return e.filePos=s,!0}}class ns{constructor(e){this.internalTrack=e,this.packetToSampleIndex=new WeakMap,this.packetToFragmentLocation=new WeakMap}getId(){return this.internalTrack.id}getCodec(){throw new Error("Not implemented on base class.")}getInternalCodecId(){return this.internalTrack.internalCodecId}getName(){return this.internalTrack.name}getLanguageCode(){return this.internalTrack.languageCode}getTimeResolution(){return this.internalTrack.timescale}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return((e==null?void 0:e.timestamp)??0)+((e==null?void 0:e.duration)??0)}async getFirstTimestamp(){const e=await this.getFirstPacket({metadataOnly:!0});return(e==null?void 0:e.timestamp)??0}async getFirstPacket(e){const r=await this.fetchPacketForSampleIndex(0,e);return r||!this.internalTrack.demuxer.isFragmented?r:this.performFragmentedLookup(()=>{const n=this.internalTrack.demuxer.fragments[0]??null;if(n!=null&&n.isKnownToBeFirstFragment){let i=n;for(;i;){if(i.trackData.get(this.internalTrack.id))return{fragmentIndex:fe(this.internalTrack.fragments,i.moofOffset,a=>a.moofOffset),sampleIndex:0,correctSampleFound:!0};i=i.nextFragment}}return{fragmentIndex:-1,sampleIndex:-1,correctSampleFound:!1}},-1/0,1/0,e)}mapTimestampIntoTimescale(e){return vr(e*this.internalTrack.timescale,14)+this.internalTrack.editListOffset}async getPacket(e,r){const n=this.mapTimestampIntoTimescale(e),i=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),s=si(i,n),a=await this.fetchPacketForSampleIndex(s,r);return!oi(i)||!this.internalTrack.demuxer.isFragmented?a:this.performFragmentedLookup(()=>this.findSampleInFragmentsForTimestamp(n),n,n,r)}async getNextPacket(e,r){const n=this.packetToSampleIndex.get(e);if(n!==void 0)return this.fetchPacketForSampleIndex(n+1,r);const i=this.packetToFragmentLocation.get(e);if(i===void 0)throw new Error("Packet was not created from this track.");const s=i.fragment.trackData.get(this.internalTrack.id),a=fe(this.internalTrack.fragments,i.fragment.moofOffset,o=>o.moofOffset);return h(a!==-1),this.performFragmentedLookup(()=>{if(i.sampleIndex+1<s.samples.length)return{fragmentIndex:a,sampleIndex:i.sampleIndex+1,correctSampleFound:!0};{let o=i.fragment;for(;o.nextFragment;)if(o=o.nextFragment,o.trackData.get(this.internalTrack.id)){const l=fe(this.internalTrack.fragments,o.moofOffset,u=>u.moofOffset);return h(l!==-1),{fragmentIndex:l,sampleIndex:0,correctSampleFound:!0}}return{fragmentIndex:a,sampleIndex:-1,correctSampleFound:!1}}},-1/0,1/0,r)}async getKeyPacket(e,r){const n=this.mapTimestampIntoTimescale(e),i=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),s=si(i,n),a=s===-1?-1:Va(i,s),o=await this.fetchPacketForSampleIndex(a,r);return!oi(i)||!this.internalTrack.demuxer.isFragmented?o:this.performFragmentedLookup(()=>this.findKeySampleInFragmentsForTimestamp(n),n,n,r)}async getNextKeyPacket(e,r){const n=this.packetToSampleIndex.get(e);if(n!==void 0){const o=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),c=Ua(o,n);return this.fetchPacketForSampleIndex(c,r)}const i=this.packetToFragmentLocation.get(e);if(i===void 0)throw new Error("Packet was not created from this track.");const s=i.fragment.trackData.get(this.internalTrack.id),a=fe(this.internalTrack.fragments,i.fragment.moofOffset,o=>o.moofOffset);return h(a!==-1),this.performFragmentedLookup(()=>{const o=s.samples.findIndex((c,l)=>c.isKeyFrame&&l>i.sampleIndex);if(o!==-1)return{fragmentIndex:a,sampleIndex:o,correctSampleFound:!0};{let c=i.fragment;for(;c.nextFragment;){c=c.nextFragment;const l=c.trackData.get(this.internalTrack.id);if(l&&l.firstKeyFrameTimestamp!==null){const u=fe(this.internalTrack.fragments,c.moofOffset,p=>p.moofOffset);h(u!==-1);const d=l.samples.findIndex(p=>p.isKeyFrame);return h(d!==-1),{fragmentIndex:u,sampleIndex:d,correctSampleFound:!0}}}return{fragmentIndex:a,sampleIndex:-1,correctSampleFound:!1}}},-1/0,1/0,r)}async fetchPacketForSampleIndex(e,r){if(e===-1)return null;const n=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),i=Oa(n,e);if(!i)return null;let s;if(r.metadataOnly)s=ze;else{let l=this.internalTrack.demuxer.reader.requestSlice(i.sampleOffset,i.sampleSize);l instanceof Promise&&(l=await l),h(l),s=$(l,i.sampleSize)}const a=(i.presentationTimestamp-this.internalTrack.editListOffset)/this.internalTrack.timescale,o=i.duration/this.internalTrack.timescale,c=new ie(s,i.isKeyFrame?"key":"delta",a,o,e,i.sampleSize);return this.packetToSampleIndex.set(c,e),c}async fetchPacketInFragment(e,r,n){if(r===-1)return null;const s=e.trackData.get(this.internalTrack.id).samples[r];h(s);let a;if(n.metadataOnly)a=ze;else{let u=this.internalTrack.demuxer.reader.requestSlice(s.byteOffset,s.byteSize);u instanceof Promise&&(u=await u),h(u),a=$(u,s.byteSize)}const o=(s.presentationTimestamp-this.internalTrack.editListOffset)/this.internalTrack.timescale,c=s.duration/this.internalTrack.timescale,l=new ie(a,s.isKeyFrame?"key":"delta",o,c,e.moofOffset+r,s.byteSize);return this.packetToFragmentLocation.set(l,{fragment:e,sampleIndex:r}),l}findSampleInFragmentsForTimestamp(e){const r=te(this.internalTrack.fragments,e,s=>s.trackData.get(this.internalTrack.id).startTimestamp);let n=-1,i=!1;if(r!==-1){const a=this.internalTrack.fragments[r].trackData.get(this.internalTrack.id),o=te(a.presentationTimestamps,e,c=>c.presentationTimestamp);h(o!==-1),n=a.presentationTimestamps[o].sampleIndex,i=e<a.endTimestamp}return{fragmentIndex:r,sampleIndex:n,correctSampleFound:i}}findKeySampleInFragmentsForTimestamp(e){const r=te(this.internalTrack.fragmentsWithKeyFrame,e,a=>a.trackData.get(this.internalTrack.id).startTimestamp);let n=-1,i=-1,s=!1;if(r!==-1){const a=this.internalTrack.fragmentsWithKeyFrame[r];n=fe(this.internalTrack.fragments,a.moofOffset,u=>u.moofOffset),h(n!==-1);const o=a.trackData.get(this.internalTrack.id),c=zi(o.presentationTimestamps,u=>o.samples[u.sampleIndex].isKeyFrame&&u.presentationTimestamp<=e);h(c!==-1),i=o.presentationTimestamps[c].sampleIndex,s=e<o.endTimestamp}return{fragmentIndex:n,sampleIndex:i,correctSampleFound:s}}async performFragmentedLookup(e,r,n,i){const s=this.internalTrack.demuxer,a=await s.fragmentLookupMutex.acquire();try{const{fragmentIndex:o,sampleIndex:c,correctSampleFound:l}=e();if(l){const b=this.internalTrack.fragments[o];return this.fetchPacketInFragment(b,c,i)}let u=null,d=o,p=c;const g=this.internalTrack.fragmentLookupTable?te(this.internalTrack.fragmentLookupTable,r,b=>b.timestamp):-1,w=g!==-1?this.internalTrack.fragmentLookupTable[g]:null;let m,k=!1;if(o===-1)m=(w==null?void 0:w.moofOffset)??0,k=m===0;else{const b=this.internalTrack.fragments[o];!w||b.moofOffset>=w.moofOffset?(m=b.moofOffset+b.moofSize,u=b):m=w.moofOffset}for(;;){if(u){const x=u.trackData.get(this.internalTrack.id);if(x&&x.startTimestamp>n)break;if(u.nextFragment){m=u.nextFragment.moofOffset+u.nextFragment.moofSize,u=u.nextFragment;continue}}let b=s.reader.requestSliceRange(m,Ne,ut);if(b instanceof Promise&&(b=await b),!b)break;const y=m,S=Xe(b);if(!S)break;if(S.name==="moof"){const x=fe(s.fragments,y,z=>z.moofOffset);let _;x===-1?_=await s.readFragment(y):_=s.fragments[x],u&&(u.nextFragment=_),u=_,k&&(_.isKnownToBeFirstFragment=!0,k=!1);const{fragmentIndex:P,sampleIndex:M,correctSampleFound:F}=e();if(F){const z=this.internalTrack.fragments[P];return this.fetchPacketInFragment(z,M,i)}P!==-1&&(d=P,p=M)}m=y+S.totalSize}const T=d!==-1?this.internalTrack.fragments[d]:null;if(w&&(!T||T.moofOffset<w.moofOffset)){const b=this.internalTrack.fragmentLookupTable[g-1],y=(b==null?void 0:b.timestamp)??-1/0;return this.performFragmentedLookup(e,y,n,i)}return T?this.fetchPacketInFragment(T,p,i):null}finally{a()}}}class Ma extends ns{constructor(e){super(e),this.decoderConfigPromise=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getCodedWidth(){return this.internalTrack.info.width}getCodedHeight(){return this.internalTrack.info.height}getRotation(){return this.internalTrack.rotation}async getColorSpace(){var e,r,n,i;return{primaries:(e=this.internalTrack.info.colorSpace)==null?void 0:e.primaries,transfer:(r=this.internalTrack.info.colorSpace)==null?void 0:r.transfer,matrix:(n=this.internalTrack.info.colorSpace)==null?void 0:n.matrix,fullRange:(i=this.internalTrack.info.colorSpace)==null?void 0:i.fullRange}}async canBeTransparent(){return!1}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfigPromise??(this.decoderConfigPromise=(async()=>{if(this.internalTrack.info.codec==="vp9"&&!this.internalTrack.info.vp9CodecInfo){const e=await this.getFirstPacket({});this.internalTrack.info.vp9CodecInfo=e&&Qi(e.data)}else if(this.internalTrack.info.codec==="av1"&&!this.internalTrack.info.av1CodecInfo){const e=await this.getFirstPacket({});this.internalTrack.info.av1CodecInfo=e&&Xi(e.data)}return{codec:Oi(this.internalTrack.info),codedWidth:this.internalTrack.info.width,codedHeight:this.internalTrack.info.height,description:this.internalTrack.info.codecDescription??void 0,colorSpace:this.internalTrack.info.colorSpace??void 0}})()):null}}class Na extends ns{constructor(e){super(e),this.decoderConfig=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getNumberOfChannels(){return this.internalTrack.info.numberOfChannels}getSampleRate(){return this.internalTrack.info.sampleRate}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfig??(this.decoderConfig={codec:Vi(this.internalTrack.info),numberOfChannels:this.internalTrack.info.numberOfChannels,sampleRate:this.internalTrack.info.sampleRate,description:this.internalTrack.info.codecDescription??void 0}):null}}const si=(t,e)=>{if(t.presentationTimestamps){const r=te(t.presentationTimestamps,e,n=>n.presentationTimestamp);return r===-1?-1:t.presentationTimestamps[r].sampleIndex}else{const r=te(t.sampleTimingEntries,e,i=>i.startDecodeTimestamp);if(r===-1)return-1;const n=t.sampleTimingEntries[r];return n.startIndex+Math.min(Math.floor((e-n.startDecodeTimestamp)/n.delta),n.count-1)}},Oa=(t,e)=>{const r=te(t.sampleTimingEntries,e,T=>T.startIndex),n=t.sampleTimingEntries[r];if(!n||n.startIndex+n.count<=e)return null;let s=n.startDecodeTimestamp+(e-n.startIndex)*n.delta;const a=te(t.sampleCompositionTimeOffsets,e,T=>T.startIndex),o=t.sampleCompositionTimeOffsets[a];o&&e-o.startIndex<o.count&&(s+=o.offset);const c=t.sampleSizes[Math.min(e,t.sampleSizes.length-1)],l=te(t.sampleToChunk,e,T=>T.startSampleIndex),u=t.sampleToChunk[l];h(u);const d=u.startChunkIndex+Math.floor((e-u.startSampleIndex)/u.samplesPerChunk),p=t.chunkOffsets[d],g=u.startSampleIndex+(d-u.startChunkIndex)*u.samplesPerChunk;let w=0,m=p;if(t.sampleSizes.length===1)m+=c*(e-g),w+=c*u.samplesPerChunk;else for(let T=g;T<g+u.samplesPerChunk;T++){const b=t.sampleSizes[T];T<e&&(m+=b),w+=b}let k=n.delta;if(t.presentationTimestamps){const T=t.presentationTimestampIndexMap[e];h(T!==void 0),T<t.presentationTimestamps.length-1&&(k=t.presentationTimestamps[T+1].presentationTimestamp-s)}return{presentationTimestamp:s,duration:k,sampleOffset:m,sampleSize:c,chunkOffset:p,chunkSize:w,isKeyFrame:t.keySampleIndices?fe(t.keySampleIndices,e,T=>T)!==-1:!0}},Va=(t,e)=>{if(!t.keySampleIndices)return e;const r=te(t.keySampleIndices,e,n=>n);return t.keySampleIndices[r]??-1},Ua=(t,e)=>{if(!t.keySampleIndices)return e+1;const r=te(t.keySampleIndices,e,n=>n);return t.keySampleIndices[r+1]??-1},ai=(t,e)=>{t.startTimestamp+=e,t.endTimestamp+=e;for(const r of t.samples)r.presentationTimestamp+=e;for(const r of t.presentationTimestamps)r.presentationTimestamp+=e},Wa=t=>{const[e,,,r]=t,n=Math.hypot(e,r),i=e/n,s=r/n,a=-Math.atan2(s,i)*(180/Math.PI);return Number.isFinite(a)?a:0},oi=t=>t.sampleSizes.length===0;/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */var C;(function(t){t[t.EBML=440786851]="EBML",t[t.EBMLVersion=17030]="EBMLVersion",t[t.EBMLReadVersion=17143]="EBMLReadVersion",t[t.EBMLMaxIDLength=17138]="EBMLMaxIDLength",t[t.EBMLMaxSizeLength=17139]="EBMLMaxSizeLength",t[t.DocType=17026]="DocType",t[t.DocTypeVersion=17031]="DocTypeVersion",t[t.DocTypeReadVersion=17029]="DocTypeReadVersion",t[t.Void=236]="Void",t[t.Segment=408125543]="Segment",t[t.SeekHead=290298740]="SeekHead",t[t.Seek=19899]="Seek",t[t.SeekID=21419]="SeekID",t[t.SeekPosition=21420]="SeekPosition",t[t.Duration=17545]="Duration",t[t.Info=357149030]="Info",t[t.TimestampScale=2807729]="TimestampScale",t[t.MuxingApp=19840]="MuxingApp",t[t.WritingApp=22337]="WritingApp",t[t.Tracks=374648427]="Tracks",t[t.TrackEntry=174]="TrackEntry",t[t.TrackNumber=215]="TrackNumber",t[t.TrackUID=29637]="TrackUID",t[t.TrackType=131]="TrackType",t[t.FlagEnabled=185]="FlagEnabled",t[t.FlagDefault=136]="FlagDefault",t[t.FlagForced=21930]="FlagForced",t[t.FlagLacing=156]="FlagLacing",t[t.Name=21358]="Name",t[t.Language=2274716]="Language",t[t.LanguageBCP47=2274717]="LanguageBCP47",t[t.CodecID=134]="CodecID",t[t.CodecPrivate=25506]="CodecPrivate",t[t.CodecDelay=22186]="CodecDelay",t[t.SeekPreRoll=22203]="SeekPreRoll",t[t.DefaultDuration=2352003]="DefaultDuration",t[t.Video=224]="Video",t[t.PixelWidth=176]="PixelWidth",t[t.PixelHeight=186]="PixelHeight",t[t.AlphaMode=21440]="AlphaMode",t[t.Audio=225]="Audio",t[t.SamplingFrequency=181]="SamplingFrequency",t[t.Channels=159]="Channels",t[t.BitDepth=25188]="BitDepth",t[t.SimpleBlock=163]="SimpleBlock",t[t.BlockGroup=160]="BlockGroup",t[t.Block=161]="Block",t[t.BlockAdditions=30113]="BlockAdditions",t[t.BlockMore=166]="BlockMore",t[t.BlockAdditional=165]="BlockAdditional",t[t.BlockAddID=238]="BlockAddID",t[t.BlockDuration=155]="BlockDuration",t[t.ReferenceBlock=251]="ReferenceBlock",t[t.Cluster=524531317]="Cluster",t[t.Timestamp=231]="Timestamp",t[t.Cues=475249515]="Cues",t[t.CuePoint=187]="CuePoint",t[t.CueTime=179]="CueTime",t[t.CueTrackPositions=183]="CueTrackPositions",t[t.CueTrack=247]="CueTrack",t[t.CueClusterPosition=241]="CueClusterPosition",t[t.Colour=21936]="Colour",t[t.MatrixCoefficients=21937]="MatrixCoefficients",t[t.TransferCharacteristics=21946]="TransferCharacteristics",t[t.Primaries=21947]="Primaries",t[t.Range=21945]="Range",t[t.Projection=30320]="Projection",t[t.ProjectionType=30321]="ProjectionType",t[t.ProjectionPoseRoll=30325]="ProjectionPoseRoll",t[t.Attachments=423732329]="Attachments",t[t.AttachedFile=24999]="AttachedFile",t[t.FileDescription=18046]="FileDescription",t[t.FileName=18030]="FileName",t[t.FileMediaType=18016]="FileMediaType",t[t.FileData=18012]="FileData",t[t.FileUID=18094]="FileUID",t[t.Chapters=272869232]="Chapters",t[t.Tags=307544935]="Tags",t[t.Tag=29555]="Tag",t[t.Targets=25536]="Targets",t[t.TargetTypeValue=26826]="TargetTypeValue",t[t.TargetType=25546]="TargetType",t[t.TagTrackUID=25541]="TagTrackUID",t[t.TagEditionUID=25545]="TagEditionUID",t[t.TagChapterUID=25540]="TagChapterUID",t[t.TagAttachmentUID=25542]="TagAttachmentUID",t[t.SimpleTag=26568]="SimpleTag",t[t.TagName=17827]="TagName",t[t.TagLanguage=17530]="TagLanguage",t[t.TagString=17543]="TagString",t[t.TagBinary=17541]="TagBinary",t[t.ContentEncodings=28032]="ContentEncodings",t[t.ContentEncoding=25152]="ContentEncoding",t[t.ContentEncodingOrder=20529]="ContentEncodingOrder",t[t.ContentEncodingScope=20530]="ContentEncodingScope",t[t.ContentCompression=20532]="ContentCompression",t[t.ContentCompAlgo=16980]="ContentCompAlgo",t[t.ContentCompSettings=16981]="ContentCompSettings",t[t.ContentEncryption=20533]="ContentEncryption"})(C||(C={}));const La=[C.EBML,C.Segment],fr=[C.SeekHead,C.Info,C.Cluster,C.Tracks,C.Cues,C.Attachments,C.Chapters,C.Tags],mn=[...La,...fr],pn=8,Ie=2,tt=2*pn,is=t=>{const e=U(t);if(t.skip(-1),e===0)return null;let r=1,n=128;for(;!(e&n);)r++,n>>=1;return r},ir=t=>{const e=U(t);if(e===0)return null;let r=1,n=128;for(;!(e&n);)r++,n>>=1;let i=e&n-1;for(let s=1;s<r;s++)i*=256,i+=U(t);return i},Z=(t,e)=>{if(e<1||e>8)throw new Error("Bad unsigned int size "+e);let r=0;for(let n=0;n<e;n++)r*=256,r+=U(t);return r},Ha=(t,e)=>{if(e<1)throw new Error("Bad unsigned int size "+e);let r=0n;for(let n=0;n<e;n++)r<<=8n,r+=BigInt(U(t));return r},qa=(t,e)=>{let r=Z(t,e);return r&1<<e*8-1&&(r-=2**(e*8)),r},zn=t=>{const e=is(t);return e===null?null:Z(t,e)},ss=t=>{let e=U(t);return e===255?e=null:(t.skip(-1),e=ir(t),e===72057594037927940&&(e=null)),e},Je=t=>{const e=zn(t);if(e===null)return null;const r=ss(t);return{id:e,size:r}},Rt=(t,e)=>{const r=$(t,e);let n=0;for(;n<e&&r[n]!==0;)n+=1;return String.fromCharCode(...r.subarray(0,n))},tr=(t,e)=>{const r=$(t,e);let n=0;for(;n<e&&r[n]!==0;)n+=1;return Be.decode(r.subarray(0,n))},Gr=(t,e)=>{if(e===0)return 0;if(e!==4&&e!==8)throw new Error("Bad float size "+e);return e===4?Jo(t):ks(t)},gn=async(t,e,r,n)=>{const i=new Set(r);let s=e;for(;n===null||s<n;){let a=t.requestSliceRange(s,Ie,tt);if(a instanceof Promise&&(a=await a),!a)break;const o=Je(a);if(!o)break;if(i.has(o.id))return{pos:s,found:!0};ct(o.size),s=a.filePos+o.size}return{pos:n!==null&&n>s?n:s,found:!1}},as=async(t,e,r,n)=>{const s=new Set(r);let a=e;for(;a<n;){let o=t.requestSliceRange(a,0,Math.min(65536,n-a));if(o instanceof Promise&&(o=await o),!o||o.length<pn)break;for(let c=0;c<o.length-pn;c++){o.filePos=a;const l=zn(o);if(l!==null&&s.has(l))return a;a++}}return null},Ue={avc:"V_MPEG4/ISO/AVC",hevc:"V_MPEGH/ISO/HEVC",vp8:"V_VP8",vp9:"V_VP9",av1:"V_AV1",aac:"A_AAC",mp3:"A_MPEG/L3",opus:"A_OPUS",vorbis:"A_VORBIS",flac:"A_FLAC","pcm-u8":"A_PCM/INT/LIT","pcm-s16":"A_PCM/INT/LIT","pcm-s16be":"A_PCM/INT/BIG","pcm-s24":"A_PCM/INT/LIT","pcm-s24be":"A_PCM/INT/BIG","pcm-s32":"A_PCM/INT/LIT","pcm-s32be":"A_PCM/INT/BIG","pcm-f32":"A_PCM/FLOAT/IEEE","pcm-f64":"A_PCM/FLOAT/IEEE",webvtt:"S_TEXT/WEBVTT"};function ct(t){if(t===null)throw new Error("Undefined element size is used in a place where it is not supported.")}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const $a=t=>{let r=(t.hasVideo?"video/":t.hasAudio?"audio/":"application/")+(t.isWebM?"webm":"x-matroska");if(t.codecStrings.length>0){const n=[...new Set(t.codecStrings.filter(Boolean))];r+=`; codecs="${n.join(", ")}"`}return r};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */var Ye;(function(t){t[t.None=0]="None",t[t.Xiph=1]="Xiph",t[t.FixedSize=2]="FixedSize",t[t.Ebml=3]="Ebml"})(Ye||(Ye={}));var Fr;(function(t){t[t.Block=1]="Block",t[t.Private=2]="Private",t[t.Next=4]="Next"})(Fr||(Fr={}));var or;(function(t){t[t.Zlib=0]="Zlib",t[t.Bzlib=1]="Bzlib",t[t.lzo1x=2]="lzo1x",t[t.HeaderStripping=3]="HeaderStripping"})(or||(or={}));const Xr=[{id:C.SeekHead,flag:"seekHeadSeen"},{id:C.Info,flag:"infoSeen"},{id:C.Tracks,flag:"tracksSeen"},{id:C.Cues,flag:"cuesSeen"}],os=10*2**20;class ja extends _t{constructor(e){super(e),this.readMetadataPromise=null,this.segments=[],this.currentSegment=null,this.currentTrack=null,this.currentCluster=null,this.currentBlock=null,this.currentBlockAdditional=null,this.currentCueTime=null,this.currentDecodingInstruction=null,this.currentTagTargetIsMovie=!0,this.currentSimpleTagName=null,this.currentAttachedFile=null,this.isWebM=!1,this.reader=e._reader}async computeDuration(){const e=await this.getTracks(),r=await Promise.all(e.map(n=>n.computeDuration()));return Math.max(0,...r)}async getTracks(){return await this.readMetadata(),this.segments.flatMap(e=>e.tracks.map(r=>r.inputTrack))}async getMimeType(){await this.readMetadata();const e=await this.getTracks(),r=await Promise.all(e.map(n=>n.getCodecParameterString()));return $a({isWebM:this.isWebM,hasVideo:this.segments.some(n=>n.tracks.some(i=>{var s;return((s=i.info)==null?void 0:s.type)==="video"})),hasAudio:this.segments.some(n=>n.tracks.some(i=>{var s;return((s=i.info)==null?void 0:s.type)==="audio"})),codecStrings:r.filter(Boolean)})}async getMetadataTags(){await this.readMetadata();for(const r of this.segments)r.metadataTagsCollected||(this.reader.fileSize!==null&&await this.loadSegmentMetadata(r),r.metadataTagsCollected=!0);let e={};for(const r of this.segments)e={...e,...r.metadataTags};return e}readMetadata(){return this.readMetadataPromise??(this.readMetadataPromise=(async()=>{let e=0;for(;;){let r=this.reader.requestSliceRange(e,Ie,tt);if(r instanceof Promise&&(r=await r),!r)break;const n=Je(r);if(!n)break;const i=n.id;let s=n.size;const a=r.filePos;if(i===C.EBML){ct(s);let o=this.reader.requestSlice(a,s);if(o instanceof Promise&&(o=await o),!o)break;this.readContiguousElements(o)}else if(i===C.Segment){if(await this.readSegment(a,s),s===null||this.reader.fileSize===null)break}else if(i===C.Cluster){if(this.reader.fileSize===null)break;s===null&&(s=(await gn(this.reader,a,mn,this.reader.fileSize)).pos-a);const o=ue(this.segments);o&&(o.elementEndPos=a+s)}ct(s),e=a+s}})())}async readSegment(e,r){this.currentSegment={seekHeadSeen:!1,infoSeen:!1,tracksSeen:!1,cuesSeen:!1,tagsSeen:!1,attachmentsSeen:!1,timestampScale:-1,timestampFactor:-1,duration:-1,seekEntries:[],tracks:[],cuePoints:[],dataStartPos:e,elementEndPos:r===null?null:e+r,clusterSeekStartPos:e,clusters:[],clusterLookupMutex:new wt,metadataTags:{},metadataTagsCollected:!1},this.segments.push(this.currentSegment);let n=e;for(;this.currentSegment.elementEndPos===null||n<this.currentSegment.elementEndPos;){let c=this.reader.requestSliceRange(n,Ie,tt);if(c instanceof Promise&&(c=await c),!c)break;const l=n,u=Je(c);if(!u||!fr.includes(u.id)&&u.id!==C.Void){const m=await as(this.reader,l,fr,Math.min(this.currentSegment.elementEndPos??1/0,l+os));if(m){n=m;continue}else break}const{id:d,size:p}=u,g=c.filePos,w=Xr.findIndex(m=>m.id===d);if(w!==-1){const m=Xr[w].flag;this.currentSegment[m]=!0,ct(p);let k=this.reader.requestSlice(g,p);k instanceof Promise&&(k=await k),k&&this.readContiguousElements(k)}else if(d===C.Tags||d===C.Attachments){d===C.Tags?this.currentSegment.tagsSeen=!0:this.currentSegment.attachmentsSeen=!0,ct(p);let m=this.reader.requestSlice(g,p);m instanceof Promise&&(m=await m),m&&this.readContiguousElements(m)}else if(d===C.Cluster){this.currentSegment.clusterSeekStartPos=l;break}if(p===null)break;n=g+p}if(this.currentSegment.seekEntries.sort((c,l)=>c.segmentPosition-l.segmentPosition),this.reader.fileSize!==null)for(const c of this.currentSegment.seekEntries){const l=Xr.find(m=>m.id===c.id);if(!l||this.currentSegment[l.flag])continue;let u=this.reader.requestSliceRange(e+c.segmentPosition,Ie,tt);if(u instanceof Promise&&(u=await u),!u)continue;const d=Je(u);if(!d)continue;const{id:p,size:g}=d;if(p!==l.id)continue;ct(g),this.currentSegment[l.flag]=!0;let w=this.reader.requestSlice(u.filePos,g);w instanceof Promise&&(w=await w),w&&this.readContiguousElements(w)}this.currentSegment.timestampScale===-1&&(this.currentSegment.timestampScale=1e6,this.currentSegment.timestampFactor=1e9/1e6),this.currentSegment.tracks.sort((c,l)=>Number(l.isDefault)-Number(c.isDefault)),this.currentSegment.cuePoints.sort((c,l)=>c.clusterPosition-l.clusterPosition);const i=this.currentSegment.tracks.map(c=>c.id),s=new Set;let a=null,o=null;for(const c of this.currentSegment.cuePoints){if(c.clusterPosition!==a){for(const u of s)h(o),this.currentSegment.tracks.find(p=>p.id===u).cuePoints.push(o);for(const u of i)s.add(u)}if(o=c,!s.has(c.trackId))continue;this.currentSegment.tracks.find(u=>u.id===c.trackId).cuePoints.push(c),s.delete(c.trackId),a=c.clusterPosition}for(const c of s)h(o),this.currentSegment.tracks.find(u=>u.id===c).cuePoints.push(o);for(const c of this.currentSegment.tracks)c.cuePoints.sort((l,u)=>l.time-u.time);this.currentSegment=null}async readCluster(e,r){let n=this.reader.requestSliceRange(e,Ie,tt);n instanceof Promise&&(n=await n),h(n);const i=e,s=Je(n);h(s);const a=s.id;let o=s.size;const c=n.filePos;o===null&&(o=(await gn(this.reader,c,mn,r.elementEndPos)).pos-c),h(a===C.Cluster);let l=this.reader.requestSlice(c,o);l instanceof Promise&&(l=await l);const u={segment:r,elementStartPos:i,elementEndPos:c+o,dataStartPos:c,timestamp:-1,trackData:new Map,nextCluster:null,isKnownToBeFirstCluster:!1};this.currentCluster=u,l&&this.readContiguousElements(l);for(const[,d]of u.trackData){const p=d.track;h(d.blocks.length>0);let g=!1,w=!1;for(let b=0;b<d.blocks.length;b++){const y=d.blocks[b];y.timestamp+=u.timestamp,g||(g=y.referencedTimestamps.length>0),w||(w=y.lacing!==Ye.None)}g&&(d.blocks=Ga(d.blocks)),d.presentationTimestamps=d.blocks.map((b,y)=>({timestamp:b.timestamp,blockIndex:y})).sort((b,y)=>b.timestamp-y.timestamp);for(let b=0;b<d.presentationTimestamps.length;b++){const y=d.presentationTimestamps[b],S=d.blocks[y.blockIndex];if(d.firstKeyFrameTimestamp===null&&S.isKeyFrame&&(d.firstKeyFrameTimestamp=S.timestamp),b<d.presentationTimestamps.length-1){const x=d.presentationTimestamps[b+1];S.duration=x.timestamp-S.timestamp}else S.duration===0&&p.defaultDuration!=null&&S.lacing===Ye.None&&(S.duration=p.defaultDuration)}w&&(this.expandLacedBlocks(d.blocks,p),d.presentationTimestamps=d.blocks.map((b,y)=>({timestamp:b.timestamp,blockIndex:y})).sort((b,y)=>b.timestamp-y.timestamp));const m=d.blocks[d.presentationTimestamps[0].blockIndex],k=d.blocks[ue(d.presentationTimestamps).blockIndex];d.startTimestamp=m.timestamp,d.endTimestamp=k.timestamp+k.duration,pt(p.clusters,u,b=>b.elementStartPos),d.firstKeyFrameTimestamp!==null&&pt(p.clustersWithKeyFrame,u,b=>b.elementStartPos)}return pt(r.clusters,u,d=>d.elementStartPos),this.currentCluster=null,u}getTrackDataInCluster(e,r){let n=e.trackData.get(r);if(!n){const i=e.segment.tracks.find(s=>s.id===r);if(!i)return null;n={track:i,startTimestamp:0,endTimestamp:0,firstKeyFrameTimestamp:null,blocks:[],presentationTimestamps:[]},e.trackData.set(r,n)}return n}expandLacedBlocks(e,r){for(let n=0;n<e.length;n++){const i=e[n];if(i.lacing===Ye.None)continue;i.decoded||(i.data=this.decodeBlockData(r,i.data),i.decoded=!0);const s=$t.tempFromBytes(i.data),a=[],o=U(s)+1;switch(i.lacing){case Ye.Xiph:{let c=0;for(let l=0;l<o-1;l++){let u=0;for(;s.bufferPos<s.length;){const d=U(s);if(u+=d,d<255){a.push(u),c+=u;break}}}a.push(s.length-(s.bufferPos+c))}break;case Ye.FixedSize:{const c=s.length-1,l=Math.floor(c/o);for(let u=0;u<o;u++)a.push(l)}break;case Ye.Ebml:{const c=ir(s);h(c!==null);let l=c;a.push(l);let u=l;for(let d=1;d<o-1;d++){const p=s.bufferPos,g=ir(s);h(g!==null);const w=g,k=(1<<(s.bufferPos-p)*7-1)-1,T=w-k;l+=T,a.push(l),u+=l}a.push(s.length-(s.bufferPos+u))}break;default:h(!1)}h(a.length===o),e.splice(n,1);for(let c=0;c<o;c++){const l=a[c],u=$(s,l),d=i.duration||o*(r.defaultDuration??0),p=i.timestamp+d*c/o,g=d/o;e.splice(n+c,0,{timestamp:p,duration:g,isKeyFrame:i.isKeyFrame,referencedTimestamps:i.referencedTimestamps,data:u,lacing:Ye.None,decoded:!0,mainAdditional:i.mainAdditional})}n+=o,n--}}async loadSegmentMetadata(e){for(const r of e.seekEntries){if(!(r.id===C.Tags&&!e.tagsSeen)){if(!(r.id===C.Attachments&&!e.attachmentsSeen))continue}let n=this.reader.requestSliceRange(e.dataStartPos+r.segmentPosition,Ie,tt);if(n instanceof Promise&&(n=await n),!n)continue;const i=Je(n);if(!i||i.id!==r.id)continue;const{size:s}=i;ct(s),h(!this.currentSegment),this.currentSegment=e;let a=this.reader.requestSlice(n.filePos,s);a instanceof Promise&&(a=await a),a&&this.readContiguousElements(a),this.currentSegment=null,r.id===C.Tags?e.tagsSeen=!0:r.id===C.Attachments&&(e.attachmentsSeen=!0)}}readContiguousElements(e){const r=e.filePos;for(;e.filePos-r<=e.length-Ie&&this.traverseElement(e););}traverseElement(e){var a,o,c,l,u,d,p,g,w,m,k,T,b,y,S,x,_,P,M,F,z,O,L,X,se,ve,oe,he,ce,Ee,Ce,it,Oe,jt,Kt,Qt,Gt,Xt,Yt;const r=Je(e);if(!r)return!1;const{id:n,size:i}=r,s=e.filePos;switch(ct(i),n){case C.DocType:this.isWebM=Rt(e,i)==="webm";break;case C.Seek:{if(!this.currentSegment)break;const N={id:-1,segmentPosition:-1};this.currentSegment.seekEntries.push(N),this.readContiguousElements(e.slice(s,i)),(N.id===-1||N.segmentPosition===-1)&&this.currentSegment.seekEntries.pop()}break;case C.SeekID:{const N=(a=this.currentSegment)==null?void 0:a.seekEntries[this.currentSegment.seekEntries.length-1];if(!N)break;N.id=Z(e,i)}break;case C.SeekPosition:{const N=(o=this.currentSegment)==null?void 0:o.seekEntries[this.currentSegment.seekEntries.length-1];if(!N)break;N.segmentPosition=Z(e,i)}break;case C.TimestampScale:{if(!this.currentSegment)break;this.currentSegment.timestampScale=Z(e,i),this.currentSegment.timestampFactor=1e9/this.currentSegment.timestampScale}break;case C.Duration:{if(!this.currentSegment)break;this.currentSegment.duration=Gr(e,i)}break;case C.TrackEntry:{if(!this.currentSegment)break;if(this.currentTrack={id:-1,segment:this.currentSegment,demuxer:this,clusters:[],clustersWithKeyFrame:[],cuePoints:[],isDefault:!1,inputTrack:null,codecId:null,codecPrivate:null,defaultDuration:null,name:null,languageCode:Fe,decodingInstructions:[],info:null},this.readContiguousElements(e.slice(s,i)),this.currentTrack.decodingInstructions.some(N=>{var Q;return((Q=N.data)==null?void 0:Q.type)!=="decompress"||N.scope!==Fr.Block||N.data.algorithm!==or.HeaderStripping})&&(console.warn(`Track #${this.currentTrack.id} has an unsupported content encoding; dropping.`),this.currentTrack=null),this.currentTrack&&this.currentTrack.id!==-1&&this.currentTrack.codecId&&this.currentTrack.info){const N=this.currentTrack.codecId.indexOf("/"),Q=N===-1?this.currentTrack.codecId:this.currentTrack.codecId.slice(0,N);if(this.currentTrack.info.type==="video"&&this.currentTrack.info.width!==-1&&this.currentTrack.info.height!==-1){this.currentTrack.codecId===Ue.avc?(this.currentTrack.info.codec="avc",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):this.currentTrack.codecId===Ue.hevc?(this.currentTrack.info.codec="hevc",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):Q===Ue.vp8?this.currentTrack.info.codec="vp8":Q===Ue.vp9?this.currentTrack.info.codec="vp9":Q===Ue.av1&&(this.currentTrack.info.codec="av1");const f=this.currentTrack,I=new wr(this.input,new Ka(f));this.currentTrack.inputTrack=I,this.currentSegment.tracks.push(this.currentTrack)}else if(this.currentTrack.info.type==="audio"&&this.currentTrack.info.numberOfChannels!==-1&&this.currentTrack.info.sampleRate!==-1){Q===Ue.aac?(this.currentTrack.info.codec="aac",this.currentTrack.info.aacCodecInfo={isMpeg2:this.currentTrack.codecId.includes("MPEG2")},this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):this.currentTrack.codecId===Ue.mp3?this.currentTrack.info.codec="mp3":Q===Ue.opus?(this.currentTrack.info.codec="opus",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate,this.currentTrack.info.sampleRate=Vr):Q===Ue.vorbis?(this.currentTrack.info.codec="vorbis",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):Q===Ue.flac?(this.currentTrack.info.codec="flac",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):this.currentTrack.codecId==="A_PCM/INT/LIT"?this.currentTrack.info.bitDepth===8?this.currentTrack.info.codec="pcm-u8":this.currentTrack.info.bitDepth===16?this.currentTrack.info.codec="pcm-s16":this.currentTrack.info.bitDepth===24?this.currentTrack.info.codec="pcm-s24":this.currentTrack.info.bitDepth===32&&(this.currentTrack.info.codec="pcm-s32"):this.currentTrack.codecId==="A_PCM/INT/BIG"?this.currentTrack.info.bitDepth===8?this.currentTrack.info.codec="pcm-u8":this.currentTrack.info.bitDepth===16?this.currentTrack.info.codec="pcm-s16be":this.currentTrack.info.bitDepth===24?this.currentTrack.info.codec="pcm-s24be":this.currentTrack.info.bitDepth===32&&(this.currentTrack.info.codec="pcm-s32be"):this.currentTrack.codecId==="A_PCM/FLOAT/IEEE"&&(this.currentTrack.info.bitDepth===32?this.currentTrack.info.codec="pcm-f32":this.currentTrack.info.bitDepth===64&&(this.currentTrack.info.codec="pcm-f64"));const f=this.currentTrack,I=new rt(this.input,new Qa(f));this.currentTrack.inputTrack=I,this.currentSegment.tracks.push(this.currentTrack)}}this.currentTrack=null}break;case C.TrackNumber:{if(!this.currentTrack)break;this.currentTrack.id=Z(e,i)}break;case C.TrackType:{if(!this.currentTrack)break;const N=Z(e,i);N===1?this.currentTrack.info={type:"video",width:-1,height:-1,rotation:0,codec:null,codecDescription:null,colorSpace:null,alphaMode:!1}:N===2&&(this.currentTrack.info={type:"audio",numberOfChannels:-1,sampleRate:-1,bitDepth:-1,codec:null,codecDescription:null,aacCodecInfo:null})}break;case C.FlagEnabled:{if(!this.currentTrack)break;Z(e,i)||(this.currentSegment.tracks.pop(),this.currentTrack=null)}break;case C.FlagDefault:{if(!this.currentTrack)break;this.currentTrack.isDefault=!!Z(e,i)}break;case C.CodecID:{if(!this.currentTrack)break;this.currentTrack.codecId=Rt(e,i)}break;case C.CodecPrivate:{if(!this.currentTrack)break;this.currentTrack.codecPrivate=$(e,i)}break;case C.DefaultDuration:{if(!this.currentTrack)break;this.currentTrack.defaultDuration=this.currentTrack.segment.timestampFactor*Z(e,i)/1e9}break;case C.Name:{if(!this.currentTrack)break;this.currentTrack.name=tr(e,i)}break;case C.Language:{if(!this.currentTrack||this.currentTrack.languageCode!==Fe)break;this.currentTrack.languageCode=Rt(e,i),ur(this.currentTrack.languageCode)||(this.currentTrack.languageCode=Fe)}break;case C.LanguageBCP47:{if(!this.currentTrack)break;const Q=Rt(e,i).split("-")[0];Q?this.currentTrack.languageCode=Q:this.currentTrack.languageCode=Fe}break;case C.Video:{if(((l=(c=this.currentTrack)==null?void 0:c.info)==null?void 0:l.type)!=="video")break;this.readContiguousElements(e.slice(s,i))}break;case C.PixelWidth:{if(((d=(u=this.currentTrack)==null?void 0:u.info)==null?void 0:d.type)!=="video")break;this.currentTrack.info.width=Z(e,i)}break;case C.PixelHeight:{if(((g=(p=this.currentTrack)==null?void 0:p.info)==null?void 0:g.type)!=="video")break;this.currentTrack.info.height=Z(e,i)}break;case C.AlphaMode:{if(((m=(w=this.currentTrack)==null?void 0:w.info)==null?void 0:m.type)!=="video")break;this.currentTrack.info.alphaMode=Z(e,i)===1}break;case C.Colour:{if(((T=(k=this.currentTrack)==null?void 0:k.info)==null?void 0:T.type)!=="video")break;this.currentTrack.info.colorSpace={},this.readContiguousElements(e.slice(s,i))}break;case C.MatrixCoefficients:{if(((y=(b=this.currentTrack)==null?void 0:b.info)==null?void 0:y.type)!=="video"||!this.currentTrack.info.colorSpace)break;const N=Z(e,i),Q=Ai[N]??null;this.currentTrack.info.colorSpace.matrix=Q}break;case C.Range:{if(((x=(S=this.currentTrack)==null?void 0:S.info)==null?void 0:x.type)!=="video"||!this.currentTrack.info.colorSpace)break;this.currentTrack.info.colorSpace.fullRange=Z(e,i)===2}break;case C.TransferCharacteristics:{if(((P=(_=this.currentTrack)==null?void 0:_.info)==null?void 0:P.type)!=="video"||!this.currentTrack.info.colorSpace)break;const N=Z(e,i),Q=Fi[N]??null;this.currentTrack.info.colorSpace.transfer=Q}break;case C.Primaries:{if(((F=(M=this.currentTrack)==null?void 0:M.info)==null?void 0:F.type)!=="video"||!this.currentTrack.info.colorSpace)break;const N=Z(e,i),Q=Ii[N]??null;this.currentTrack.info.colorSpace.primaries=Q}break;case C.Projection:{if(((O=(z=this.currentTrack)==null?void 0:z.info)==null?void 0:O.type)!=="video")break;this.readContiguousElements(e.slice(s,i))}break;case C.ProjectionPoseRoll:{if(((X=(L=this.currentTrack)==null?void 0:L.info)==null?void 0:X.type)!=="video")break;const Q=-Gr(e,i);try{this.currentTrack.info.rotation=vn(Q)}catch{}}break;case C.Audio:{if(((ve=(se=this.currentTrack)==null?void 0:se.info)==null?void 0:ve.type)!=="audio")break;this.readContiguousElements(e.slice(s,i))}break;case C.SamplingFrequency:{if(((he=(oe=this.currentTrack)==null?void 0:oe.info)==null?void 0:he.type)!=="audio")break;this.currentTrack.info.sampleRate=Gr(e,i)}break;case C.Channels:{if(((Ee=(ce=this.currentTrack)==null?void 0:ce.info)==null?void 0:Ee.type)!=="audio")break;this.currentTrack.info.numberOfChannels=Z(e,i)}break;case C.BitDepth:{if(((it=(Ce=this.currentTrack)==null?void 0:Ce.info)==null?void 0:it.type)!=="audio")break;this.currentTrack.info.bitDepth=Z(e,i)}break;case C.CuePoint:{if(!this.currentSegment)break;this.readContiguousElements(e.slice(s,i)),this.currentCueTime=null}break;case C.CueTime:this.currentCueTime=Z(e,i);break;case C.CueTrackPositions:{if(this.currentCueTime===null)break;h(this.currentSegment);const N={time:this.currentCueTime,trackId:-1,clusterPosition:-1};this.currentSegment.cuePoints.push(N),this.readContiguousElements(e.slice(s,i)),(N.trackId===-1||N.clusterPosition===-1)&&this.currentSegment.cuePoints.pop()}break;case C.CueTrack:{const N=(Oe=this.currentSegment)==null?void 0:Oe.cuePoints[this.currentSegment.cuePoints.length-1];if(!N)break;N.trackId=Z(e,i)}break;case C.CueClusterPosition:{const N=(jt=this.currentSegment)==null?void 0:jt.cuePoints[this.currentSegment.cuePoints.length-1];if(!N)break;h(this.currentSegment),N.clusterPosition=this.currentSegment.dataStartPos+Z(e,i)}break;case C.Timestamp:{if(!this.currentCluster)break;this.currentCluster.timestamp=Z(e,i)}break;case C.SimpleBlock:{if(!this.currentCluster)break;const N=ir(e);if(N===null)break;const Q=this.getTrackDataInCluster(this.currentCluster,N);if(!Q)break;const f=yn(e),I=U(e),E=!!(I&128),v=I>>1&3,H=$(e,i-(e.filePos-s)),A=Q.track.decodingInstructions.length>0;Q.blocks.push({timestamp:f,duration:0,isKeyFrame:E,referencedTimestamps:[],data:H,lacing:v,decoded:!A,mainAdditional:null})}break;case C.BlockGroup:{if(!this.currentCluster)break;if(this.readContiguousElements(e.slice(s,i)),this.currentBlock){for(let N=0;N<this.currentBlock.referencedTimestamps.length;N++)this.currentBlock.referencedTimestamps[N]+=this.currentBlock.timestamp;this.currentBlock=null}}break;case C.Block:{if(!this.currentCluster)break;const N=ir(e);if(N===null)break;const Q=this.getTrackDataInCluster(this.currentCluster,N);if(!Q)break;const f=yn(e),E=U(e)>>1&3,v=$(e,i-(e.filePos-s)),H=Q.track.decodingInstructions.length>0;this.currentBlock={timestamp:f,duration:0,isKeyFrame:!0,referencedTimestamps:[],data:v,lacing:E,decoded:!H,mainAdditional:null},Q.blocks.push(this.currentBlock)}break;case C.BlockAdditions:this.readContiguousElements(e.slice(s,i));break;case C.BlockMore:{if(!this.currentBlock)break;this.currentBlockAdditional={addId:1,data:null},this.readContiguousElements(e.slice(s,i)),this.currentBlockAdditional.data&&this.currentBlockAdditional.addId===1&&(this.currentBlock.mainAdditional=this.currentBlockAdditional.data),this.currentBlockAdditional=null}break;case C.BlockAdditional:{if(!this.currentBlockAdditional)break;this.currentBlockAdditional.data=$(e,i)}break;case C.BlockAddID:{if(!this.currentBlockAdditional)break;this.currentBlockAdditional.addId=Z(e,i)}break;case C.BlockDuration:{if(!this.currentBlock)break;this.currentBlock.duration=Z(e,i)}break;case C.ReferenceBlock:{if(!this.currentBlock)break;this.currentBlock.isKeyFrame=!1;const N=qa(e,i);this.currentBlock.referencedTimestamps.push(N)}break;case C.Tag:this.currentTagTargetIsMovie=!0,this.readContiguousElements(e.slice(s,i));break;case C.Targets:this.readContiguousElements(e.slice(s,i));break;case C.TargetTypeValue:Z(e,i)!==50&&(this.currentTagTargetIsMovie=!1);break;case C.TagTrackUID:case C.TagEditionUID:case C.TagChapterUID:case C.TagAttachmentUID:this.currentTagTargetIsMovie=!1;break;case C.SimpleTag:{if(!this.currentTagTargetIsMovie)break;this.currentSimpleTagName=null,this.readContiguousElements(e.slice(s,i))}break;case C.TagName:this.currentSimpleTagName=tr(e,i);break;case C.TagString:{if(!this.currentSimpleTagName)break;const N=tr(e,i);this.processTagValue(this.currentSimpleTagName,N)}break;case C.TagBinary:{if(!this.currentSimpleTagName)break;const N=$(e,i);this.processTagValue(this.currentSimpleTagName,N)}break;case C.AttachedFile:{if(!this.currentSegment)break;this.currentAttachedFile={fileUid:null,fileName:null,fileMediaType:null,fileData:null,fileDescription:null},this.readContiguousElements(e.slice(s,i));const N=this.currentSegment.metadataTags;if(this.currentAttachedFile.fileUid&&this.currentAttachedFile.fileData&&(N.raw??(N.raw={}),N.raw[this.currentAttachedFile.fileUid.toString()]=new Ni(this.currentAttachedFile.fileData,this.currentAttachedFile.fileMediaType??void 0,this.currentAttachedFile.fileName??void 0,this.currentAttachedFile.fileDescription??void 0)),(Kt=this.currentAttachedFile.fileMediaType)!=null&&Kt.startsWith("image/")&&this.currentAttachedFile.fileData){const Q=this.currentAttachedFile.fileName;let f="unknown";if(Q){const I=Q.toLowerCase();I.startsWith("cover.")?f="coverFront":I.startsWith("back.")&&(f="coverBack")}N.images??(N.images=[]),N.images.push({data:this.currentAttachedFile.fileData,mimeType:this.currentAttachedFile.fileMediaType,kind:f,name:this.currentAttachedFile.fileName??void 0,description:this.currentAttachedFile.fileDescription??void 0})}this.currentAttachedFile=null}break;case C.FileUID:{if(!this.currentAttachedFile)break;this.currentAttachedFile.fileUid=Ha(e,i)}break;case C.FileName:{if(!this.currentAttachedFile)break;this.currentAttachedFile.fileName=tr(e,i)}break;case C.FileMediaType:{if(!this.currentAttachedFile)break;this.currentAttachedFile.fileMediaType=Rt(e,i)}break;case C.FileData:{if(!this.currentAttachedFile)break;this.currentAttachedFile.fileData=$(e,i)}break;case C.FileDescription:{if(!this.currentAttachedFile)break;this.currentAttachedFile.fileDescription=tr(e,i)}break;case C.ContentEncodings:{if(!this.currentTrack)break;this.readContiguousElements(e.slice(s,i)),this.currentTrack.decodingInstructions.sort((N,Q)=>Q.order-N.order)}break;case C.ContentEncoding:this.currentDecodingInstruction={order:0,scope:Fr.Block,data:null},this.readContiguousElements(e.slice(s,i)),this.currentDecodingInstruction.data&&this.currentTrack.decodingInstructions.push(this.currentDecodingInstruction),this.currentDecodingInstruction=null;break;case C.ContentEncodingOrder:{if(!this.currentDecodingInstruction)break;this.currentDecodingInstruction.order=Z(e,i)}break;case C.ContentEncodingScope:{if(!this.currentDecodingInstruction)break;this.currentDecodingInstruction.scope=Z(e,i)}break;case C.ContentCompression:{if(!this.currentDecodingInstruction)break;this.currentDecodingInstruction.data={type:"decompress",algorithm:or.Zlib,settings:null},this.readContiguousElements(e.slice(s,i))}break;case C.ContentCompAlgo:{if(((Gt=(Qt=this.currentDecodingInstruction)==null?void 0:Qt.data)==null?void 0:Gt.type)!=="decompress")break;this.currentDecodingInstruction.data.algorithm=Z(e,i)}break;case C.ContentCompSettings:{if(((Yt=(Xt=this.currentDecodingInstruction)==null?void 0:Xt.data)==null?void 0:Yt.type)!=="decompress")break;this.currentDecodingInstruction.data.settings=$(e,i)}break;case C.ContentEncryption:{if(!this.currentDecodingInstruction)break;this.currentDecodingInstruction.data={type:"decrypt"}}break}return e.filePos=s+i,!0}decodeBlockData(e,r){h(e.decodingInstructions.length>0);let n=r;for(const i of e.decodingInstructions)switch(h(i.data),i.data.type){case"decompress":switch(i.data.algorithm){case or.HeaderStripping:if(i.data.settings&&i.data.settings.length>0){const s=i.data.settings,a=new Uint8Array(s.length+n.length);a.set(s,0),a.set(n,s.length),n=a}break}break}return n}processTagValue(e,r){var i,s;if(!((i=this.currentSegment)!=null&&i.metadataTags))return;const n=this.currentSegment.metadataTags;if(n.raw??(n.raw={}),(s=n.raw)[e]??(s[e]=r),typeof r=="string")switch(e.toLowerCase()){case"title":n.title??(n.title=r);break;case"description":n.description??(n.description=r);break;case"artist":n.artist??(n.artist=r);break;case"album":n.album??(n.album=r);break;case"album_artist":n.albumArtist??(n.albumArtist=r);break;case"genre":n.genre??(n.genre=r);break;case"comment":n.comment??(n.comment=r);break;case"lyrics":n.lyrics??(n.lyrics=r);break;case"date":{const a=new Date(r);Number.isNaN(a.getTime())||(n.date??(n.date=a))}break;case"track_number":case"part_number":{const a=r.split("/"),o=Number.parseInt(a[0],10),c=a[1]&&Number.parseInt(a[1],10);Number.isInteger(o)&&o>0&&(n.trackNumber??(n.trackNumber=o)),c&&Number.isInteger(c)&&c>0&&(n.tracksTotal??(n.tracksTotal=c))}break;case"disc_number":case"disc":{const a=r.split("/"),o=Number.parseInt(a[0],10),c=a[1]&&Number.parseInt(a[1],10);Number.isInteger(o)&&o>0&&(n.discNumber??(n.discNumber=o)),c&&Number.isInteger(c)&&c>0&&(n.discsTotal??(n.discsTotal=c))}break}}}class cs{constructor(e){this.internalTrack=e,this.packetToClusterLocation=new WeakMap}getId(){return this.internalTrack.id}getCodec(){throw new Error("Not implemented on base class.")}getInternalCodecId(){return this.internalTrack.codecId}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return((e==null?void 0:e.timestamp)??0)+((e==null?void 0:e.duration)??0)}getName(){return this.internalTrack.name}getLanguageCode(){return this.internalTrack.languageCode}async getFirstTimestamp(){const e=await this.getFirstPacket({metadataOnly:!0});return(e==null?void 0:e.timestamp)??0}getTimeResolution(){return this.internalTrack.segment.timestampFactor}async getFirstPacket(e){return this.performClusterLookup(()=>{const r=this.internalTrack.segment.clusters[0]??null;if(r!=null&&r.isKnownToBeFirstCluster){let n=r;for(;n;){if(n.trackData.get(this.internalTrack.id))return{clusterIndex:fe(this.internalTrack.clusters,n.elementStartPos,s=>s.elementStartPos),blockIndex:0,correctBlockFound:!0};n=n.nextCluster}}return{clusterIndex:-1,blockIndex:-1,correctBlockFound:!1}},-1/0,1/0,e)}intoTimescale(e){return vr(e*this.internalTrack.segment.timestampFactor,14)}async getPacket(e,r){const n=this.intoTimescale(e);return this.performClusterLookup(()=>this.findBlockInClustersForTimestamp(n),n,n,r)}async getNextPacket(e,r){const n=this.packetToClusterLocation.get(e);if(n===void 0)throw new Error("Packet was not created from this track.");const i=n.cluster.trackData.get(this.internalTrack.id),s=fe(this.internalTrack.clusters,n.cluster.elementStartPos,a=>a.elementStartPos);return h(s!==-1),this.performClusterLookup(()=>{if(n.blockIndex+1<i.blocks.length)return{clusterIndex:s,blockIndex:n.blockIndex+1,correctBlockFound:!0};{let a=n.cluster;for(;a.nextCluster;)if(a=a.nextCluster,a.trackData.get(this.internalTrack.id)){const c=fe(this.internalTrack.clusters,a.elementStartPos,l=>l.elementStartPos);return h(c!==-1),{clusterIndex:c,blockIndex:0,correctBlockFound:!0}}return{clusterIndex:s,blockIndex:-1,correctBlockFound:!1}}},-1/0,1/0,r)}async getKeyPacket(e,r){const n=this.intoTimescale(e);return this.performClusterLookup(()=>this.findKeyBlockInClustersForTimestamp(n),n,n,r)}async getNextKeyPacket(e,r){const n=this.packetToClusterLocation.get(e);if(n===void 0)throw new Error("Packet was not created from this track.");const i=n.cluster.trackData.get(this.internalTrack.id),s=fe(this.internalTrack.clusters,n.cluster.elementStartPos,a=>a.elementStartPos);return h(s!==-1),this.performClusterLookup(()=>{const a=i.blocks.findIndex((o,c)=>o.isKeyFrame&&c>n.blockIndex);if(a!==-1)return{clusterIndex:s,blockIndex:a,correctBlockFound:!0};{let o=n.cluster;for(;o.nextCluster;){o=o.nextCluster;const c=o.trackData.get(this.internalTrack.id);if(c&&c.firstKeyFrameTimestamp!==null){const l=fe(this.internalTrack.clusters,o.elementStartPos,d=>d.elementStartPos);h(l!==-1);const u=c.blocks.findIndex(d=>d.isKeyFrame);return h(u!==-1),{clusterIndex:l,blockIndex:u,correctBlockFound:!0}}}return{clusterIndex:s,blockIndex:-1,correctBlockFound:!1}}},-1/0,1/0,r)}async fetchPacketInCluster(e,r,n){var d;if(r===-1)return null;const s=e.trackData.get(this.internalTrack.id).blocks[r];h(s),s.decoded||(s.data=this.internalTrack.demuxer.decodeBlockData(this.internalTrack,s.data),s.decoded=!0);const a=n.metadataOnly?ze:s.data,o=s.timestamp/this.internalTrack.segment.timestampFactor,c=s.duration/this.internalTrack.segment.timestampFactor,l={};s.mainAdditional&&((d=this.internalTrack.info)==null?void 0:d.type)==="video"&&this.internalTrack.info.alphaMode&&(l.alpha=n.metadataOnly?ze:s.mainAdditional,l.alphaByteLength=s.mainAdditional.byteLength);const u=new ie(a,s.isKeyFrame?"key":"delta",o,c,e.dataStartPos+r,s.data.byteLength,l);return this.packetToClusterLocation.set(u,{cluster:e,blockIndex:r}),u}findBlockInClustersForTimestamp(e){const r=te(this.internalTrack.clusters,e,s=>s.trackData.get(this.internalTrack.id).startTimestamp);let n=-1,i=!1;if(r!==-1){const a=this.internalTrack.clusters[r].trackData.get(this.internalTrack.id),o=te(a.presentationTimestamps,e,c=>c.timestamp);h(o!==-1),n=a.presentationTimestamps[o].blockIndex,i=e<a.endTimestamp}return{clusterIndex:r,blockIndex:n,correctBlockFound:i}}findKeyBlockInClustersForTimestamp(e){const r=te(this.internalTrack.clustersWithKeyFrame,e,a=>a.trackData.get(this.internalTrack.id).firstKeyFrameTimestamp);let n=-1,i=-1,s=!1;if(r!==-1){const a=this.internalTrack.clustersWithKeyFrame[r];n=fe(this.internalTrack.clusters,a.elementStartPos,u=>u.elementStartPos),h(n!==-1);const o=a.trackData.get(this.internalTrack.id),c=zi(o.presentationTimestamps,u=>o.blocks[u.blockIndex].isKeyFrame&&u.timestamp<=e);h(c!==-1),i=o.presentationTimestamps[c].blockIndex,s=e<o.endTimestamp}return{clusterIndex:n,blockIndex:i,correctBlockFound:s}}async performClusterLookup(e,r,n,i){const{demuxer:s,segment:a}=this.internalTrack,o=await a.clusterLookupMutex.acquire();try{const{clusterIndex:c,blockIndex:l,correctBlockFound:u}=e();if(u){const y=this.internalTrack.clusters[c];return this.fetchPacketInCluster(y,l,i)}let d=null,p=c,g=l;const w=te(this.internalTrack.cuePoints,r,y=>y.time),m=w!==-1?this.internalTrack.cuePoints[w]:null;let k,T=!1;if(c===-1)k=(m==null?void 0:m.clusterPosition)??a.clusterSeekStartPos,T=k===a.clusterSeekStartPos;else{const y=this.internalTrack.clusters[c];!m||y.elementStartPos>=m.clusterPosition?(k=y.elementEndPos,d=y):k=m.clusterPosition}for(;a.elementEndPos===null||k<=a.elementEndPos-Ie;){if(d){const F=d.trackData.get(this.internalTrack.id);if(F&&F.startTimestamp>n)break;if(d.nextCluster){k=d.nextCluster.elementEndPos,d=d.nextCluster;continue}}let y=s.reader.requestSliceRange(k,Ie,tt);if(y instanceof Promise&&(y=await y),!y)break;const S=k,x=Je(y);if(!x||!fr.includes(x.id)&&x.id!==C.Void){const F=await as(s.reader,S,fr,Math.min(a.elementEndPos??1/0,S+os));if(F){k=F;continue}else break}const _=x.id;let P=x.size;const M=y.filePos;if(_===C.Cluster){const F=fe(a.clusters,S,se=>se.elementStartPos);let z;F===-1?z=await s.readCluster(S,a):z=a.clusters[F],d&&(d.nextCluster=z),d=z,T&&(z.isKnownToBeFirstCluster=!0,T=!1);const{clusterIndex:O,blockIndex:L,correctBlockFound:X}=e();if(X){const se=this.internalTrack.clusters[O];return this.fetchPacketInCluster(se,L,i)}O!==-1&&(p=O,g=L)}if(P===null){_===C.Cluster?(h(d),P=d.elementEndPos-M):P=(await gn(s.reader,M,mn,a.elementEndPos)).pos-M;const F=M+P;if(a.elementEndPos!==null&&F>a.elementEndPos-Ie)break;{let z=s.reader.requestSliceRange(F,Ie,tt);if(z instanceof Promise&&(z=await z),!z)break;if(zn(z)===C.Segment){a.elementEndPos=F;break}}}k=M+P}const b=p!==-1?this.internalTrack.clusters[p]:null;if(m&&(!b||b.elementStartPos<m.clusterPosition)){const y=this.internalTrack.cuePoints[w-1],S=(y==null?void 0:y.time)??-1/0;return this.performClusterLookup(e,S,n,i)}return b?this.fetchPacketInCluster(b,g,i):null}finally{o()}}}class Ka extends cs{constructor(e){super(e),this.decoderConfigPromise=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getCodedWidth(){return this.internalTrack.info.width}getCodedHeight(){return this.internalTrack.info.height}getRotation(){return this.internalTrack.info.rotation}async getColorSpace(){var e,r,n,i;return{primaries:(e=this.internalTrack.info.colorSpace)==null?void 0:e.primaries,transfer:(r=this.internalTrack.info.colorSpace)==null?void 0:r.transfer,matrix:(n=this.internalTrack.info.colorSpace)==null?void 0:n.matrix,fullRange:(i=this.internalTrack.info.colorSpace)==null?void 0:i.fullRange}}async canBeTransparent(){return this.internalTrack.info.alphaMode}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfigPromise??(this.decoderConfigPromise=(async()=>{let e=null;return(this.internalTrack.info.codec==="vp9"||this.internalTrack.info.codec==="av1"||this.internalTrack.info.codec==="avc"&&!this.internalTrack.info.codecDescription||this.internalTrack.info.codec==="hevc"&&!this.internalTrack.info.codecDescription)&&(e=await this.getFirstPacket({})),{codec:Oi({width:this.internalTrack.info.width,height:this.internalTrack.info.height,codec:this.internalTrack.info.codec,codecDescription:this.internalTrack.info.codecDescription,colorSpace:this.internalTrack.info.colorSpace,avcCodecInfo:this.internalTrack.info.codec==="avc"&&e?$i(e.data):null,hevcCodecInfo:this.internalTrack.info.codec==="hevc"&&e?Ki(e.data):null,vp9CodecInfo:this.internalTrack.info.codec==="vp9"&&e?Qi(e.data):null,av1CodecInfo:this.internalTrack.info.codec==="av1"&&e?Xi(e.data):null}),codedWidth:this.internalTrack.info.width,codedHeight:this.internalTrack.info.height,description:this.internalTrack.info.codecDescription??void 0,colorSpace:this.internalTrack.info.colorSpace??void 0}})()):null}}class Qa extends cs{constructor(e){super(e),this.decoderConfig=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getNumberOfChannels(){return this.internalTrack.info.numberOfChannels}getSampleRate(){return this.internalTrack.info.sampleRate}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfig??(this.decoderConfig={codec:Vi({codec:this.internalTrack.info.codec,codecDescription:this.internalTrack.info.codecDescription,aacCodecInfo:this.internalTrack.info.aacCodecInfo}),numberOfChannels:this.internalTrack.info.numberOfChannels,sampleRate:this.internalTrack.info.sampleRate,description:this.internalTrack.info.codecDescription??void 0}):null}}const Ga=t=>{const e=new Map;for(let s=0;s<t.length;s++){const a=t[s];e.set(a.timestamp,a)}const r=new Set,n=[],i=s=>{if(!r.has(s)){r.add(s);for(let a=0;a<s.referencedTimestamps.length;a++){const o=s.referencedTimestamps[a],c=e.get(o);c&&i(c)}n.push(s)}};for(let s=0;s<t.length;s++)i(t[s]);return n};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const ls=4,Xa=[44100,48e3,32e3],Ya=[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,32,40,48,56,64,80,96,112,128,160,192,224,256,320,-1,-1,32,48,56,64,80,96,112,128,160,192,224,256,320,384,-1,-1,32,64,96,128,160,192,224,256,288,320,352,384,416,448,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,16,24,32,40,48,56,64,80,96,112,128,144,160,-1,-1,8,16,24,32,40,48,56,64,80,96,112,128,144,160,-1,-1,32,48,56,64,80,96,112,128,144,160,176,192,224,256,-1],Za=1483304551,Ja=1231971951,eo=(t,e,r,n,i)=>e===0?0:e===1?Math.floor(144*r/(n<<t))+i:e===2?Math.floor(144*r/n)+i:(Math.floor(12*r/n)+i)*4,to=(t,e)=>t===3?e===3?21:36:e===3?13:21,ro=(t,e)=>{const r=t>>>24,n=t>>>16&255,i=t>>>8&255,s=t&255;if(r!==255&&n!==255&&i!==255&&s!==255)return{header:null,bytesAdvanced:4};if(r!==255)return{header:null,bytesAdvanced:1};if((n&224)!==224)return{header:null,bytesAdvanced:1};let a=0,o=0;n&16?a=n&8?0:1:(a=1,o=1);const c=n>>3&3,l=n>>1&3,u=i>>4&15,d=(i>>2&3)%3,p=i>>1&1,g=s>>6&3,w=s>>4&3,m=s>>3&1,k=s>>2&1,T=s&3,b=Ya[a*16*4+l*16+u];if(b===-1)return{header:null,bytesAdvanced:1};const y=b*1e3,S=Xa[d]>>a+o,x=eo(a,l,y,S,p);if(e!==null&&e<x)return{header:null,bytesAdvanced:1};let _;return c===3?_=l===3?384:1152:l===3?_=384:l===2?_=1152:_=576,{header:{totalSize:x,mpegVersionId:c,layer:l,bitrate:y,frequencyIndex:d,sampleRate:S,channel:g,modeExtension:w,copyright:m,original:k,emphasis:T,audioSamplesInFrame:_},bytesAdvanced:1}},bn=t=>{let e=2130706432,r=0;for(;e!==0;)r>>=1,r|=t&e,e>>=8;return r};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */var Mt;(function(t){t[t.Unsynchronisation=128]="Unsynchronisation",t[t.ExtendedHeader=64]="ExtendedHeader",t[t.ExperimentalIndicator=32]="ExperimentalIndicator",t[t.Footer=16]="Footer"})(Mt||(Mt={}));var Nt;(function(t){t[t.ISO_8859_1=0]="ISO_8859_1",t[t.UTF_16_WITH_BOM=1]="UTF_16_WITH_BOM",t[t.UTF_16_BE_NO_BOM=2]="UTF_16_BE_NO_BOM",t[t.UTF_8=3]="UTF_8"})(Nt||(Nt={}));const _r=128,Ar=10,Ot=["Blues","Classic rock","Country","Dance","Disco","Funk","Grunge","Hip-hop","Jazz","Metal","New age","Oldies","Other","Pop","Rhythm and blues","Rap","Reggae","Rock","Techno","Industrial","Alternative","Ska","Death metal","Pranks","Soundtrack","Euro-techno","Ambient","Trip-hop","Vocal","Jazz & funk","Fusion","Trance","Classical","Instrumental","Acid","House","Game","Sound clip","Gospel","Noise","Alternative rock","Bass","Soul","Punk","Space","Meditative","Instrumental pop","Instrumental rock","Ethnic","Gothic","Darkwave","Techno-industrial","Electronic","Pop-folk","Eurodance","Dream","Southern rock","Comedy","Cult","Gangsta","Top 40","Christian rap","Pop/funk","Jungle music","Native US","Cabaret","New wave","Psychedelic","Rave","Showtunes","Trailer","Lo-fi","Tribal","Acid punk","Acid jazz","Polka","Retro","Musical","Rock 'n' roll","Hard rock","Folk","Folk rock","National folk","Swing","Fast fusion","Bebop","Latin","Revival","Celtic","Bluegrass","Avantgarde","Gothic rock","Progressive rock","Psychedelic rock","Symphonic rock","Slow rock","Big band","Chorus","Easy listening","Acoustic","Humour","Speech","Chanson","Opera","Chamber music","Sonata","Symphony","Booty bass","Primus","Porn groove","Satire","Slow jam","Club","Tango","Samba","Folklore","Ballad","Power ballad","Rhythmic Soul","Freestyle","Duet","Punk rock","Drum solo","A cappella","Euro-house","Dance hall","Goa music","Drum & bass","Club-house","Hardcore techno","Terror","Indie","Britpop","Negerpunk","Polsk punk","Beat","Christian gangsta rap","Heavy metal","Black metal","Crossover","Contemporary Christian","Christian rock","Merengue","Salsa","Thrash metal","Anime","Jpop","Synthpop","Christmas","Art rock","Baroque","Bhangra","Big beat","Breakbeat","Chillout","Downtempo","Dub","EBM","Eclectic","Electro","Electroclash","Emo","Experimental","Garage","Global","IDM","Illbient","Industro-Goth","Jam Band","Krautrock","Leftfield","Lounge","Math rock","New romantic","Nu-breakz","Post-punk","Post-rock","Psytrance","Shoegaze","Space rock","Trop rock","World music","Neoclassical","Audiobook","Audio theatre","Neue Deutsche Welle","Podcast","Indie rock","G-Funk","Dubstep","Garage rock","Psybient"],no=(t,e)=>{var d;const r=t.filePos;e.raw??(e.raw={}),(d=e.raw).TAG??(d.TAG=$(t,_r-3)),t.filePos=r;const n=It(t,30);n&&(e.title??(e.title=n));const i=It(t,30);i&&(e.artist??(e.artist=i));const s=It(t,30);s&&(e.album??(e.album=s));const a=It(t,4),o=Number.parseInt(a,10);Number.isInteger(o)&&o>0&&(e.date??(e.date=new Date(o,0,1)));const c=$(t,30);let l;if(c[28]===0&&c[29]!==0){const p=c[29];p>0&&(e.trackNumber??(e.trackNumber=p)),t.skip(-30),l=It(t,28),t.skip(2)}else t.skip(-30),l=It(t,30);l&&(e.comment??(e.comment=l));const u=U(t);u<Ot.length&&(e.genre??(e.genre=Ot[u]))},It=(t,e)=>{const r=$(t,e),n=zt(r.indexOf(0),r.length),i=r.subarray(0,n);let s="";for(let a=0;a<i.length;a++)s+=String.fromCharCode(i[a]);return s.trimEnd()},Br=t=>{const e=t.filePos,r=ge(t,3),n=U(t),i=U(t),s=U(t),a=R(t);if(r!=="ID3"||n===255||i===255||a&2155905152)return t.filePos=e,null;const o=bn(a);return{majorVersion:n,revision:i,flags:s,size:o}},us=(t,e,r)=>{var s,a,o,c;if(![2,3,4].includes(e.majorVersion)){console.warn(`Unsupported ID3v2 major version: ${e.majorVersion}`);return}const n=$(t,e.size),i=new io(e,n);if(e.flags&Mt.Footer&&i.removeFooter(),e.flags&Mt.Unsynchronisation&&e.majorVersion===3&&i.ununsynchronizeAll(),e.flags&Mt.ExtendedHeader){const l=i.readU32();e.majorVersion===3?i.pos+=l:i.pos+=l-4}for(;i.pos<=i.bytes.length-i.frameHeaderSize();){const l=i.readId3V2Frame();if(!l)break;const u=i.pos,d=i.pos+l.size;let p=!1,g=!1,w=!1;if(e.majorVersion===3?(p=!!(l.flags&64),g=!!(l.flags&128)):e.majorVersion===4&&(p=!!(l.flags&4),g=!!(l.flags&8),w=!!(l.flags&2)||!!(e.flags&Mt.Unsynchronisation)),p){console.warn(`Skipping encrypted ID3v2 frame ${l.id}`),i.pos=d;continue}if(g){console.warn(`Skipping compressed ID3v2 frame ${l.id}`),i.pos=d;continue}switch(w&&i.ununsynchronizeRegion(i.pos,d),r.raw??(r.raw={}),l.id[0]==="T"?(s=r.raw)[a=l.id]??(s[a]=i.readId3V2EncodingAndText(d)):(o=r.raw)[c=l.id]??(o[c]=i.readBytes(l.size)),i.pos=u,l.id){case"TIT2":case"TT2":r.title??(r.title=i.readId3V2EncodingAndText(d));break;case"TIT3":case"TT3":r.description??(r.description=i.readId3V2EncodingAndText(d));break;case"TPE1":case"TP1":r.artist??(r.artist=i.readId3V2EncodingAndText(d));break;case"TALB":case"TAL":r.album??(r.album=i.readId3V2EncodingAndText(d));break;case"TPE2":case"TP2":r.albumArtist??(r.albumArtist=i.readId3V2EncodingAndText(d));break;case"TRCK":case"TRK":{const k=i.readId3V2EncodingAndText(d).split("/"),T=Number.parseInt(k[0],10),b=k[1]&&Number.parseInt(k[1],10);Number.isInteger(T)&&T>0&&(r.trackNumber??(r.trackNumber=T)),b&&Number.isInteger(b)&&b>0&&(r.tracksTotal??(r.tracksTotal=b))}break;case"TPOS":case"TPA":{const k=i.readId3V2EncodingAndText(d).split("/"),T=Number.parseInt(k[0],10),b=k[1]&&Number.parseInt(k[1],10);Number.isInteger(T)&&T>0&&(r.discNumber??(r.discNumber=T)),b&&Number.isInteger(b)&&b>0&&(r.discsTotal??(r.discsTotal=b))}break;case"TCON":case"TCO":{const m=i.readId3V2EncodingAndText(d);let k=/^\((\d+)\)/.exec(m);if(k){const T=Number.parseInt(k[1]);if(Ot[T]!==void 0){r.genre??(r.genre=Ot[T]);break}}if(k=/^\d+$/.exec(m),k){const T=Number.parseInt(k[0]);if(Ot[T]!==void 0){r.genre??(r.genre=Ot[T]);break}}r.genre??(r.genre=m)}break;case"TDRC":case"TDAT":{const m=i.readId3V2EncodingAndText(d),k=new Date(m);Number.isNaN(k.getTime())||(r.date??(r.date=k))}break;case"TYER":case"TYE":{const m=i.readId3V2EncodingAndText(d),k=Number.parseInt(m,10);Number.isInteger(k)&&(r.date??(r.date=new Date(k,0,1)))}break;case"USLT":case"ULT":{const m=i.readU8();i.pos+=3,i.readId3V2Text(m,d),r.lyrics??(r.lyrics=i.readId3V2Text(m,d))}break;case"COMM":case"COM":{const m=i.readU8();i.pos+=3,i.readId3V2Text(m,d),r.comment??(r.comment=i.readId3V2Text(m,d))}break;case"APIC":case"PIC":{const m=i.readId3V2TextEncoding();let k;if(e.majorVersion===2){const S=i.readAscii(3);k=S==="PNG"?"image/png":S==="JPG"?"image/jpeg":"image/*"}else k=i.readId3V2Text(m,d);const T=i.readU8(),b=i.readId3V2Text(m,d).trimEnd(),y=d-i.pos;if(y>=0){const S=i.readBytes(y);r.images||(r.images=[]),r.images.push({data:S,mimeType:k,kind:T===3?"coverFront":T===4?"coverBack":"unknown",description:b})}}break;default:i.pos+=l.size;break}i.pos=d}};class io{constructor(e,r){this.header=e,this.bytes=r,this.pos=0,this.view=new DataView(r.buffer,r.byteOffset,r.byteLength)}frameHeaderSize(){return this.header.majorVersion===2?6:10}ununsynchronizeAll(){const e=[];for(let r=0;r<this.bytes.length;r++){const n=this.bytes[r];e.push(n),n===255&&r!==this.bytes.length-1&&this.bytes[r]===0&&r++}this.bytes=new Uint8Array(e),this.view=new DataView(this.bytes.buffer)}ununsynchronizeRegion(e,r){const n=[];for(let a=e;a<r;a++){const o=this.bytes[a];n.push(o),o===255&&a!==r-1&&this.bytes[a+1]===0&&a++}const i=this.bytes.subarray(0,e),s=this.bytes.subarray(r);this.bytes=new Uint8Array(i.length+n.length+s.length),this.bytes.set(i,0),this.bytes.set(n,i.length),this.bytes.set(s,i.length+n.length),this.view=new DataView(this.bytes.buffer)}removeFooter(){this.bytes=this.bytes.subarray(0,this.bytes.length-Ar),this.view=new DataView(this.bytes.buffer)}readBytes(e){const r=this.bytes.subarray(this.pos,this.pos+e);return this.pos+=e,r}readU8(){const e=this.view.getUint8(this.pos);return this.pos+=1,e}readU16(){const e=this.view.getUint16(this.pos,!1);return this.pos+=2,e}readU24(){const e=this.view.getUint16(this.pos,!1),r=this.view.getUint8(this.pos+1);return this.pos+=3,e*256+r}readU32(){const e=this.view.getUint32(this.pos,!1);return this.pos+=4,e}readAscii(e){let r="";for(let n=0;n<e;n++)r+=String.fromCharCode(this.view.getUint8(this.pos+n));return this.pos+=e,r}readId3V2Frame(){if(this.header.majorVersion===2){const e=this.readAscii(3);if(e==="\0\0\0")return null;const r=this.readU24();return{id:e,size:r,flags:0}}else{const e=this.readAscii(4);if(e==="\0\0\0\0")return null;const r=this.readU32();let n=this.header.majorVersion===4?bn(r):r;const i=this.readU16(),s=this.pos,a=o=>{const c=this.pos+o;if(c>this.bytes.length)return!1;if(c<=this.bytes.length-this.frameHeaderSize()){this.pos+=o;const l=this.readAscii(4);if(l!=="\0\0\0\0"&&!/[0-9A-Z]{4}/.test(l))return!1}return!0};if(!a(n)){const o=this.header.majorVersion===4?r:bn(r);a(o)&&(n=o)}return this.pos=s,{id:e,size:n,flags:i}}}readId3V2TextEncoding(){const e=this.readU8();if(e>3)throw new Error(`Unsupported text encoding: ${e}`);return e}readId3V2Text(e,r){const n=this.pos,i=this.readBytes(r-this.pos);switch(e){case Nt.ISO_8859_1:{let s="";for(let a=0;a<i.length;a++){const o=i[a];if(o===0){this.pos=n+a+1;break}s+=String.fromCharCode(o)}return s}case Nt.UTF_16_WITH_BOM:if(i[0]===255&&i[1]===254){const s=new TextDecoder("utf-16le"),a=zt(i.findIndex((o,c)=>o===0&&i[c+1]===0&&c%2===0),i.length);return this.pos=n+Math.min(a+2,i.length),s.decode(i.subarray(2,a))}else if(i[0]===254&&i[1]===255){const s=new TextDecoder("utf-16be"),a=zt(i.findIndex((o,c)=>o===0&&i[c+1]===0&&c%2===0),i.length);return this.pos=n+Math.min(a+2,i.length),s.decode(i.subarray(2,a))}else{const s=zt(i.findIndex(a=>a===0),i.length);return this.pos=n+Math.min(s+1,i.length),Be.decode(i.subarray(0,s))}case Nt.UTF_16_BE_NO_BOM:{const s=new TextDecoder("utf-16be"),a=zt(i.findIndex((o,c)=>o===0&&i[c+1]===0&&c%2===0),i.length);return this.pos=n+Math.min(a+2,i.length),s.decode(i.subarray(0,a))}case Nt.UTF_8:{const s=zt(i.findIndex(a=>a===0),i.length);return this.pos=n+Math.min(s+1,i.length),Be.decode(i.subarray(0,s))}}}readId3V2EncodingAndText(e){if(this.pos>=e)return"";const r=this.readId3V2TextEncoding();return this.readId3V2Text(r,e)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const wn=async(t,e,r)=>{let n=e;for(;r===null||n<r;){let i=t.requestSlice(n,ls);if(i instanceof Promise&&(i=await i),!i)break;const s=R(i),a=ro(s,t.fileSize!==null?t.fileSize-n:null);if(a.header)return{header:a.header,startPos:n};n+=a.bytesAdvanced}return null};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class so extends _t{constructor(e){super(e),this.metadataPromise=null,this.firstFrameHeader=null,this.loadedSamples=[],this.metadataTags=null,this.tracks=[],this.readingMutex=new wt,this.lastSampleLoaded=!1,this.lastLoadedPos=0,this.nextTimestampInSamples=0,this.reader=e._reader}async readMetadata(){return this.metadataPromise??(this.metadataPromise=(async()=>{for(;!this.firstFrameHeader&&!this.lastSampleLoaded;)await this.advanceReader();if(!this.firstFrameHeader)throw new Error("No valid MP3 frame found.");this.tracks=[new rt(this.input,new ao(this))]})())}async advanceReader(){if(this.lastLoadedPos===0)for(;;){let o=this.reader.requestSlice(this.lastLoadedPos,Ar);if(o instanceof Promise&&(o=await o),!o){this.lastSampleLoaded=!0;return}const c=Br(o);if(!c)break;this.lastLoadedPos=o.filePos+c.size}const e=await wn(this.reader,this.lastLoadedPos,this.reader.fileSize);if(!e){this.lastSampleLoaded=!0;return}const r=e.header;this.lastLoadedPos=e.startPos+r.totalSize-1;const n=to(r.mpegVersionId,r.channel);let i=this.reader.requestSlice(e.startPos+n,4);if(i instanceof Promise&&(i=await i),i){const o=R(i);if(o===Za||o===Ja)return}this.firstFrameHeader||(this.firstFrameHeader=r),r.sampleRate!==this.firstFrameHeader.sampleRate&&console.warn(`MP3 changed sample rate mid-file: ${this.firstFrameHeader.sampleRate} Hz to ${r.sampleRate} Hz. Might be a bug, so please report this file.`);const s=r.audioSamplesInFrame/this.firstFrameHeader.sampleRate,a={timestamp:this.nextTimestampInSamples/this.firstFrameHeader.sampleRate,duration:s,dataStart:e.startPos,dataSize:r.totalSize};this.loadedSamples.push(a),this.nextTimestampInSamples+=r.audioSamplesInFrame}async getMimeType(){return"audio/mpeg"}async getTracks(){return await this.readMetadata(),this.tracks}async computeDuration(){await this.readMetadata();const e=this.tracks[0];return h(e),e.computeDuration()}async getMetadataTags(){const e=await this.readingMutex.acquire();try{if(await this.readMetadata(),this.metadataTags)return this.metadataTags;this.metadataTags={};let r=0,n=!1;for(;;){let i=this.reader.requestSlice(r,Ar);if(i instanceof Promise&&(i=await i),!i)break;const s=Br(i);if(!s)break;n=!0;let a=this.reader.requestSlice(i.filePos,s.size);if(a instanceof Promise&&(a=await a),!a)break;us(a,s,this.metadataTags),r=i.filePos+s.size}if(!n&&this.reader.fileSize!==null&&this.reader.fileSize>=_r){let i=this.reader.requestSlice(this.reader.fileSize-_r,_r);i instanceof Promise&&(i=await i),h(i),ge(i,3)==="TAG"&&no(i,this.metadataTags)}return this.metadataTags}finally{e()}}}class ao{constructor(e){this.demuxer=e}getId(){return 1}async getFirstTimestamp(){return 0}getTimeResolution(){return h(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.sampleRate/this.demuxer.firstFrameHeader.audioSamplesInFrame}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return((e==null?void 0:e.timestamp)??0)+((e==null?void 0:e.duration)??0)}getName(){return null}getLanguageCode(){return Fe}getCodec(){return"mp3"}getInternalCodecId(){return null}getNumberOfChannels(){return h(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.channel===3?1:2}getSampleRate(){return h(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.sampleRate}async getDecoderConfig(){return h(this.demuxer.firstFrameHeader),{codec:"mp3",numberOfChannels:this.demuxer.firstFrameHeader.channel===3?1:2,sampleRate:this.demuxer.firstFrameHeader.sampleRate}}async getPacketAtIndex(e,r){if(e===-1)return null;const n=this.demuxer.loadedSamples[e];if(!n)return null;let i;if(r.metadataOnly)i=ze;else{let s=this.demuxer.reader.requestSlice(n.dataStart,n.dataSize);if(s instanceof Promise&&(s=await s),!s)return null;i=$(s,n.dataSize)}return new ie(i,"key",n.timestamp,n.duration,e,n.dataSize)}getFirstPacket(e){return this.getPacketAtIndex(0,e)}async getNextPacket(e,r){const n=await this.demuxer.readingMutex.acquire();try{const i=fe(this.demuxer.loadedSamples,e.timestamp,a=>a.timestamp);if(i===-1)throw new Error("Packet was not created from this track.");const s=i+1;for(;s>=this.demuxer.loadedSamples.length&&!this.demuxer.lastSampleLoaded;)await this.demuxer.advanceReader();return this.getPacketAtIndex(s,r)}finally{n()}}async getPacket(e,r){const n=await this.demuxer.readingMutex.acquire();try{for(;;){const i=te(this.demuxer.loadedSamples,e,s=>s.timestamp);if(i===-1&&this.demuxer.loadedSamples.length>0)return null;if(this.demuxer.lastSampleLoaded)return this.getPacketAtIndex(i,r);if(i>=0&&i+1<this.demuxer.loadedSamples.length)return this.getPacketAtIndex(i,r);await this.demuxer.advanceReader()}}finally{n()}}getKeyPacket(e,r){return this.getPacket(e,r)}getNextKeyPacket(e,r){return this.getNextPacket(e,r)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const ds=1399285583,oo=79764919,hs=new Uint32Array(256);for(let t=0;t<256;t++){let e=t<<24;for(let r=0;r<8;r++)e=e&2147483648?e<<1^oo:e<<1;hs[t]=e>>>0&4294967295}const co=t=>{const e=Te(t),r=e.getUint32(22,!0);e.setUint32(22,0,!0);let n=0;for(let i=0;i<t.length;i++){const s=t[i];n=(n<<8^hs[n>>>24^s])>>>0}return e.setUint32(22,r,!0),n},lo=(t,e,r)=>{let n=0,i=null;if(t.length>0)if(e.codec==="vorbis"){h(e.vorbisInfo);const s=e.vorbisInfo.modeBlockflags.length,o=(1<<$s(s-1))-1<<1,c=(t[0]&o)>>1;if(c>=e.vorbisInfo.modeBlockflags.length)throw new Error("Invalid mode number.");let l=r;const u=e.vorbisInfo.modeBlockflags[c];if(i=e.vorbisInfo.blocksizes[u],u===1){const d=(o|1)+1,p=t[0]&d?1:0;l=e.vorbisInfo.blocksizes[p]}n=l!==null?l+i>>2:0}else e.codec==="opus"&&(n=ya(t).durationInSamples);return{durationInSamples:n,vorbisBlockSize:i}},uo=t=>{let e="audio/ogg";if(t.codecStrings){const r=[...new Set(t.codecStrings)];e+=`; codecs="${r.join(", ")}"`}return e};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const St=27,Ht=27+255,ho=Ht+255*255,cr=t=>{const e=t.filePos;if(Vt(t)!==ds)return null;t.skip(1);const n=U(t),i=Zo(t),s=Vt(t),a=Vt(t),o=Vt(t),c=U(t),l=new Uint8Array(c);for(let g=0;g<c;g++)l[g]=U(t);const u=27+c,d=l.reduce((g,w)=>g+w,0),p=u+d;return{headerStartPos:e,totalSize:p,dataStartPos:e+u,dataSize:d,headerType:n,granulePosition:i,serialNumber:s,sequenceNumber:a,checksum:o,lacingValues:l}},fo=(t,e)=>{for(;t.filePos<e-(4-1);){const r=Vt(t),n=r&255,i=r>>>8&255,s=r>>>16&255,a=r>>>24&255,o=79;if(!(n!==o&&i!==o&&s!==o&&a!==o)){if(t.skip(-4),r===ds)return!0;t.skip(1)}}return!1};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class mo extends _t{constructor(e){super(e),this.metadataPromise=null,this.bitstreams=[],this.tracks=[],this.metadataTags={},this.reader=e._reader}async readMetadata(){return this.metadataPromise??(this.metadataPromise=(async()=>{let e=0;for(;;){let r=this.reader.requestSliceRange(e,St,Ht);if(r instanceof Promise&&(r=await r),!r)break;const n=cr(r);if(!n||!!!(n.headerType&2))break;this.bitstreams.push({serialNumber:n.serialNumber,bosPage:n,description:null,numberOfChannels:-1,sampleRate:-1,codecInfo:{codec:null,vorbisInfo:null,opusInfo:null},lastMetadataPacket:null}),e=n.headerStartPos+n.totalSize}for(const r of this.bitstreams){const n=await this.readPacket(r.bosPage,0);n&&(n.data.byteLength>=7&&n.data[0]===1&&n.data[1]===118&&n.data[2]===111&&n.data[3]===114&&n.data[4]===98&&n.data[5]===105&&n.data[6]===115?await this.readVorbisMetadata(n,r):n.data.byteLength>=8&&n.data[0]===79&&n.data[1]===112&&n.data[2]===117&&n.data[3]===115&&n.data[4]===72&&n.data[5]===101&&n.data[6]===97&&n.data[7]===100&&await this.readOpusMetadata(n,r),r.codecInfo.codec!==null&&this.tracks.push(new rt(this.input,new po(r,this))))}})())}async readVorbisMetadata(e,r){let n=await this.findNextPacketStart(e);if(!n)return;const i=await this.readPacket(n.startPage,n.startSegmentIndex);if(!i||(n=await this.findNextPacketStart(i),!n))return;const s=await this.readPacket(n.startPage,n.startSegmentIndex);if(!s||i.data[0]!==3||s.data[0]!==5)return;const a=[],o=d=>{for(;a.push(Math.min(255,d)),!(d<255);)d-=255};o(e.data.length),o(i.data.length);const c=new Uint8Array(1+a.length+e.data.length+i.data.length+s.data.length);c[0]=2,c.set(a,1),c.set(e.data,1+a.length),c.set(i.data,1+a.length+e.data.length),c.set(s.data,1+a.length+e.data.length+i.data.length),r.codecInfo.codec="vorbis",r.description=c,r.lastMetadataPacket=s;const l=Te(e.data);r.numberOfChannels=l.getUint8(11),r.sampleRate=l.getUint32(12,!0);const u=l.getUint8(28);r.codecInfo.vorbisInfo={blocksizes:[1<<(u&15),1<<(u>>4)],modeBlockflags:Sa(s.data).modeBlockflags},un(i.data.subarray(7),this.metadataTags)}async readOpusMetadata(e,r){const n=await this.findNextPacketStart(e);if(!n)return;const i=await this.readPacket(n.startPage,n.startSegmentIndex);if(!i)return;r.codecInfo.codec="opus",r.description=e.data,r.lastMetadataPacket=i;const s=Yi(e.data);r.numberOfChannels=s.outputChannelCount,r.sampleRate=Vr,r.codecInfo.opusInfo={preSkip:s.preSkip},un(i.data.subarray(8),this.metadataTags)}async readPacket(e,r){h(r<e.lacingValues.length);let n=0;for(let d=0;d<r;d++)n+=e.lacingValues[d];let i=e,s=n,a=r;const o=[];e:for(;;){let d=this.reader.requestSlice(i.dataStartPos,i.dataSize);d instanceof Promise&&(d=await d),h(d);const p=$(d,i.dataSize);for(;;){if(a===i.lacingValues.length){o.push(p.subarray(n,s));break}const w=i.lacingValues[a];if(s+=w,w<255){o.push(p.subarray(n,s));break e}a++}let g=i.headerStartPos+i.totalSize;for(;;){let w=this.reader.requestSliceRange(g,St,Ht);if(w instanceof Promise&&(w=await w),!w)return null;const m=cr(w);if(!m)return null;if(i=m,i.serialNumber===e.serialNumber)break;g=i.headerStartPos+i.totalSize}n=0,s=0,a=0}const c=o.reduce((d,p)=>d+p.length,0),l=new Uint8Array(c);let u=0;for(let d=0;d<o.length;d++){const p=o[d];l.set(p,u),u+=p.length}return{data:l,endPage:i,endSegmentIndex:a}}async findNextPacketStart(e){if(e.endSegmentIndex<e.endPage.lacingValues.length-1)return{startPage:e.endPage,startSegmentIndex:e.endSegmentIndex+1};if(!!(e.endPage.headerType&4))return null;let n=e.endPage.headerStartPos+e.endPage.totalSize;for(;;){let i=this.reader.requestSliceRange(n,St,Ht);if(i instanceof Promise&&(i=await i),!i)return null;const s=cr(i);if(!s)return null;if(s.serialNumber===e.endPage.serialNumber)return{startPage:s,startSegmentIndex:0};n=s.headerStartPos+s.totalSize}}async getMimeType(){await this.readMetadata();const e=await Promise.all(this.tracks.map(r=>r.getCodecParameterString()));return uo({codecStrings:e.filter(Boolean)})}async getTracks(){return await this.readMetadata(),this.tracks}async computeDuration(){const e=await this.getTracks(),r=await Promise.all(e.map(n=>n.computeDuration()));return Math.max(0,...r)}async getMetadataTags(){return await this.readMetadata(),this.metadataTags}}class po{constructor(e,r){this.bitstream=e,this.demuxer=r,this.encodedPacketToMetadata=new WeakMap,this.sequentialScanCache=[],this.sequentialScanMutex=new wt,this.internalSampleRate=e.codecInfo.codec==="opus"?Vr:e.sampleRate}getId(){return this.bitstream.serialNumber}getNumberOfChannels(){return this.bitstream.numberOfChannels}getSampleRate(){return this.bitstream.sampleRate}getTimeResolution(){return this.bitstream.sampleRate}getCodec(){return this.bitstream.codecInfo.codec}getInternalCodecId(){return null}async getDecoderConfig(){return h(this.bitstream.codecInfo.codec),{codec:this.bitstream.codecInfo.codec,numberOfChannels:this.bitstream.numberOfChannels,sampleRate:this.bitstream.sampleRate,description:this.bitstream.description??void 0}}getName(){return null}getLanguageCode(){return Fe}async getFirstTimestamp(){return 0}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return((e==null?void 0:e.timestamp)??0)+((e==null?void 0:e.duration)??0)}granulePositionToTimestampInSamples(e){return this.bitstream.codecInfo.codec==="opus"?(h(this.bitstream.codecInfo.opusInfo),e-this.bitstream.codecInfo.opusInfo.preSkip):e}createEncodedPacketFromOggPacket(e,r,n){if(!e)return null;const{durationInSamples:i,vorbisBlockSize:s}=lo(e.data,this.bitstream.codecInfo,r.vorbisLastBlocksize),a=new ie(n.metadataOnly?ze:e.data,"key",Math.max(0,r.timestampInSamples)/this.internalSampleRate,i/this.internalSampleRate,e.endPage.headerStartPos+e.endSegmentIndex,e.data.byteLength);return this.encodedPacketToMetadata.set(a,{packet:e,timestampInSamples:r.timestampInSamples,durationInSamples:i,vorbisLastBlockSize:r.vorbisLastBlocksize,vorbisBlockSize:s}),a}async getFirstPacket(e){h(this.bitstream.lastMetadataPacket);const r=await this.demuxer.findNextPacketStart(this.bitstream.lastMetadataPacket);if(!r)return null;let n=0;this.bitstream.codecInfo.codec==="opus"&&(h(this.bitstream.codecInfo.opusInfo),n-=this.bitstream.codecInfo.opusInfo.preSkip);const i=await this.demuxer.readPacket(r.startPage,r.startSegmentIndex);return this.createEncodedPacketFromOggPacket(i,{timestampInSamples:n,vorbisLastBlocksize:null},e)}async getNextPacket(e,r){const n=this.encodedPacketToMetadata.get(e);if(!n)throw new Error("Packet was not created from this track.");const i=await this.demuxer.findNextPacketStart(n.packet);if(!i)return null;const s=n.timestampInSamples+n.durationInSamples,a=await this.demuxer.readPacket(i.startPage,i.startSegmentIndex);return this.createEncodedPacketFromOggPacket(a,{timestampInSamples:s,vorbisLastBlocksize:n.vorbisBlockSize},r)}async getPacket(e,r){if(this.demuxer.reader.fileSize===null)return this.getPacketSequential(e,r);const n=vr(e*this.internalSampleRate,14);if(n===0)return this.getFirstPacket(r);if(n<0)return null;h(this.bitstream.lastMetadataPacket);const i=await this.demuxer.findNextPacketStart(this.bitstream.lastMetadataPacket);if(!i)return null;let s=i.startPage,a=this.demuxer.reader.fileSize;const o=[s];e:for(;s.headerStartPos+s.totalSize<a;){const b=s.headerStartPos,y=Math.floor((b+a)/2);let S=y;for(;;){const x=Math.min(S+ho,a-St);let _=this.demuxer.reader.requestSlice(S,x-S);if(_ instanceof Promise&&(_=await _),h(_),!fo(_,x)){a=y+St;continue e}let M=this.demuxer.reader.requestSliceRange(_.filePos,St,Ht);M instanceof Promise&&(M=await M),h(M);const F=cr(M);h(F);let z=!1;if(F.serialNumber===this.bitstream.serialNumber)z=!0;else{let L=this.demuxer.reader.requestSlice(F.headerStartPos,F.totalSize);L instanceof Promise&&(L=await L),h(L);const X=$(L,F.totalSize);z=co(X)===F.checksum}if(!z){S=F.headerStartPos+4;continue}if(z&&F.serialNumber!==this.bitstream.serialNumber){S=F.headerStartPos+F.totalSize;continue}if(F.granulePosition===-1){S=F.headerStartPos+F.totalSize;continue}this.granulePositionToTimestampInSamples(F.granulePosition)>n?a=F.headerStartPos:(s=F,o.push(F));continue e}}let c=i.startPage;for(const b of o){if(b.granulePosition===s.granulePosition)break;(!c||b.headerStartPos>c.headerStartPos)&&(c=b)}let l=c;const u=[l];for(;!(l.serialNumber===this.bitstream.serialNumber&&l.granulePosition===s.granulePosition);){const b=l.headerStartPos+l.totalSize;let y=this.demuxer.reader.requestSliceRange(b,St,Ht);y instanceof Promise&&(y=await y),h(y);const S=cr(y);h(S),l=S,l.serialNumber===this.bitstream.serialNumber&&u.push(l)}h(l.granulePosition!==-1);let d=null,p,g,w=l,m=0;if(l.headerStartPos===i.startPage.headerStartPos)p=this.granulePositionToTimestampInSamples(0),g=!0,d=0;else{p=0,g=!1;for(let S=l.lacingValues.length-1;S>=0;S--)if(l.lacingValues[S]<255){d=S+1;break}if(d===null)throw new Error("Invalid page with granule position: no packets end on this page.");m=d-1;const b={data:ze,endPage:w,endSegmentIndex:m};if(await this.demuxer.findNextPacketStart(b)){const S=li(u,l,d);h(S);const x=ci(u,S.page,S.segmentIndex);x&&(l=x.page,d=x.segmentIndex)}else for(;;){const S=li(u,l,d);if(!S)break;const x=ci(u,S.page,S.segmentIndex);if(!x)break;if(l=x.page,d=x.segmentIndex,S.page.headerStartPos!==w.headerStartPos){w=S.page,m=S.segmentIndex;break}}}let k=null,T=null;for(;l!==null;){h(d!==null);const b=await this.demuxer.readPacket(l,d);if(!b)break;if(!(l.headerStartPos===i.startPage.headerStartPos&&d<i.startSegmentIndex)){let x=this.createEncodedPacketFromOggPacket(b,{timestampInSamples:p,vorbisLastBlocksize:(T==null?void 0:T.vorbisBlockSize)??null},r);h(x);let _=this.encodedPacketToMetadata.get(x);if(h(_),!g&&b.endPage.headerStartPos===w.headerStartPos&&b.endSegmentIndex===m?(p=this.granulePositionToTimestampInSamples(l.granulePosition),g=!0,x=this.createEncodedPacketFromOggPacket(b,{timestampInSamples:p-_.durationInSamples,vorbisLastBlocksize:(T==null?void 0:T.vorbisBlockSize)??null},r),h(x),_=this.encodedPacketToMetadata.get(x),h(_)):p+=_.durationInSamples,k=x,T=_,g&&(Math.max(p,0)>n||Math.max(_.timestampInSamples,0)===n))break}const S=await this.demuxer.findNextPacketStart(b);if(!S)break;l=S.startPage,d=S.startSegmentIndex}return k}async getPacketSequential(e,r){const n=await this.sequentialScanMutex.acquire();try{const i=vr(e*this.internalSampleRate,14);e=i/this.internalSampleRate;const s=te(this.sequentialScanCache,i,c=>c.timestampInSamples);let a;if(s!==-1){const c=this.sequentialScanCache[s];a=this.createEncodedPacketFromOggPacket(c.packet,{timestampInSamples:c.timestampInSamples,vorbisLastBlocksize:c.vorbisLastBlockSize},r)}else a=await this.getFirstPacket(r);let o=0;for(;a&&a.timestamp<e;){const c=await this.getNextPacket(a,r);if(!c||c.timestamp>e)break;if(a=c,o++,o===100){o=0;const l=this.encodedPacketToMetadata.get(a);h(l),this.sequentialScanCache.length>0&&h(ue(this.sequentialScanCache).timestampInSamples<=l.timestampInSamples),this.sequentialScanCache.push(l)}}return a}finally{n()}}getKeyPacket(e,r){return this.getPacket(e,r)}getNextKeyPacket(e,r){return this.getNextPacket(e,r)}}const ci=(t,e,r)=>{let n=e,i=r;e:for(;;){for(i--,i;i>=0;i--)if(n.lacingValues[i]<255){i++;break e}if(h(i===-1),!(n.headerType&1)){i=0;break}const a=Bi(t,o=>o.headerStartPos<n.headerStartPos);if(!a)return null;n=a,i=n.lacingValues.length}if(h(i!==-1),i===n.lacingValues.length){const s=t[t.indexOf(n)+1];h(s),n=s,i=0}return{page:n,segmentIndex:i}},li=(t,e,r)=>{if(r>0)return{page:e,segmentIndex:r-1};const n=Bi(t,i=>i.headerStartPos<e.headerStartPos);return n?{page:n,segmentIndex:n.lacingValues.length-1}:null};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */var Ze;(function(t){t[t.PCM=1]="PCM",t[t.IEEE_FLOAT=3]="IEEE_FLOAT",t[t.ALAW=6]="ALAW",t[t.MULAW=7]="MULAW",t[t.EXTENSIBLE=65534]="EXTENSIBLE"})(Ze||(Ze={}));class go extends _t{constructor(e){super(e),this.metadataPromise=null,this.dataStart=-1,this.dataSize=-1,this.audioInfo=null,this.tracks=[],this.lastKnownPacketIndex=0,this.metadataTags={},this.reader=e._reader}async readMetadata(){return this.metadataPromise??(this.metadataPromise=(async()=>{let e=this.reader.requestSlice(0,12);e instanceof Promise&&(e=await e),h(e);const r=ge(e,4),n=r!=="RIFX",i=r==="RF64",s=mt(e,n);let a=i?this.reader.fileSize:Math.min(s+8,this.reader.fileSize??1/0);if(ge(e,4)!=="WAVE")throw new Error("Invalid WAVE file - wrong format");let c=0,l=null,u=e.filePos;for(;a===null||u<a;){let p=this.reader.requestSlice(u,8);if(p instanceof Promise&&(p=await p),!p)break;const g=ge(p,4),w=mt(p,n),m=p.filePos;if(i&&c===0&&g!=="ds64")throw new Error('Invalid RF64 file: First chunk must be "ds64".');if(g==="fmt ")await this.parseFmtChunk(m,w,n);else if(g==="data"){if(l??(l=w),this.dataStart=p.filePos,this.dataSize=Math.min(l,(a??1/0)-this.dataStart),this.reader.fileSize===null)break}else if(g==="ds64"){let k=this.reader.requestSlice(m,w);if(k instanceof Promise&&(k=await k),!k)break;const T=ui(k,n);l=ui(k,n),a=Math.min(T+8,this.reader.fileSize??1/0)}else g==="LIST"?await this.parseListChunk(m,w,n):(g==="ID3 "||g==="id3 ")&&await this.parseId3Chunk(m,w);u=m+w+(w&1),c++}if(!this.audioInfo)throw new Error('Invalid WAVE file - missing "fmt " chunk');if(this.dataStart===-1)throw new Error('Invalid WAVE file - missing "data" chunk');const d=this.audioInfo.blockSizeInBytes;this.dataSize=Math.floor(this.dataSize/d)*d,this.tracks.push(new rt(this.input,new bo(this)))})())}async parseFmtChunk(e,r,n){let i=this.reader.requestSlice(e,r);if(i instanceof Promise&&(i=await i),!i)return;let s=rr(i,n);const a=rr(i,n),o=mt(i,n);i.skip(4);const c=rr(i,n);let l;if(r===14?l=8:l=rr(i,n),r>=18&&s!==357){const u=rr(i,n),d=r-18;if(Math.min(d,u)>=22&&s===Ze.EXTENSIBLE){i.skip(2+4);const g=$(i,16);s=g[0]|g[1]<<8}}(s===Ze.MULAW||s===Ze.ALAW)&&(l=8),this.audioInfo={format:s,numberOfChannels:a,sampleRate:o,sampleSizeInBytes:Math.ceil(l/8),blockSizeInBytes:c}}async parseListChunk(e,r,n){var o,c,l,u,d,p,g,w,m,k,T;let i=this.reader.requestSlice(e,r);if(i instanceof Promise&&(i=await i),!i)return;const s=ge(i,4);if(s!=="INFO"&&s!=="INF0")return;let a=i.filePos;for(;a<=e+r-8;){i.filePos=a;const b=ge(i,4),y=mt(i,n),S=$(i,y);let x=0;for(let P=0;P<S.length&&S[P]!==0;P++)x++;const _=String.fromCharCode(...S.subarray(0,x));switch((o=this.metadataTags).raw??(o.raw={}),this.metadataTags.raw[b]=_,b){case"INAM":case"TITL":(c=this.metadataTags).title??(c.title=_);break;case"TIT3":(l=this.metadataTags).description??(l.description=_);break;case"IART":(u=this.metadataTags).artist??(u.artist=_);break;case"IPRD":(d=this.metadataTags).album??(d.album=_);break;case"IPRT":case"ITRK":case"TRCK":{const P=_.split("/"),M=Number.parseInt(P[0],10),F=P[1]&&Number.parseInt(P[1],10);Number.isInteger(M)&&M>0&&((p=this.metadataTags).trackNumber??(p.trackNumber=M)),F&&Number.isInteger(F)&&F>0&&((g=this.metadataTags).tracksTotal??(g.tracksTotal=F))}break;case"ICRD":case"IDIT":{const P=new Date(_);Number.isNaN(P.getTime())||((w=this.metadataTags).date??(w.date=P))}break;case"YEAR":{const P=Number.parseInt(_,10);Number.isInteger(P)&&P>0&&((m=this.metadataTags).date??(m.date=new Date(P,0,1)))}break;case"IGNR":case"GENR":(k=this.metadataTags).genre??(k.genre=_);break;case"ICMT":case"CMNT":case"COMM":(T=this.metadataTags).comment??(T.comment=_);break}a+=8+y+(y&1)}}async parseId3Chunk(e,r){let n=this.reader.requestSlice(e,r);if(n instanceof Promise&&(n=await n),!n)return;const i=Br(n);if(i){const s=n.slice(e+10,i.size);us(s,i,this.metadataTags)}}getCodec(){if(h(this.audioInfo),this.audioInfo.format===Ze.MULAW)return"ulaw";if(this.audioInfo.format===Ze.ALAW)return"alaw";if(this.audioInfo.format===Ze.PCM){if(this.audioInfo.sampleSizeInBytes===1)return"pcm-u8";if(this.audioInfo.sampleSizeInBytes===2)return"pcm-s16";if(this.audioInfo.sampleSizeInBytes===3)return"pcm-s24";if(this.audioInfo.sampleSizeInBytes===4)return"pcm-s32"}return this.audioInfo.format===Ze.IEEE_FLOAT&&this.audioInfo.sampleSizeInBytes===4?"pcm-f32":null}async getMimeType(){return"audio/wav"}async computeDuration(){await this.readMetadata();const e=this.tracks[0];return h(e),e.computeDuration()}async getTracks(){return await this.readMetadata(),this.tracks}async getMetadataTags(){return await this.readMetadata(),this.metadataTags}}const Ft=2048;class bo{constructor(e){this.demuxer=e}getId(){return 1}getCodec(){return this.demuxer.getCodec()}getInternalCodecId(){return h(this.demuxer.audioInfo),this.demuxer.audioInfo.format}async getDecoderConfig(){const e=this.demuxer.getCodec();return e?(h(this.demuxer.audioInfo),{codec:e,numberOfChannels:this.demuxer.audioInfo.numberOfChannels,sampleRate:this.demuxer.audioInfo.sampleRate}):null}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return((e==null?void 0:e.timestamp)??0)+((e==null?void 0:e.duration)??0)}getNumberOfChannels(){return h(this.demuxer.audioInfo),this.demuxer.audioInfo.numberOfChannels}getSampleRate(){return h(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}getTimeResolution(){return h(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}getName(){return null}getLanguageCode(){return Fe}async getFirstTimestamp(){return 0}async getPacketAtIndex(e,r){h(this.demuxer.audioInfo);const n=e*Ft*this.demuxer.audioInfo.blockSizeInBytes;if(n>=this.demuxer.dataSize)return null;const i=Math.min(Ft*this.demuxer.audioInfo.blockSizeInBytes,this.demuxer.dataSize-n);if(this.demuxer.reader.fileSize===null){let c=this.demuxer.reader.requestSlice(this.demuxer.dataStart+n,i);if(c instanceof Promise&&(c=await c),!c)return null}let s;if(r.metadataOnly)s=ze;else{let c=this.demuxer.reader.requestSlice(this.demuxer.dataStart+n,i);c instanceof Promise&&(c=await c),h(c),s=$(c,i)}const a=e*Ft/this.demuxer.audioInfo.sampleRate,o=i/this.demuxer.audioInfo.blockSizeInBytes/this.demuxer.audioInfo.sampleRate;return this.demuxer.lastKnownPacketIndex=Math.max(e,a),new ie(s,"key",a,o,e,i)}getFirstPacket(e){return this.getPacketAtIndex(0,e)}async getPacket(e,r){h(this.demuxer.audioInfo);const n=Math.floor(Math.min(e*this.demuxer.audioInfo.sampleRate/Ft,(this.demuxer.dataSize-1)/(Ft*this.demuxer.audioInfo.blockSizeInBytes))),i=await this.getPacketAtIndex(n,r);if(i)return i;if(n===0)return null;h(this.demuxer.reader.fileSize===null);let s=await this.getPacketAtIndex(this.demuxer.lastKnownPacketIndex,r);for(;s;){const a=await this.getNextPacket(s,r);if(!a)break;s=a}return s}getNextPacket(e,r){h(this.demuxer.audioInfo);const n=Math.round(e.timestamp*this.demuxer.audioInfo.sampleRate/Ft);return this.getPacketAtIndex(n+1,r)}getKeyPacket(e,r){return this.getPacket(e,r)}getNextKeyPacket(e,r){return this.getNextPacket(e,r)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const zr=7,Rr=9,kn=t=>{const e=t.filePos,r=$(t,9),n=new de(r);if(n.readBits(12)!==4095||(n.skipBits(1),n.readBits(2)!==0))return null;const a=n.readBits(1),o=n.readBits(2)+1,c=n.readBits(4);if(c===15)return null;n.skipBits(1);const l=n.readBits(3);if(l===0)throw new Error("ADTS frames with channel configuration 0 are not supported.");n.skipBits(1),n.skipBits(1),n.skipBits(1),n.skipBits(1);const u=n.readBits(13);n.skipBits(11);const d=n.readBits(2)+1;if(d!==1)throw new Error("ADTS frames with more than one AAC frame are not supported.");let p=null;return a===1?t.filePos-=2:p=n.readBits(16),{objectType:o,samplingFrequencyIndex:c,channelConfiguration:l,frameLength:u,numberOfAacFrames:d,crcCheck:p,startPos:e}};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Tn=1024;class wo extends _t{constructor(e){super(e),this.metadataPromise=null,this.firstFrameHeader=null,this.loadedSamples=[],this.tracks=[],this.readingMutex=new wt,this.lastSampleLoaded=!1,this.lastLoadedPos=0,this.nextTimestampInSamples=0,this.reader=e._reader}async readMetadata(){return this.metadataPromise??(this.metadataPromise=(async()=>{for(;!this.firstFrameHeader&&!this.lastSampleLoaded;)await this.advanceReader();h(this.firstFrameHeader),this.tracks=[new rt(this.input,new ko(this))]})())}async advanceReader(){let e=this.reader.requestSliceRange(this.lastLoadedPos,zr,Rr);if(e instanceof Promise&&(e=await e),!e){this.lastSampleLoaded=!0;return}const r=kn(e);if(!r){this.lastSampleLoaded=!0;return}if(this.reader.fileSize!==null&&r.startPos+r.frameLength>this.reader.fileSize){this.lastSampleLoaded=!0;return}this.firstFrameHeader||(this.firstFrameHeader=r);const n=Ir[r.samplingFrequencyIndex];h(n!==void 0);const i=Tn/n,s=r.crcCheck?Rr:zr,a={timestamp:this.nextTimestampInSamples/n,duration:i,dataStart:r.startPos+s,dataSize:r.frameLength-s};this.loadedSamples.push(a),this.nextTimestampInSamples+=Tn,this.lastLoadedPos=r.startPos+r.frameLength}async getMimeType(){return"audio/aac"}async getTracks(){return await this.readMetadata(),this.tracks}async computeDuration(){await this.readMetadata();const e=this.tracks[0];return h(e),e.computeDuration()}async getMetadataTags(){return{}}}class ko{constructor(e){this.demuxer=e}getId(){return 1}async getFirstTimestamp(){return 0}getTimeResolution(){return this.getSampleRate()/Tn}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return((e==null?void 0:e.timestamp)??0)+((e==null?void 0:e.duration)??0)}getName(){return null}getLanguageCode(){return Fe}getCodec(){return"aac"}getInternalCodecId(){return h(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.objectType}getNumberOfChannels(){h(this.demuxer.firstFrameHeader);const e=Ui[this.demuxer.firstFrameHeader.channelConfiguration];return h(e!==void 0),e}getSampleRate(){h(this.demuxer.firstFrameHeader);const e=Ir[this.demuxer.firstFrameHeader.samplingFrequencyIndex];return h(e!==void 0),e}async getDecoderConfig(){h(this.demuxer.firstFrameHeader);const e=new Uint8Array(3),r=new de(e),{objectType:n,samplingFrequencyIndex:i,channelConfiguration:s}=this.demuxer.firstFrameHeader;return n>31?(r.writeBits(5,31),r.writeBits(6,n-32)):r.writeBits(5,n),r.writeBits(4,i),r.writeBits(4,s),{codec:`mp4a.40.${this.demuxer.firstFrameHeader.objectType}`,numberOfChannels:this.getNumberOfChannels(),sampleRate:this.getSampleRate(),description:e.subarray(0,Math.ceil((r.pos-1)/8))}}async getPacketAtIndex(e,r){if(e===-1)return null;const n=this.demuxer.loadedSamples[e];if(!n)return null;let i;if(r.metadataOnly)i=ze;else{let s=this.demuxer.reader.requestSlice(n.dataStart,n.dataSize);if(s instanceof Promise&&(s=await s),!s)return null;i=$(s,n.dataSize)}return new ie(i,"key",n.timestamp,n.duration,e,n.dataSize)}getFirstPacket(e){return this.getPacketAtIndex(0,e)}async getNextPacket(e,r){const n=await this.demuxer.readingMutex.acquire();try{const i=fe(this.demuxer.loadedSamples,e.timestamp,a=>a.timestamp);if(i===-1)throw new Error("Packet was not created from this track.");const s=i+1;for(;s>=this.demuxer.loadedSamples.length&&!this.demuxer.lastSampleLoaded;)await this.demuxer.advanceReader();return this.getPacketAtIndex(s,r)}finally{n()}}async getPacket(e,r){const n=await this.demuxer.readingMutex.acquire();try{for(;;){const i=te(this.demuxer.loadedSamples,e,s=>s.timestamp);if(i===-1&&this.demuxer.loadedSamples.length>0)return null;if(this.demuxer.lastSampleLoaded)return this.getPacketAtIndex(i,r);if(i>=0&&i+1<this.demuxer.loadedSamples.length)return this.getPacketAtIndex(i,r);await this.demuxer.advanceReader()}}finally{n()}}getKeyPacket(e,r){return this.getPacket(e,r)}getNextKeyPacket(e,r){return this.getNextPacket(e,r)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const To=t=>t===0?null:t===1?192:t>=2&&t<=5?144*2**t:t===6?"uncommon-u8":t===7?"uncommon-u16":t>=8&&t<=15?2**t:null,yo=(t,e)=>{switch(t){case 0:return e;case 1:return 88200;case 2:return 176400;case 3:return 192e3;case 4:return 8e3;case 5:return 16e3;case 6:return 22050;case 7:return 24e3;case 8:return 32e3;case 9:return 44100;case 10:return 48e3;case 11:return 96e3;case 12:return"uncommon-u8";case 13:return"uncommon-u16";case 14:return"uncommon-u16-10";default:return null}},So=t=>{let e=0;const r=new de($(t,1));for(;r.readBits(1)===1;)e++;if(e===0)return r.readBits(7);const n=[],i=e-1,s=new de($(t,i)),a=8-e-1;for(let c=0;c<a;c++)n.unshift(r.readBits(1));for(let c=0;c<i;c++)for(let l=0;l<8;l++){const u=s.readBits(1);l<2||n.unshift(u)}return n.reduce((c,l,u)=>c|l<<u,0)},xo=(t,e)=>{if(e==="uncommon-u16")return be(t)+1;if(e==="uncommon-u8")return U(t)+1;if(typeof e=="number")return e;bt(e),h(!1)},Co=(t,e)=>e==="uncommon-u16"?be(t):e==="uncommon-u16-10"?be(t)*10:e==="uncommon-u8"?U(t):typeof e=="number"?e:null,Po=t=>{let r=0;for(const n of t){r^=n;for(let i=0;i<8;i++)r&128?r=r<<1^7:r<<=1,r&=255}return r};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class _o extends _t{constructor(e){super(e),this.loadedSamples=[],this.metadataPromise=null,this.track=null,this.metadataTags={},this.audioInfo=null,this.lastLoadedPos=null,this.blockingBit=null,this.readingMutex=new wt,this.lastSampleLoaded=!1,this.reader=e._reader}async computeDuration(){return await this.readMetadata(),h(this.track),this.track.computeDuration()}async getMetadataTags(){return await this.readMetadata(),this.metadataTags}async getTracks(){return await this.readMetadata(),h(this.track),[this.track]}async getMimeType(){return"audio/flac"}async readMetadata(){let e=4;return this.metadataPromise??(this.metadataPromise=(async()=>{var r;for(;this.reader.fileSize===null||e<this.reader.fileSize;){let n=this.reader.requestSlice(e,4);if(n instanceof Promise&&(n=await n),e+=4,n===null)throw new Error(`Metadata block at position ${e} is too small! Corrupted file.`);h(n);const i=U(n),s=Dt(n),a=(i&128)!==0;switch(i&127){case Lt.STREAMINFO:{let c=this.reader.requestSlice(e,s);if(c instanceof Promise&&(c=await c),h(c),c===null)throw new Error(`StreamInfo block at position ${e} is too small! Corrupted file.`);const l=$(c,34),u=new de(l),d=u.readBits(16),p=u.readBits(16),g=u.readBits(24),w=u.readBits(24),m=u.readBits(20),k=u.readBits(3)+1;u.readBits(5);const T=u.readBits(36);u.skipBits(16*8);const b=new Uint8Array(42);b.set(new Uint8Array([102,76,97,67]),0),b.set(new Uint8Array([128,0,0,34]),4),b.set(l,8),this.audioInfo={numberOfChannels:k,sampleRate:m,totalSamples:T,minimumBlockSize:d,maximumBlockSize:p,minimumFrameSize:g,maximumFrameSize:w,description:b},this.track=new rt(this.input,new vo(this));break}case Lt.VORBIS_COMMENT:{let c=this.reader.requestSlice(e,s);c instanceof Promise&&(c=await c),h(c),un($(c,s),this.metadataTags);break}case Lt.PICTURE:{let c=this.reader.requestSlice(e,s);c instanceof Promise&&(c=await c),h(c);const l=R(c),u=R(c),d=Be.decode($(c,u)),p=R(c),g=Be.decode($(c,p));c.skip(4+4+4+4);const w=R(c),m=$(c,w);(r=this.metadataTags).images??(r.images=[]),this.metadataTags.images.push({data:m,mimeType:d,kind:l===3?"coverFront":l===4?"coverBack":"unknown",description:g});break}}if(e+=s,a){this.lastLoadedPos=e;break}}})())}async readNextFlacFrame({startPos:e,isFirstPacket:r}){h(this.audioInfo);const n=6,i=16,s=this.audioInfo.maximumFrameSize+i,a=await this.reader.requestSliceRange(e,this.audioInfo.minimumFrameSize,s);if(!a)return null;const o=this.readFlacFrameHeader({slice:a,isFirstPacket:r});if(!o)return null;for(a.filePos=e+this.audioInfo.minimumFrameSize;;){if(a.filePos>a.end-n)return{num:o.num,blockSize:o.blockSize,sampleRate:o.sampleRate,size:a.end-e,isLastFrame:!0};if(U(a)===255){const l=U(a),u=this.blockingBit===1?249:248;if(l!==u){a.skip(-1);continue}a.skip(-2);const d=a.filePos-e;if(!this.readFlacFrameHeader({slice:a,isFirstPacket:!1})){a.skip(-1);continue}return{num:o.num,blockSize:o.blockSize,sampleRate:o.sampleRate,size:d,isLastFrame:!1}}}}readFlacFrameHeader({slice:e,isFirstPacket:r}){const n=e.filePos,i=$(e,4),s=new de(i);if(s.readBits(15)!==32764)return null;if(this.blockingBit===null){h(r);const k=s.readBits(1);this.blockingBit=k}else if(this.blockingBit===1){if(h(!r),s.readBits(1)!==1)return null}else if(this.blockingBit===0){if(h(!r),s.readBits(1)!==0)return null}else throw new Error("Invalid blocking bit");const o=To(s.readBits(4));if(!o)return null;h(this.audioInfo);const c=yo(s.readBits(4),this.audioInfo.sampleRate);if(!c||(s.readBits(4),s.readBits(3),s.readBits(1)!==0))return null;const u=So(e),d=xo(e,o),p=Co(e,c);if(p===null)return null;const g=e.filePos-n,w=U(e);e.skip(-g),e.skip(-1);const m=Po($(e,g));return w!==m?null:{num:u,blockSize:d,sampleRate:p}}async advanceReader(){await this.readMetadata(),h(this.lastLoadedPos!==null),h(this.audioInfo);const e=this.lastLoadedPos,r=await this.readNextFlacFrame({startPos:e,isFirstPacket:this.loadedSamples.length===0});if(!r){this.lastSampleLoaded=!0;return}const n=this.loadedSamples[this.loadedSamples.length-1],s={blockOffset:n?n.blockOffset+n.blockSize:0,blockSize:r.blockSize,byteOffset:e,byteSize:r.size};if(this.lastLoadedPos=this.lastLoadedPos+r.size,this.loadedSamples.push(s),r.isLastFrame){this.lastSampleLoaded=!0;return}}}class vo{constructor(e){this.demuxer=e}getId(){return 1}getCodec(){return"flac"}getInternalCodecId(){return null}getNumberOfChannels(){return h(this.demuxer.audioInfo),this.demuxer.audioInfo.numberOfChannels}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return((e==null?void 0:e.timestamp)??0)+((e==null?void 0:e.duration)??0)}getSampleRate(){return h(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}getName(){return null}getLanguageCode(){return Fe}getTimeResolution(){return h(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}async getFirstTimestamp(){return 0}async getDecoderConfig(){return h(this.demuxer.audioInfo),{codec:"flac",numberOfChannels:this.demuxer.audioInfo.numberOfChannels,sampleRate:this.demuxer.audioInfo.sampleRate,description:this.demuxer.audioInfo.description}}async getPacket(e,r){if(h(this.demuxer.audioInfo),e<0)throw new Error("Timestamp cannot be negative");const n=await this.demuxer.readingMutex.acquire();try{for(;;){const i=te(this.demuxer.loadedSamples,e,c=>c.blockOffset/this.demuxer.audioInfo.sampleRate);if(i===-1){await this.demuxer.advanceReader();continue}const s=this.demuxer.loadedSamples[i],a=s.blockOffset/this.demuxer.audioInfo.sampleRate,o=s.blockSize/this.demuxer.audioInfo.sampleRate;if(a+o<=e){if(this.demuxer.lastSampleLoaded)return this.getPacketAtIndex(this.demuxer.loadedSamples.length-1,r);await this.demuxer.advanceReader();continue}return this.getPacketAtIndex(i,r)}}finally{n()}}async getNextPacket(e,r){const n=await this.demuxer.readingMutex.acquire();try{const i=e.sequenceNumber+1;if(this.demuxer.lastSampleLoaded&&i>=this.demuxer.loadedSamples.length)return null;for(;i>=this.demuxer.loadedSamples.length&&!this.demuxer.lastSampleLoaded;)await this.demuxer.advanceReader();return this.getPacketAtIndex(i,r)}finally{n()}}getKeyPacket(e,r){return this.getPacket(e,r)}getNextKeyPacket(e,r){return this.getNextPacket(e,r)}async getPacketAtIndex(e,r){const n=this.demuxer.loadedSamples[e];if(!n)return null;let i;if(r.metadataOnly)i=ze;else{let o=this.demuxer.reader.requestSlice(n.byteOffset,n.byteSize);if(o instanceof Promise&&(o=await o),!o)return null;i=$(o,n.byteSize)}h(this.demuxer.audioInfo);const s=n.blockOffset/this.demuxer.audioInfo.sampleRate,a=n.blockSize/this.demuxer.audioInfo.sampleRate;return new ie(i,"key",s,a,e,n.byteSize)}async getFirstPacket(e){for(;this.demuxer.loadedSamples.length===0&&!this.demuxer.lastSampleLoaded;)await this.demuxer.advanceReader();return this.getPacketAtIndex(0,e)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Tt{}class fs extends Tt{async _getMajorBrand(e){let r=e._reader.requestSlice(0,12);return r instanceof Promise&&(r=await r),!r||(r.skip(4),ge(r,4)!=="ftyp")?null:ge(r,4)}_createDemuxer(e){return new Da(e)}}class Eo extends fs{async _canReadInput(e){const r=await this._getMajorBrand(e);return!!r&&r!=="qt  "}get name(){return"MP4"}get mimeType(){return"video/mp4"}}class Io extends fs{async _canReadInput(e){return await this._getMajorBrand(e)==="qt  "}get name(){return"QuickTime File Format"}get mimeType(){return"video/quicktime"}}class ms extends Tt{async isSupportedEBMLOfDocType(e,r){let n=e._reader.requestSlice(0,tt);if(n instanceof Promise&&(n=await n),!n)return!1;const i=is(n);if(i===null||i<1||i>8||Z(n,i)!==C.EBML)return!1;const a=ss(n);if(a===null)return!1;let o=e._reader.requestSlice(n.filePos,a);if(o instanceof Promise&&(o=await o),!o)return!1;const c=n.filePos;for(;o.filePos<=c+a-Ie;){const l=Je(o);if(!l)break;const{id:u,size:d}=l,p=o.filePos;if(d===null)return!1;switch(u){case C.EBMLVersion:if(Z(o,d)!==1)return!1;break;case C.EBMLReadVersion:if(Z(o,d)!==1)return!1;break;case C.DocType:if(Rt(o,d)!==r)return!1;break;case C.DocTypeVersion:if(Z(o,d)>4)return!1;break}o.filePos=p+d}return!0}_canReadInput(e){return this.isSupportedEBMLOfDocType(e,"matroska")}_createDemuxer(e){return new ja(e)}get name(){return"Matroska"}get mimeType(){return"video/x-matroska"}}class Fo extends ms{_canReadInput(e){return this.isSupportedEBMLOfDocType(e,"webm")}get name(){return"WebM"}get mimeType(){return"video/webm"}}class Ao extends Tt{async _canReadInput(e){let r=e._reader.requestSlice(0,10);if(r instanceof Promise&&(r=await r),!r)return!1;let n=0,i=!1;for(;;){let l=e._reader.requestSlice(n,Ar);if(l instanceof Promise&&(l=await l),!l)break;const u=Br(l);if(!u)break;i=!0,n=l.filePos+u.size}const s=await wn(e._reader,n,n+4096);if(!s)return!1;if(i)return!0;n=s.startPos+s.header.totalSize;const a=await wn(e._reader,n,n+ls);if(!a)return!1;const o=s.header,c=a.header;return!(o.channel!==c.channel||o.sampleRate!==c.sampleRate)}_createDemuxer(e){return new so(e)}get name(){return"MP3"}get mimeType(){return"audio/mpeg"}}class Bo extends Tt{async _canReadInput(e){let r=e._reader.requestSlice(0,12);if(r instanceof Promise&&(r=await r),!r)return!1;const n=ge(r,4);return n!=="RIFF"&&n!=="RIFX"&&n!=="RF64"?!1:(r.skip(4),ge(r,4)==="WAVE")}_createDemuxer(e){return new go(e)}get name(){return"WAVE"}get mimeType(){return"audio/wav"}}class zo extends Tt{async _canReadInput(e){let r=e._reader.requestSlice(0,4);return r instanceof Promise&&(r=await r),r?ge(r,4)==="OggS":!1}_createDemuxer(e){return new mo(e)}get name(){return"Ogg"}get mimeType(){return"application/ogg"}}class Ro extends Tt{async _canReadInput(e){let r=e._reader.requestSlice(0,4);return r instanceof Promise&&(r=await r),r?ge(r,4)==="fLaC":!1}get name(){return"FLAC"}get mimeType(){return"audio/flac"}_createDemuxer(e){return new _o(e)}}class Do extends Tt{async _canReadInput(e){let r=e._reader.requestSliceRange(0,zr,Rr);if(r instanceof Promise&&(r=await r),!r)return!1;const n=kn(r);if(!n||(r=e._reader.requestSliceRange(n.frameLength,zr,Rr),r instanceof Promise&&(r=await r),!r))return!1;const i=kn(r);return i?n.objectType===i.objectType&&n.samplingFrequencyIndex===i.samplingFrequencyIndex&&n.channelConfiguration===i.channelConfiguration:!1}_createDemuxer(e){return new wo(e)}get name(){return"ADTS"}get mimeType(){return"audio/aac"}}const Mo=new Eo,No=new Io,Oo=new ms,Vo=new Fo,Uo=new Ao,Wo=new Bo,Lo=new zo,Ho=new Do,qo=new Ro,$o=[Mo,No,Oo,Vo,Wo,Lo,qo,Uo,Ho];/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Rn{constructor(){this._disposed=!1,this._sizePromise=null,this.onread=null}async getSizeOrNull(){if(this._disposed)throw new _e;return this._sizePromise??(this._sizePromise=Promise.resolve(this._retrieveSize()))}async getSize(){if(this._disposed)throw new _e;const e=await this.getSizeOrNull();if(e===null)throw new Error("Cannot determine the size of an unsized source.");return e}}class jo extends Rn{constructor(e,r={}){if(!(e instanceof Blob))throw new TypeError("blob must be a Blob.");if(!r||typeof r!="object")throw new TypeError("options must be an object.");if(r.maxCacheSize!==void 0&&(!Number.isInteger(r.maxCacheSize)||r.maxCacheSize<0))throw new TypeError("options.maxCacheSize, when provided, must be a non-negative integer.");super(),this._readers=new WeakMap,this._blob=e,this._orchestrator=new bs({maxCacheSize:r.maxCacheSize??8*2**20,maxWorkerCount:4,runWorker:this._runWorker.bind(this),prefetchProfile:gs.fileSystem})}_retrieveSize(){const e=this._blob.size;return this._orchestrator.fileSize=e,e}_read(e,r){return this._orchestrator.read(e,r)}async _runWorker(e){var n,i;let r=this._readers.get(e);for(r===void 0&&("stream"in this._blob?r=this._blob.slice(e.currentPos).stream().getReader():r=null,this._readers.set(e,r));e.currentPos<e.targetPos&&!e.aborted;)if(r){const{done:s,value:a}=await r.read();if(s){if(this._orchestrator.forgetWorker(e),e.currentPos<e.targetPos)throw new Error("Blob reader stopped unexpectedly before all requested data was read.");break}(n=this.onread)==null||n.call(this,e.currentPos,e.currentPos+a.length),this._orchestrator.supplyWorkerData(e,a)}else{const s=await this._blob.slice(e.currentPos,e.targetPos).arrayBuffer();(i=this.onread)==null||i.call(this,e.currentPos,e.currentPos+s.byteLength),this._orchestrator.supplyWorkerData(e,new Uint8Array(s))}e.running=!1}_dispose(){this._orchestrator.dispose()}}const ps=.5*2**20,Ko=t=>Math.min(2**(t-2),16);class Qo extends Rn{constructor(e,r={}){if(typeof e!="string"&&!(e instanceof URL)&&!(typeof Request<"u"&&e instanceof Request))throw new TypeError("url must be a string, URL or Request.");if(!r||typeof r!="object")throw new TypeError("options must be an object.");if(r.requestInit!==void 0&&(!r.requestInit||typeof r.requestInit!="object"))throw new TypeError("options.requestInit, when provided, must be an object.");if(r.getRetryDelay!==void 0&&typeof r.getRetryDelay!="function")throw new TypeError("options.getRetryDelay, when provided, must be a function.");if(r.maxCacheSize!==void 0&&(!Number.isInteger(r.maxCacheSize)||r.maxCacheSize<0))throw new TypeError("options.maxCacheSize, when provided, must be a non-negative integer.");if(r.fetchFn!==void 0&&typeof r.fetchFn!="function")throw new TypeError("options.fetchFn, when provided, must be a function.");super(),this._existingResponses=new WeakMap,this._url=e,this._options=r,this._getRetryDelay=r.getRetryDelay??Ko,this._orchestrator=new bs({maxCacheSize:r.maxCacheSize??64*2**20,maxWorkerCount:2,runWorker:this._runWorker.bind(this),prefetchProfile:gs.network})}async _retrieveSize(){const e=new AbortController,r=await Xn(this._options.fetchFn??fetch,this._url,Qn(this._options.requestInit??{},{headers:{Range:"bytes=0-"},signal:e.signal}),this._getRetryDelay);if(!r.ok)throw new Error(`Error fetching ${String(this._url)}: ${r.status} ${r.statusText}`);let n,i;if(r.status===206)i=this._getPartialLengthFromRangeResponse(r),n=this._orchestrator.createWorker(0,Math.min(i,ps));else{const s=r.headers.get("Content-Length");if(s)i=Number(s),n=this._orchestrator.createWorker(0,i),this._orchestrator.options.maxCacheSize=1/0,console.warn("HTTP server did not respond with 206 Partial Content, meaning the entire remote resource now has to be downloaded. For efficient media file streaming across a network, please make sure your server supports range requests.");else throw new Error(`HTTP response (status ${r.status}) must surface Content-Length header.`)}return this._orchestrator.fileSize=i,this._existingResponses.set(n,{response:r,abortController:e}),this._orchestrator.runWorker(n),i}_read(e,r){return this._orchestrator.read(e,r)}async _runWorker(e){var r;for(;!e.aborted;){const n=this._existingResponses.get(e);this._existingResponses.delete(e);let i=n==null?void 0:n.abortController,s=n==null?void 0:n.response;if(i||(i=new AbortController,s=await Xn(this._options.fetchFn??fetch,this._url,Qn(this._options.requestInit??{},{headers:{Range:`bytes=${e.currentPos}-`},signal:i.signal}),this._getRetryDelay)),h(s),!s.ok)throw new Error(`Error fetching ${String(this._url)}: ${s.status} ${s.statusText}`);if(e.currentPos>0&&s.status!==206)throw new Error("HTTP server did not respond with 206 Partial Content to a range request. To enable efficient media file streaming across a network, please make sure your server supports range requests.");const a=this._getPartialLengthFromRangeResponse(s),o=e.targetPos-e.currentPos;if(a<o)throw new Error(`HTTP response unexpectedly too short: Needed at least ${o} bytes, got only ${a}.`);if(!s.body)throw new Error("Missing HTTP response body stream. The used fetch function must provide the response body as a ReadableStream.");const c=s.body.getReader();for(;;){if(e.currentPos>=e.targetPos||e.aborted){i.abort(),e.running=!1;return}let l;try{l=await c.read()}catch(p){const g=this._getRetryDelay(1,p);if(g!==null){console.error("Error while reading response stream. Attempting to resume.",p),await new Promise(w=>setTimeout(w,1e3*g));break}else throw p}const{done:u,value:d}=l;if(u){if(this._orchestrator.forgetWorker(e),e.currentPos<e.targetPos)throw new Error("Response stream reader stopped unexpectedly before all requested data was read.");e.running=!1;return}(r=this.onread)==null||r.call(this,e.currentPos,e.currentPos+d.length),this._orchestrator.supplyWorkerData(e,d)}}e.running=!1}_getPartialLengthFromRangeResponse(e){const r=e.headers.get("Content-Range");if(r){const n=/\/(\d+)/.exec(r);if(n)return Number(n[1]);throw new Error(`Invalid Content-Range header: ${r}`)}else{const n=e.headers.get("Content-Length");if(n)return Number(n);throw new Error("Partial HTTP response (status 206) must surface either Content-Range or Content-Length header.")}}_dispose(){this._orchestrator.dispose()}}const gs={none:(t,e)=>({start:t,end:e}),fileSystem:(t,e)=>(t=Math.floor((t-65536)/65536)*65536,e=Math.ceil((e+65536)/65536)*65536,{start:t,end:e}),network:(t,e,r)=>{t=Math.max(0,Math.floor((t-65536)/65536)*65536);for(const i of r){const a=Math.max((i.startPos+i.targetPos)/2,i.targetPos-8388608);if(on(t,e,a,i.targetPos)){const o=i.targetPos-i.startPos,c=Math.ceil((o+1)/8388608)*8388608,l=2**Math.ceil(Math.log2(o+1)),u=Math.min(l,c);e=Math.max(e,i.startPos+u)}}return e=Math.max(e,t+ps),{start:t,end:e}}};class bs{constructor(e){this.options=e,this.fileSize=null,this.nextAge=0,this.workers=[],this.cache=[],this.currentCacheSize=0}read(e,r){h(this.fileSize!==null);const n=this.options.prefetchProfile(e,r,this.workers),i=Math.max(n.start,0),s=Math.min(n.end,this.fileSize);h(i<=e&&r<=s);let a=null;const o=te(this.cache,e,b=>b.start),c=o!==-1?this.cache[o]:null;c&&c.start<=e&&r<=c.end&&(c.age=this.nextAge++,a={bytes:c.bytes,view:c.view,offset:c.start});const l=te(this.cache,i,b=>b.start),u=a?null:new Uint8Array(r-e);let d=0,p=i;const g=[];if(l!==-1){for(let b=l;b<this.cache.length;b++){const y=this.cache[b];if(y.start>=s)break;if(y.end<=i)continue;const S=Math.max(i,y.start),x=Math.min(s,y.end);if(h(S<=x),p<S&&g.push({start:p,end:S}),p=x,u){const _=Math.max(e,y.start),P=Math.min(r,y.end);if(_<P){const M=_-e;u.set(y.bytes.subarray(_-y.start,P-y.start),M),M===d&&(d=P-e)}}y.age=this.nextAge++}p<s&&g.push({start:p,end:s})}else g.push({start:i,end:s});if(u&&d>=u.length&&(a={bytes:u,view:Te(u),offset:e}),g.length===0)return h(a),a;const{promise:w,resolve:m,reject:k}=ke(),T=[];for(const b of g){const y=Math.max(e,b.start),S=Math.min(r,b.end);y===b.start&&S===b.end?T.push(b):y<S&&T.push({start:y,end:S})}for(const b of g){const y=u&&{start:e,bytes:u,holes:T,resolve:m,reject:k};let S=!1;for(const x of this.workers)if(on(b.start-131072,b.start,x.currentPos,x.targetPos)){x.targetPos=Math.max(x.targetPos,b.end),S=!0,y&&!x.pendingSlices.includes(y)&&x.pendingSlices.push(y),x.running||this.runWorker(x);break}if(!S){const x=this.createWorker(b.start,b.end);y&&(x.pendingSlices=[y]),this.runWorker(x)}}return a||(h(u),a=w.then(b=>({bytes:b,view:Te(b),offset:e}))),a}createWorker(e,r){const n={startPos:e,currentPos:e,targetPos:r,running:!1,aborted:!1,pendingSlices:[],age:this.nextAge++};for(this.workers.push(n);this.workers.length>this.options.maxWorkerCount;){let i=0,s=this.workers[0];for(let a=1;a<this.workers.length;a++){const o=this.workers[a];o.age<s.age&&(i=a,s=o)}if(s.running&&s.pendingSlices.length>0)break;s.aborted=!0,this.workers.splice(i,1)}return n}runWorker(e){h(!e.running),h(e.currentPos<e.targetPos),e.running=!0,e.age=this.nextAge++,this.options.runWorker(e).catch(r=>{if(e.running=!1,e.pendingSlices.length>0)e.pendingSlices.forEach(n=>n.reject(r)),e.pendingSlices.length=0;else throw r})}supplyWorkerData(e,r){const n=e.currentPos,i=n+r.length;this.insertIntoCache({start:n,end:i,bytes:r,view:Te(r),age:this.nextAge++}),e.currentPos+=r.length,e.targetPos=Math.max(e.targetPos,e.currentPos);for(let s=0;s<e.pendingSlices.length;s++){const a=e.pendingSlices[s],o=Math.max(n,a.start),c=Math.min(i,a.start+a.bytes.length);o<c&&a.bytes.set(r.subarray(o-n,c-n),o-a.start);for(let l=0;l<a.holes.length;l++){const u=a.holes[l];n<=u.start&&i>u.start&&(u.start=i),u.end<=u.start&&(a.holes.splice(l,1),l--)}a.holes.length===0&&(a.resolve(a.bytes),e.pendingSlices.splice(s,1),s--)}for(let s=0;s<this.workers.length;s++){const a=this.workers[s];e===a||a.running||on(n,i,a.currentPos,a.targetPos)&&(this.workers.splice(s,1),s--)}}forgetWorker(e){const r=this.workers.indexOf(e);h(r!==-1),this.workers.splice(r,1)}insertIntoCache(e){if(this.options.maxCacheSize===0)return;let r=te(this.cache,e.start,n=>n.start)+1;if(r>0){const n=this.cache[r-1];if(n.end>=e.end)return;if(n.end>e.start){const i=new Uint8Array(e.end-n.start);i.set(n.bytes,0),i.set(e.bytes,e.start-n.start),this.currentCacheSize+=e.end-n.end,n.bytes=i,n.view=Te(i),n.end=e.end,r--,e=n}else this.cache.splice(r,0,e),this.currentCacheSize+=e.bytes.length}else this.cache.splice(r,0,e),this.currentCacheSize+=e.bytes.length;for(let n=r+1;n<this.cache.length;n++){const i=this.cache[n];if(e.end<=i.start)break;if(e.end>=i.end){this.cache.splice(n,1),this.currentCacheSize-=i.bytes.length,n--;continue}const s=new Uint8Array(i.end-e.start);s.set(e.bytes,0),s.set(i.bytes,i.start-e.start),this.currentCacheSize-=e.end-i.start,e.bytes=s,e.view=Te(s),e.end=i.end,this.cache.splice(n,1);break}for(;this.currentCacheSize>this.options.maxCacheSize;){let n=0,i=this.cache[0];for(let s=1;s<this.cache.length;s++){const a=this.cache[s];a.age<i.age&&(n=s,i=a)}if(this.currentCacheSize-i.bytes.length<=this.options.maxCacheSize)break;this.cache.splice(n,1),this.currentCacheSize-=i.bytes.length}}dispose(){for(const e of this.workers)e.aborted=!0;this.workers.length=0,this.cache.length=0}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */Mi();class ws{get disposed(){return this._disposed}constructor(e){if(this._demuxerPromise=null,this._format=null,this._disposed=!1,!e||typeof e!="object")throw new TypeError("options must be an object.");if(!Array.isArray(e.formats)||e.formats.some(r=>!(r instanceof Tt)))throw new TypeError("options.formats must be an array of InputFormat.");if(!(e.source instanceof Rn))throw new TypeError("options.source must be a Source.");if(e.source._disposed)throw new Error("options.source must not be disposed.");this._formats=e.formats,this._source=e.source,this._reader=new Go(e.source)}_getDemuxer(){return this._demuxerPromise??(this._demuxerPromise=(async()=>{this._reader.fileSize=await this._source.getSizeOrNull();for(const e of this._formats)if(await e._canReadInput(this))return this._format=e,e._createDemuxer(this);throw new Error("Input has an unsupported or unrecognizable format.")})())}get source(){return this._source}async getFormat(){return await this._getDemuxer(),h(this._format),this._format}async computeDuration(){return(await this._getDemuxer()).computeDuration()}async getTracks(){return(await this._getDemuxer()).getTracks()}async getVideoTracks(){return(await this.getTracks()).filter(r=>r.isVideoTrack())}async getAudioTracks(){return(await this.getTracks()).filter(r=>r.isAudioTrack())}async getPrimaryVideoTrack(){return(await this.getTracks()).find(r=>r.isVideoTrack())??null}async getPrimaryAudioTrack(){return(await this.getTracks()).find(r=>r.isAudioTrack())??null}async getMimeType(){return(await this._getDemuxer()).getMimeType()}async getMetadataTags(){return(await this._getDemuxer()).getMetadataTags()}dispose(){this._disposed||(this._disposed=!0,this._source._disposed=!0,this._source._dispose())}[Symbol.dispose](){this.dispose()}}class _e extends Error{constructor(e="Input has been disposed."){super(e),this.name="InputDisposedError"}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Go{constructor(e){this.source=e}requestSlice(e,r){if(this.source._disposed)throw new _e;if(this.fileSize!==null&&e+r>this.fileSize)return null;const n=e+r,i=this.source._read(e,n);return i instanceof Promise?i.then(s=>s?new $t(s.bytes,s.view,s.offset,e,n):null):i?new $t(i.bytes,i.view,i.offset,e,n):null}requestSliceRange(e,r,n){if(this.source._disposed)throw new _e;if(this.fileSize!==null)return this.requestSlice(e,pe(this.fileSize-e,r,n));{const i=this.requestSlice(e,n),s=a=>{if(a)return a;const o=l=>(h(l!==null),this.requestSlice(e,pe(l-e,r,n))),c=this.source._retrieveSize();return c instanceof Promise?c.then(o):o(c)};return i instanceof Promise?i.then(s):s(i)}}}class $t{constructor(e,r,n,i,s){this.bytes=e,this.view=r,this.offset=n,this.start=i,this.end=s,this.bufferPos=i-n}static tempFromBytes(e){return new $t(e,Te(e),0,0,e.length)}get length(){return this.end-this.start}get filePos(){return this.offset+this.bufferPos}set filePos(e){this.bufferPos=e-this.offset}get remainingLength(){return Math.max(this.end-this.filePos,0)}skip(e){this.bufferPos+=e}slice(e,r=this.end-e){if(e<this.start||e+r>this.end)throw new RangeError("Slicing outside of original slice.");return new $t(this.bytes,this.view,this.offset,e,e+r)}}const xe=(t,e)=>{if(t.filePos<t.start||t.filePos+e>t.end)throw new RangeError(`Tried reading [${t.filePos}, ${t.filePos+e}), but slice is [${t.start}, ${t.end}). This is likely an internal error, please report it alongside the file that caused it.`)},$=(t,e)=>{xe(t,e);const r=t.bytes.subarray(t.bufferPos,t.bufferPos+e);return t.bufferPos+=e,r},U=t=>(xe(t,1),t.view.getUint8(t.bufferPos++)),rr=(t,e)=>{xe(t,2);const r=t.view.getUint16(t.bufferPos,e);return t.bufferPos+=2,r},be=t=>{xe(t,2);const e=t.view.getUint16(t.bufferPos,!1);return t.bufferPos+=2,e},Dt=t=>{xe(t,3);const e=Nr(t.view,t.bufferPos,!1);return t.bufferPos+=3,e},yn=t=>{xe(t,2);const e=t.view.getInt16(t.bufferPos,!1);return t.bufferPos+=2,e},mt=(t,e)=>{xe(t,4);const r=t.view.getUint32(t.bufferPos,e);return t.bufferPos+=4,r},R=t=>{xe(t,4);const e=t.view.getUint32(t.bufferPos,!1);return t.bufferPos+=4,e},Vt=t=>{xe(t,4);const e=t.view.getUint32(t.bufferPos,!0);return t.bufferPos+=4,e},xt=t=>{xe(t,4);const e=t.view.getInt32(t.bufferPos,!1);return t.bufferPos+=4,e},Xo=t=>{xe(t,4);const e=t.view.getInt32(t.bufferPos,!0);return t.bufferPos+=4,e},ui=(t,e)=>{let r,n;return e?(r=mt(t,!0),n=mt(t,!0)):(n=mt(t,!1),r=mt(t,!1)),n*4294967296+r},Me=t=>{const e=R(t),r=R(t);return e*4294967296+r},Yo=t=>{const e=xt(t),r=R(t);return e*4294967296+r},Zo=t=>{const e=Vt(t);return Xo(t)*4294967296+e},Jo=t=>{xe(t,4);const e=t.view.getFloat32(t.bufferPos,!1);return t.bufferPos+=4,e},ks=t=>{xe(t,8);const e=t.view.getFloat64(t.bufferPos,!1);return t.bufferPos+=8,e},ge=(t,e)=>{xe(t,e);let r="";for(let n=0;n<e;n++)r+=String.fromCharCode(t.bytes[t.bufferPos++]);return r};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const di=/<(?:(\d{2}):)?(\d{2}):(\d{2}).(\d{3})>/g,ec=t=>{const e=Math.floor(t/36e5),r=Math.floor(t%(60*60*1e3)/(60*1e3)),n=Math.floor(t%(60*1e3)/1e3),i=t%1e3;return e.toString().padStart(2,"0")+":"+r.toString().padStart(2,"0")+":"+n.toString().padStart(2,"0")+"."+i.toString().padStart(3,"0")};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class hi{constructor(e){this.writer=e,this.helper=new Uint8Array(8),this.helperView=new DataView(this.helper.buffer),this.offsets=new WeakMap}writeU32(e){this.helperView.setUint32(0,e,!1),this.writer.write(this.helper.subarray(0,4))}writeU64(e){this.helperView.setUint32(0,Math.floor(e/2**32),!1),this.helperView.setUint32(4,e,!1),this.writer.write(this.helper.subarray(0,8))}writeAscii(e){for(let r=0;r<e.length;r++)this.helperView.setUint8(r%8,e.charCodeAt(r)),r%8===7&&this.writer.write(this.helper);e.length%8!==0&&this.writer.write(this.helper.subarray(0,e.length%8))}writeBox(e){if(this.offsets.set(e,this.writer.getPos()),e.contents&&!e.children)this.writeBoxHeader(e,e.size??e.contents.byteLength+8),this.writer.write(e.contents);else{const r=this.writer.getPos();if(this.writeBoxHeader(e,0),e.contents&&this.writer.write(e.contents),e.children)for(const s of e.children)s&&this.writeBox(s);const n=this.writer.getPos(),i=e.size??n-r;this.writer.seek(r),this.writeBoxHeader(e,i),this.writer.seek(n)}}writeBoxHeader(e,r){this.writeU32(e.largeSize?1:r),this.writeAscii(e.type),e.largeSize&&this.writeU64(r)}measureBoxHeader(e){return 8+(e.largeSize?8:0)}patchBox(e){const r=this.offsets.get(e);h(r!==void 0);const n=this.writer.getPos();this.writer.seek(r),this.writeBox(e),this.writer.seek(n)}measureBox(e){if(e.contents&&!e.children)return this.measureBoxHeader(e)+e.contents.byteLength;{let r=this.measureBoxHeader(e);if(e.contents&&(r+=e.contents.byteLength),e.children)for(const n of e.children)n&&(r+=this.measureBox(n));return r}}}const Y=new Uint8Array(8),Qe=new DataView(Y.buffer),ae=t=>[(t%256+256)%256],W=t=>(Qe.setUint16(0,t,!1),[Y[0],Y[1]]),Ts=t=>(Qe.setInt16(0,t,!1),[Y[0],Y[1]]),ys=t=>(Qe.setUint32(0,t,!1),[Y[1],Y[2],Y[3]]),B=t=>(Qe.setUint32(0,t,!1),[Y[0],Y[1],Y[2],Y[3]]),dt=t=>(Qe.setInt32(0,t,!1),[Y[0],Y[1],Y[2],Y[3]]),Ct=t=>(Qe.setUint32(0,Math.floor(t/2**32),!1),Qe.setUint32(4,t,!1),[Y[0],Y[1],Y[2],Y[3],Y[4],Y[5],Y[6],Y[7]]),Ss=t=>(Qe.setInt16(0,2**8*t,!1),[Y[0],Y[1]]),et=t=>(Qe.setInt32(0,2**16*t,!1),[Y[0],Y[1],Y[2],Y[3]]),Yr=t=>(Qe.setInt32(0,2**30*t,!1),[Y[0],Y[1],Y[2],Y[3]]),Zr=(t,e)=>{const r=[];let n=t;do{let i=n&127;n>>=7,r.length>0&&(i|=128),r.push(i),e!==void 0&&e--}while(n>0||e);return r.reverse()},we=(t,e=!1)=>{const r=Array(t.length).fill(null).map((n,i)=>t.charCodeAt(i));return e&&r.push(0),r},Dn=t=>{let e=null;for(const r of t)(!e||r.timestamp>e.timestamp)&&(e=r);return e},xs=t=>{const e=t*(Math.PI/180),r=Math.round(Math.cos(e)),n=Math.round(Math.sin(e));return[r,n,0,-n,r,0,0,0,1]},Cs=xs(0),Ps=t=>[et(t[0]),et(t[1]),Yr(t[2]),et(t[3]),et(t[4]),Yr(t[5]),et(t[6]),et(t[7]),Yr(t[8])],q=(t,e,r)=>({type:t,contents:e&&new Uint8Array(e.flat(10)),children:r}),J=(t,e,r,n,i)=>q(t,[ae(e),ys(r),n??[]],i),tc=t=>t.isQuickTime?q("ftyp",[we("qt  "),B(512),we("qt  ")]):t.fragmented?q("ftyp",[we("iso5"),B(512),we("iso5"),we("iso6"),we("mp41")]):q("ftyp",[we("isom"),B(512),we("isom"),t.holdsAvc?we("avc1"):[],we("mp41")]),Tr=t=>({type:"mdat",largeSize:t}),rc=t=>({type:"free",size:t}),nr=t=>q("moov",void 0,[nc(t.creationTime,t.trackDatas),...t.trackDatas.map(e=>ic(e,t.creationTime)),t.isFragmented?Vc(t.trackDatas):null,Zc(t)]),nc=(t,e)=>{const r=me(Math.max(0,...e.filter(a=>a.samples.length>0).map(a=>{const o=Dn(a.samples);return o.timestamp+o.duration})),Sn),n=Math.max(0,...e.map(a=>a.track.id))+1,i=!qt(t)||!qt(r),s=i?Ct:B;return J("mvhd",+i,0,[s(t),s(t),B(Sn),s(r),et(1),Ss(1),Array(10).fill(0),Ps(Cs),Array(24).fill(0),B(n)])},ic=(t,e)=>{const r=ul(t);return q("trak",void 0,[sc(t,e),ac(t,e),r.name!==void 0?q("udta",void 0,[q("name",[...He.encode(r.name)])]):null])},sc=(t,e)=>{const r=Dn(t.samples),n=me(r?r.timestamp+r.duration:0,Sn),i=!qt(e)||!qt(n),s=i?Ct:B;let a;if(t.type==="video"){const o=t.track.metadata.rotation;a=xs(o??0)}else a=Cs;return J("tkhd",+i,3,[s(e),s(e),B(t.track.id),B(0),s(n),Array(8).fill(0),W(0),W(t.track.id),Ss(t.type==="audio"?1:0),W(0),Ps(a),et(t.type==="video"?t.info.width:0),et(t.type==="video"?t.info.height:0)])},ac=(t,e)=>q("mdia",void 0,[oc(t,e),Mn(!0,cc[t.type],lc[t.type]),uc(t)]),oc=(t,e)=>{const r=Dn(t.samples),n=me(r?r.timestamp+r.duration:0,t.timescale),i=!qt(e)||!qt(n),s=i?Ct:B;return J("mdhd",+i,0,[s(e),s(e),B(t.timescale),s(n),W(Is(t.track.metadata.languageCode??Fe)),W(0)])},cc={video:"vide",audio:"soun",subtitle:"text"},lc={video:"MediabunnyVideoHandler",audio:"MediabunnySoundHandler",subtitle:"MediabunnyTextHandler"},Mn=(t,e,r,n="\0\0\0\0")=>J("hdlr",0,0,[t?we("mhlr"):B(0),we(e),we(n),B(0),B(0),we(r,!0)]),uc=t=>q("minf",void 0,[mc[t.type](),pc(),wc(t)]),dc=()=>J("vmhd",0,1,[W(0),W(0),W(0),W(0)]),hc=()=>J("smhd",0,0,[W(0),W(0)]),fc=()=>J("nmhd",0,0),mc={video:dc,audio:hc,subtitle:fc},pc=()=>q("dinf",void 0,[gc()]),gc=()=>J("dref",0,0,[B(1)],[bc()]),bc=()=>J("url ",0,1),wc=t=>{const e=t.compositionTimeOffsetTable.length>1||t.compositionTimeOffsetTable.some(r=>r.sampleCompositionTimeOffset!==0);return q("stbl",void 0,[kc(t),Bc(t),e?Nc(t):null,e?Oc(t):null,Rc(t),Dc(t),Mc(t),zc(t)])},kc=t=>{let e;if(t.type==="video")e=Tc(rl[t.track.source._codec],t);else if(t.type==="audio"){const r=Es(t.track.source._codec,t.muxer.isQuickTime);h(r),e=Pc(r,t)}else t.type==="subtitle"&&(e=Fc(sl[t.track.source._codec],t));return h(e),J("stsd",0,0,[B(1)],[e])},Tc=(t,e)=>q(t,[Array(6).fill(0),W(1),W(0),W(0),Array(12).fill(0),W(e.info.width),W(e.info.height),B(4718592),B(4718592),B(0),W(1),Array(32).fill(0),W(24),Ts(65535)],[nl[e.track.source._codec](e),Vs(e.info.decoderConfig.colorSpace)?yc(e):null]),yc=t=>q("colr",[we("nclx"),W(mr[t.info.decoderConfig.colorSpace.primaries]),W(pr[t.info.decoderConfig.colorSpace.transfer]),W(gr[t.info.decoderConfig.colorSpace.matrix]),ae((t.info.decoderConfig.colorSpace.fullRange?1:0)<<7)]),Sc=t=>t.info.decoderConfig&&q("avcC",[...$e(t.info.decoderConfig.description)]),xc=t=>t.info.decoderConfig&&q("hvcC",[...$e(t.info.decoderConfig.description)]),fi=t=>{var p,g,w,m;if(!t.info.decoderConfig)return null;const e=t.info.decoderConfig,r=e.codec.split("."),n=Number(r[1]),i=Number(r[2]),s=Number(r[3]),a=r[4]?Number(r[4]):1,o=r[8]?Number(r[8]):Number(((p=e.colorSpace)==null?void 0:p.fullRange)??0),c=(s<<4)+(a<<1)+o,l=r[5]?Number(r[5]):(g=e.colorSpace)!=null&&g.primaries?mr[e.colorSpace.primaries]:2,u=r[6]?Number(r[6]):(w=e.colorSpace)!=null&&w.transfer?pr[e.colorSpace.transfer]:2,d=r[7]?Number(r[7]):(m=e.colorSpace)!=null&&m.matrix?gr[e.colorSpace.matrix]:2;return J("vpcC",1,0,[ae(n),ae(i),ae(c),ae(l),ae(u),ae(d),W(0)])},Cc=t=>q("av1C",Xs(t.info.decoderConfig.codec)),Pc=(t,e)=>{var s;let r=0,n,i=16;if(ye.includes(e.track.source._codec)){const a=e.track.source._codec,{sampleSize:o}=kt(a);i=8*o,i>16&&(r=1)}return r===0?n=[Array(6).fill(0),W(1),W(r),W(0),B(0),W(e.info.numberOfChannels),W(i),W(0),W(0),W(e.info.sampleRate<2**16?e.info.sampleRate:0),W(0)]:n=[Array(6).fill(0),W(1),W(r),W(0),B(0),W(e.info.numberOfChannels),W(Math.min(i,16)),W(0),W(0),W(e.info.sampleRate<2**16?e.info.sampleRate:0),W(0),B(1),B(i/8),B(e.info.numberOfChannels*i/8),B(2)],q(t,n,[((s=il(e.track.source._codec,e.muxer.isQuickTime))==null?void 0:s(e))??null])},Jr=t=>{let e;switch(t.track.source._codec){case"aac":e=64;break;case"mp3":e=107;break;case"vorbis":e=221;break;default:throw new Error(`Unhandled audio codec: ${t.track.source._codec}`)}let r=[...ae(e),...ae(21),...ys(0),...B(0),...B(0)];if(t.info.decoderConfig.description){const n=$e(t.info.decoderConfig.description);r=[...r,...ae(5),...Zr(n.byteLength),...n]}return r=[...W(1),...ae(0),...ae(4),...Zr(r.length),...r,...ae(6),...ae(1),...ae(2)],r=[...ae(3),...Zr(r.length),...r],J("esds",0,0,r)},ot=t=>q("wave",void 0,[_c(t),vc(t),q("\0\0\0\0")]),_c=t=>q("frma",[we(Es(t.track.source._codec,t.muxer.isQuickTime))]),vc=t=>{const{littleEndian:e}=kt(t.track.source._codec);return q("enda",[W(+e)])},Ec=t=>{var c;let e=t.info.numberOfChannels,r=3840,n=t.info.sampleRate,i=0,s=0,a=new Uint8Array(0);const o=(c=t.info.decoderConfig)==null?void 0:c.description;if(o){h(o.byteLength>=18);const l=$e(o),u=Yi(l);e=u.outputChannelCount,r=u.preSkip,n=u.inputSampleRate,i=u.outputGain,s=u.channelMappingFamily,u.channelMappingTable&&(a=u.channelMappingTable)}return q("dOps",[ae(0),ae(e),W(r),B(n),Ts(i),ae(s),...a])},Ic=t=>{var n;const e=(n=t.info.decoderConfig)==null?void 0:n.description;h(e);const r=$e(e);return J("dfLa",0,0,[...r.subarray(4)])},We=t=>{const{littleEndian:e,sampleSize:r}=kt(t.track.source._codec),n=+e;return J("pcmC",0,0,[ae(n),ae(8*r)])},Fc=(t,e)=>q(t,[Array(6).fill(0),W(1)],[al[e.track.source._codec](e)]),Ac=t=>q("vttC",[...He.encode(t.info.config.description)]),Bc=t=>J("stts",0,0,[B(t.timeToSampleTable.length),t.timeToSampleTable.map(e=>[B(e.sampleCount),B(e.sampleDelta)])]),zc=t=>{if(t.samples.every(r=>r.type==="key"))return null;const e=[...t.samples.entries()].filter(([,r])=>r.type==="key");return J("stss",0,0,[B(e.length),e.map(([r])=>B(r+1))])},Rc=t=>J("stsc",0,0,[B(t.compactlyCodedChunkTable.length),t.compactlyCodedChunkTable.map(e=>[B(e.firstChunk),B(e.samplesPerChunk),B(1)])]),Dc=t=>{if(t.type==="audio"&&t.info.requiresPcmTransformation){const{sampleSize:e}=kt(t.track.source._codec);return J("stsz",0,0,[B(e*t.info.numberOfChannels),B(t.samples.reduce((r,n)=>r+me(n.duration,t.timescale),0))])}return J("stsz",0,0,[B(0),B(t.samples.length),t.samples.map(e=>B(e.size))])},Mc=t=>t.finalizedChunks.length>0&&ue(t.finalizedChunks).offset>=2**32?J("co64",0,0,[B(t.finalizedChunks.length),t.finalizedChunks.map(e=>Ct(e.offset))]):J("stco",0,0,[B(t.finalizedChunks.length),t.finalizedChunks.map(e=>B(e.offset))]),Nc=t=>J("ctts",1,0,[B(t.compositionTimeOffsetTable.length),t.compositionTimeOffsetTable.map(e=>[B(e.sampleCount),dt(e.sampleCompositionTimeOffset)])]),Oc=t=>{let e=1/0,r=-1/0,n=1/0,i=-1/0;h(t.compositionTimeOffsetTable.length>0),h(t.samples.length>0);for(let a=0;a<t.compositionTimeOffsetTable.length;a++){const o=t.compositionTimeOffsetTable[a];e=Math.min(e,o.sampleCompositionTimeOffset),r=Math.max(r,o.sampleCompositionTimeOffset)}for(let a=0;a<t.samples.length;a++){const o=t.samples[a];n=Math.min(n,me(o.timestamp,t.timescale)),i=Math.max(i,me(o.timestamp+o.duration,t.timescale))}const s=Math.max(-e,0);return i>=2**31?null:J("cslg",0,0,[dt(s),dt(e),dt(r),dt(n),dt(i)])},Vc=t=>q("mvex",void 0,t.map(Uc)),Uc=t=>J("trex",0,0,[B(t.track.id),B(1),B(0),B(0),B(0)]),mi=(t,e)=>q("moof",void 0,[Wc(t),...e.map(Lc)]),Wc=t=>J("mfhd",0,0,[B(t)]),_s=t=>{let e=0,r=0;const n=0,i=0,s=t.type==="delta";return r|=+s,s?e|=1:e|=2,e<<24|r<<16|n<<8|i},Lc=t=>q("traf",void 0,[Hc(t),qc(t),$c(t)]),Hc=t=>{h(t.currentChunk);let e=0;e|=8,e|=16,e|=32,e|=131072;const r=t.currentChunk.samples[1]??t.currentChunk.samples[0],n={duration:r.timescaleUnitsToNextSample,size:r.size,flags:_s(r)};return J("tfhd",0,e,[B(t.track.id),B(n.duration),B(n.size),B(n.flags)])},qc=t=>(h(t.currentChunk),J("tfdt",1,0,[Ct(me(t.currentChunk.startTimestamp,t.timescale))])),$c=t=>{h(t.currentChunk);const e=t.currentChunk.samples.map(m=>m.timescaleUnitsToNextSample),r=t.currentChunk.samples.map(m=>m.size),n=t.currentChunk.samples.map(_s),i=t.currentChunk.samples.map(m=>me(m.timestamp-m.decodeTimestamp,t.timescale)),s=new Set(e),a=new Set(r),o=new Set(n),c=new Set(i),l=o.size===2&&n[0]!==n[1],u=s.size>1,d=a.size>1,p=!l&&o.size>1,g=c.size>1||[...c].some(m=>m!==0);let w=0;return w|=1,w|=4*+l,w|=256*+u,w|=512*+d,w|=1024*+p,w|=2048*+g,J("trun",1,w,[B(t.currentChunk.samples.length),B(t.currentChunk.offset-t.currentChunk.moofOffset||0),l?B(n[0]):[],t.currentChunk.samples.map((m,k)=>[u?B(e[k]):[],d?B(r[k]):[],p?B(n[k]):[],g?dt(i[k]):[]])])},jc=t=>q("mfra",void 0,[...t.map(Kc),Qc()]),Kc=(t,e)=>J("tfra",1,0,[B(t.track.id),B(63),B(t.finalizedChunks.length),t.finalizedChunks.map(n=>[Ct(me(n.samples[0].timestamp,t.timescale)),Ct(n.moofOffset),B(e+1),B(1),B(1)])]),Qc=()=>J("mfro",0,0,[B(0)]),Gc=()=>q("vtte"),Xc=(t,e,r,n,i)=>q("vttc",void 0,[i!==null?q("vsid",[dt(i)]):null,r!==null?q("iden",[...He.encode(r)]):null,e!==null?q("ctim",[...He.encode(ec(e))]):null,n!==null?q("sttg",[...He.encode(n)]):null,q("payl",[...He.encode(t)])]),Yc=t=>q("vtta",[...He.encode(t)]),Zc=t=>{const e=[],r=t.format._options.metadataFormat??"auto",n=t.output._metadataTags;if(r==="mdir"||r==="auto"&&!t.isQuickTime){const i=el(n);i&&e.push(i)}else if(r==="mdta"){const i=tl(n);i&&e.push(i)}else(r==="udta"||r==="auto"&&t.isQuickTime)&&Jc(e,t.output._metadataTags);return e.length===0?null:q("udta",void 0,e)},Jc=(t,e)=>{for(const{key:r,value:n}of Di(e))switch(r){case"title":t.push(Le("nam",n));break;case"description":t.push(Le("des",n));break;case"artist":t.push(Le("ART",n));break;case"album":t.push(Le("alb",n));break;case"albumArtist":t.push(Le("albr",n));break;case"genre":t.push(Le("gen",n));break;case"date":t.push(Le("day",n.toISOString().slice(0,10)));break;case"comment":t.push(Le("cmt",n));break;case"lyrics":t.push(Le("lyr",n));break;case"raw":break;case"discNumber":case"discsTotal":case"trackNumber":case"tracksTotal":case"images":break;default:bt(r)}if(e.raw)for(const r in e.raw){const n=e.raw[r];n==null||r.length!==4||t.some(i=>i.type===r)||(typeof n=="string"?t.push(Le(r,n)):n instanceof Uint8Array&&t.push(q(r,Array.from(n))))}},Le=(t,e)=>{const r=He.encode(e);return q(t,[W(r.length),W(Is("und")),Array.from(r)])},pi={"image/jpeg":13,"image/png":14,"image/bmp":27},vs=(t,e)=>{const r=[];for(const{key:n,value:i}of Di(t))switch(n){case"title":r.push({key:e?"title":"nam",value:De(i)});break;case"description":r.push({key:e?"description":"des",value:De(i)});break;case"artist":r.push({key:e?"artist":"ART",value:De(i)});break;case"album":r.push({key:e?"album":"alb",value:De(i)});break;case"albumArtist":r.push({key:e?"album_artist":"aART",value:De(i)});break;case"comment":r.push({key:e?"comment":"cmt",value:De(i)});break;case"genre":r.push({key:e?"genre":"gen",value:De(i)});break;case"lyrics":r.push({key:e?"lyrics":"lyr",value:De(i)});break;case"date":r.push({key:e?"date":"day",value:De(i.toISOString().slice(0,10))});break;case"images":for(const s of i)s.kind==="coverFront"&&r.push({key:"covr",value:q("data",[B(pi[s.mimeType]??0),B(0),Array.from(s.data)])});break;case"trackNumber":if(e){const s=t.tracksTotal!==void 0?`${i}/${t.tracksTotal}`:i.toString();r.push({key:"track",value:De(s)})}else r.push({key:"trkn",value:q("data",[B(0),B(0),W(0),W(i),W(t.tracksTotal??0),W(0)])});break;case"discNumber":e||r.push({key:"disc",value:q("data",[B(0),B(0),W(0),W(i),W(t.discsTotal??0),W(0)])});break;case"tracksTotal":case"discsTotal":break;case"raw":break;default:bt(n)}if(t.raw)for(const n in t.raw){const i=t.raw[n];i==null||!e&&n.length!==4||r.some(s=>s.key===n)||(typeof i=="string"?r.push({key:n,value:De(i)}):i instanceof Uint8Array?r.push({key:n,value:q("data",[B(0),B(0),Array.from(i)])}):i instanceof Ut&&r.push({key:n,value:q("data",[B(pi[i.mimeType]??0),B(0),Array.from(i.data)])}))}return r},el=t=>{const e=vs(t,!1);return e.length===0?null:J("meta",0,0,void 0,[Mn(!1,"mdir","","appl"),q("ilst",void 0,e.map(r=>q(r.key,void 0,[r.value])))])},tl=t=>{const e=vs(t,!0);return e.length===0?null:q("meta",void 0,[Mn(!1,"mdta",""),J("keys",0,0,[B(e.length)],e.map(r=>q("mdta",[...He.encode(r.key)]))),q("ilst",void 0,e.map((r,n)=>{const i=String.fromCharCode(...B(n+1));return q(i,void 0,[r.value])}))])},De=t=>q("data",[B(1),B(0),...He.encode(t)]),rl={avc:"avc1",hevc:"hvc1",vp8:"vp08",vp9:"vp09",av1:"av01"},nl={avc:Sc,hevc:xc,vp8:fi,vp9:fi,av1:Cc},Es=(t,e)=>{switch(t){case"aac":return"mp4a";case"mp3":return"mp4a";case"opus":return"Opus";case"vorbis":return"mp4a";case"flac":return"fLaC";case"ulaw":return"ulaw";case"alaw":return"alaw";case"pcm-u8":return"raw ";case"pcm-s8":return"sowt"}if(e)switch(t){case"pcm-s16":return"sowt";case"pcm-s16be":return"twos";case"pcm-s24":return"in24";case"pcm-s24be":return"in24";case"pcm-s32":return"in32";case"pcm-s32be":return"in32";case"pcm-f32":return"fl32";case"pcm-f32be":return"fl32";case"pcm-f64":return"fl64";case"pcm-f64be":return"fl64"}else switch(t){case"pcm-s16":return"ipcm";case"pcm-s16be":return"ipcm";case"pcm-s24":return"ipcm";case"pcm-s24be":return"ipcm";case"pcm-s32":return"ipcm";case"pcm-s32be":return"ipcm";case"pcm-f32":return"fpcm";case"pcm-f32be":return"fpcm";case"pcm-f64":return"fpcm";case"pcm-f64be":return"fpcm"}},il=(t,e)=>{switch(t){case"aac":return Jr;case"mp3":return Jr;case"opus":return Ec;case"vorbis":return Jr;case"flac":return Ic}if(e)switch(t){case"pcm-s24":return ot;case"pcm-s24be":return ot;case"pcm-s32":return ot;case"pcm-s32be":return ot;case"pcm-f32":return ot;case"pcm-f32be":return ot;case"pcm-f64":return ot;case"pcm-f64be":return ot}else switch(t){case"pcm-s16":return We;case"pcm-s16be":return We;case"pcm-s24":return We;case"pcm-s24be":return We;case"pcm-s32":return We;case"pcm-s32be":return We;case"pcm-f32":return We;case"pcm-f32be":return We;case"pcm-f64":return We;case"pcm-f64be":return We}return null},sl={webvtt:"wvtt"},al={webvtt:Ac},Is=t=>{h(t.length===3);let e=0;for(let r=0;r<3;r++)e<<=5,e+=t.charCodeAt(r)-96;return e};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Fs{constructor(){this.ensureMonotonicity=!1,this.trackedWrites=null,this.trackedStart=-1,this.trackedEnd=-1}start(){}maybeTrackWrites(e){if(!this.trackedWrites)return;let r=this.getPos();if(r<this.trackedStart){if(r+e.byteLength<=this.trackedStart)return;e=e.subarray(this.trackedStart-r),r=0}const n=r+e.byteLength-this.trackedStart;let i=this.trackedWrites.byteLength;for(;i<n;)i*=2;if(i!==this.trackedWrites.byteLength){const s=new Uint8Array(i);s.set(this.trackedWrites,0),this.trackedWrites=s}this.trackedWrites.set(e,r-this.trackedStart),this.trackedEnd=Math.max(this.trackedEnd,r+e.byteLength)}startTrackingWrites(){this.trackedWrites=new Uint8Array(2**10),this.trackedStart=this.getPos(),this.trackedEnd=this.trackedStart}stopTrackingWrites(){if(!this.trackedWrites)throw new Error("Internal error: Can't get tracked writes since nothing was tracked.");const r={data:this.trackedWrites.subarray(0,this.trackedEnd-this.trackedStart),start:this.trackedStart,end:this.trackedEnd};return this.trackedWrites=null,r}}const en=2**16,tn=2**32;class As extends Fs{constructor(e){if(super(),this.pos=0,this.maxPos=0,this.target=e,this.supportsResize="resize"in new ArrayBuffer(0),this.supportsResize)try{this.buffer=new ArrayBuffer(en,{maxByteLength:tn})}catch{this.buffer=new ArrayBuffer(en),this.supportsResize=!1}else this.buffer=new ArrayBuffer(en);this.bytes=new Uint8Array(this.buffer)}ensureSize(e){let r=this.buffer.byteLength;for(;r<e;)r*=2;if(r!==this.buffer.byteLength){if(r>tn)throw new Error(`ArrayBuffer exceeded maximum size of ${tn} bytes. Please consider using another target.`);if(this.supportsResize)this.buffer.resize(r);else{const n=new ArrayBuffer(r),i=new Uint8Array(n);i.set(this.bytes,0),this.buffer=n,this.bytes=i}}}write(e){var r,n;this.maybeTrackWrites(e),this.ensureSize(this.pos+e.byteLength),this.bytes.set(e,this.pos),(n=(r=this.target).onwrite)==null||n.call(r,this.pos,this.pos+e.byteLength),this.pos+=e.byteLength,this.maxPos=Math.max(this.maxPos,this.pos)}seek(e){this.pos=e}getPos(){return this.pos}async flush(){}async finalize(){this.ensureSize(this.pos),this.target.buffer=this.buffer.slice(0,Math.max(this.maxPos,this.pos))}async close(){}getSlice(e,r){return this.bytes.slice(e,r)}}class ol extends Fs{constructor(e){super(),this.target=e,this.pos=0}write(e){var r,n;this.maybeTrackWrites(e),(n=(r=this.target).onwrite)==null||n.call(r,this.pos,this.pos+e.byteLength),this.pos+=e.byteLength}getPos(){return this.pos}seek(e){this.pos=e}async flush(){}async finalize(){}async close(){}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Nn{constructor(){this._output=null,this.onwrite=null}}class Bs extends Nn{constructor(){super(...arguments),this.buffer=null}_createWriter(){return new As(this)}}class cl extends Nn{_createWriter(){return new ol(this)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Sn=1e3,ll=2082844800,ul=t=>{const e={},r=t.track;return r.metadata.name!==void 0&&(e.name=r.metadata.name),e},me=(t,e,r=!0)=>{const n=t*e;return r?Math.round(n):n};class dl extends la{constructor(e,r){super(e),this.auxTarget=new Bs,this.auxWriter=this.auxTarget._createWriter(),this.auxBoxWriter=new hi(this.auxWriter),this.mdat=null,this.ftypSize=null,this.trackDatas=[],this.allTracksKnown=ke(),this.creationTime=Math.floor(Date.now()/1e3)+ll,this.finalizedChunks=[],this.nextFragmentNumber=1,this.maxWrittenTimestamp=-1/0,this.format=r,this.writer=e._writer,this.boxWriter=new hi(this.writer),this.isQuickTime=r instanceof Ds;const n=this.writer instanceof As?"in-memory":!1;this.fastStart=r._options.fastStart??n,this.isFragmented=this.fastStart==="fragmented",(this.fastStart==="in-memory"||this.isFragmented)&&(this.writer.ensureMonotonicity=!0),this.minimumFragmentDuration=r._options.minimumFragmentDuration??1}async start(){const e=await this.mutex.acquire(),r=this.output._tracks.some(n=>n.type==="video"&&n.source._codec==="avc");if(this.format._options.onFtyp&&this.writer.startTrackingWrites(),this.boxWriter.writeBox(tc({isQuickTime:this.isQuickTime,holdsAvc:r,fragmented:this.isFragmented})),this.format._options.onFtyp){const{data:n,start:i}=this.writer.stopTrackingWrites();this.format._options.onFtyp(n,i)}if(this.ftypSize=this.writer.getPos(),this.fastStart!=="in-memory")if(this.fastStart==="reserve"){for(const n of this.output._tracks)if(n.metadata.maximumPacketCount===void 0)throw new Error("All tracks must specify maximumPacketCount in their metadata when using fastStart: 'reserve'.")}else this.isFragmented||(this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat=Tr(!0),this.boxWriter.writeBox(this.mdat));await this.writer.flush(),e()}allTracksAreKnown(){for(const e of this.output._tracks)if(!e.source._closed&&!this.trackDatas.some(r=>r.track===e))return!1;return!0}async getMimeType(){await this.allTracksKnown.promise;const e=this.trackDatas.map(r=>r.type==="video"||r.type==="audio"?r.info.decoderConfig.codec:{webvtt:"wvtt"}[r.track.source._codec]);return rs({isQuickTime:this.isQuickTime,hasVideo:this.trackDatas.some(r=>r.type==="video"),hasAudio:this.trackDatas.some(r=>r.type==="audio"),codecStrings:e})}getVideoTrackData(e,r,n){const i=this.trackDatas.find(l=>l.track===e);if(i)return i;sa(n),h(n),h(n.decoderConfig);const s={...n.decoderConfig};h(s.codedWidth!==void 0),h(s.codedHeight!==void 0);let a=!1;if(e.source._codec==="avc"&&!s.description){const l=$i(r.data);if(!l)throw new Error("Couldn't extract an AVCDecoderConfigurationRecord from the AVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.264) when not providing a description, or provide a description (must be an AVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in AVCC format.");s.description=ha(l),a=!0}else if(e.source._codec==="hevc"&&!s.description){const l=Ki(r.data);if(!l)throw new Error("Couldn't extract an HEVCDecoderConfigurationRecord from the HEVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.265) when not providing a description, or provide a description (must be an HEVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in HEVC format.");s.description=ka(l),a=!0}const o=Ks(1/(e.metadata.frameRate??57600),1e6).denominator,c={muxer:this,track:e,type:"video",info:{width:s.codedWidth,height:s.codedHeight,decoderConfig:s,requiresAnnexBTransformation:a},timescale:o,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(c),this.trackDatas.sort((l,u)=>l.track.id-u.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),c}getAudioTrackData(e,r){const n=this.trackDatas.find(s=>s.track===e);if(n)return n;oa(r),h(r),h(r.decoderConfig);const i={muxer:this,track:e,type:"audio",info:{numberOfChannels:r.decoderConfig.numberOfChannels,sampleRate:r.decoderConfig.sampleRate,decoderConfig:r.decoderConfig,requiresPcmTransformation:!this.isFragmented&&ye.includes(e.source._codec)},timescale:r.decoderConfig.sampleRate,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(i),this.trackDatas.sort((s,a)=>s.track.id-a.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),i}getSubtitleTrackData(e,r){const n=this.trackDatas.find(s=>s.track===e);if(n)return n;ca(r),h(r),h(r.config);const i={muxer:this,track:e,type:"subtitle",info:{config:r.config},timescale:1e3,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[],lastCueEndTimestamp:0,cueQueue:[],nextSourceId:0,cueToSourceId:new WeakMap};return this.trackDatas.push(i),this.trackDatas.sort((s,a)=>s.track.id-a.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),i}async addEncodedVideoPacket(e,r,n){const i=await this.mutex.acquire();try{const s=this.getVideoTrackData(e,r,n);let a=r.data;if(s.info.requiresAnnexBTransformation){const l=ua(a);if(!l)throw new Error("Failed to transform packet data. Make sure all packets are provided in Annex B format, as specified in ITU-T-REC-H.264 and ITU-T-REC-H.265.");a=l}const o=this.validateAndNormalizeTimestamp(s.track,r.timestamp,r.type==="key"),c=this.createSampleForTrack(s,a,o,r.duration,r.type);await this.registerSample(s,c)}finally{i()}}async addEncodedAudioPacket(e,r,n){const i=await this.mutex.acquire();try{const s=this.getAudioTrackData(e,n),a=this.validateAndNormalizeTimestamp(s.track,r.timestamp,r.type==="key"),o=this.createSampleForTrack(s,r.data,a,r.duration,r.type);s.info.requiresPcmTransformation&&await this.maybePadWithSilence(s,a),await this.registerSample(s,o)}finally{i()}}async maybePadWithSilence(e,r){const n=ue(e.samples),i=n?n.timestamp+n.duration:0,s=r-i,a=me(s,e.timescale);if(a>0){const{sampleSize:o,silentValue:c}=kt(e.info.decoderConfig.codec),l=a*e.info.numberOfChannels,u=new Uint8Array(o*l).fill(c),d=this.createSampleForTrack(e,new Uint8Array(u.buffer),i,s,"key");await this.registerSample(e,d)}}async addSubtitleCue(e,r,n){const i=await this.mutex.acquire();try{const s=this.getSubtitleTrackData(e,n);this.validateAndNormalizeTimestamp(s.track,r.timestamp,!0),e.source._codec==="webvtt"&&(s.cueQueue.push(r),await this.processWebVTTCues(s,r.timestamp))}finally{i()}}async processWebVTTCues(e,r){for(;e.cueQueue.length>0;){const n=new Set([]);for(const l of e.cueQueue)h(l.timestamp<=r),h(e.lastCueEndTimestamp<=l.timestamp+l.duration),n.add(Math.max(l.timestamp,e.lastCueEndTimestamp)),n.add(l.timestamp+l.duration);const i=[...n].sort((l,u)=>l-u),s=i[0],a=i[1]??s;if(r<a)break;if(e.lastCueEndTimestamp<s){this.auxWriter.seek(0);const l=Gc();this.auxBoxWriter.writeBox(l);const u=this.auxWriter.getSlice(0,this.auxWriter.getPos()),d=this.createSampleForTrack(e,u,e.lastCueEndTimestamp,s-e.lastCueEndTimestamp,"key");await this.registerSample(e,d),e.lastCueEndTimestamp=s}this.auxWriter.seek(0);for(let l=0;l<e.cueQueue.length;l++){const u=e.cueQueue[l];if(u.timestamp>=a)break;di.lastIndex=0;const d=di.test(u.text),p=u.timestamp+u.duration;let g=e.cueToSourceId.get(u);if(g===void 0&&a<p&&(g=e.nextSourceId++,e.cueToSourceId.set(u,g)),u.notes){const m=Yc(u.notes);this.auxBoxWriter.writeBox(m)}const w=Xc(u.text,d?s:null,u.identifier??null,u.settings??null,g??null);this.auxBoxWriter.writeBox(w),p===a&&e.cueQueue.splice(l--,1)}const o=this.auxWriter.getSlice(0,this.auxWriter.getPos()),c=this.createSampleForTrack(e,o,s,a-s,"key");await this.registerSample(e,c),e.lastCueEndTimestamp=a}}createSampleForTrack(e,r,n,i,s){return{timestamp:n,decodeTimestamp:n,duration:i,data:r,size:r.byteLength,type:s,timescaleUnitsToNextSample:me(i,e.timescale)}}processTimestamps(e,r){if(e.timestampProcessingQueue.length===0)return;if(e.type==="audio"&&e.info.requiresPcmTransformation){let i=0;for(let s=0;s<e.timestampProcessingQueue.length;s++){const a=e.timestampProcessingQueue[s],o=me(a.duration,e.timescale);i+=o}if(e.timeToSampleTable.length===0)e.timeToSampleTable.push({sampleCount:i,sampleDelta:1});else{const s=ue(e.timeToSampleTable);s.sampleCount+=i}e.timestampProcessingQueue.length=0;return}const n=e.timestampProcessingQueue.map(i=>i.timestamp).sort((i,s)=>i-s);for(let i=0;i<e.timestampProcessingQueue.length;i++){const s=e.timestampProcessingQueue[i];s.decodeTimestamp=n[i],!this.isFragmented&&e.lastTimescaleUnits===null&&(s.decodeTimestamp=0);const a=me(s.timestamp-s.decodeTimestamp,e.timescale),o=me(s.duration,e.timescale);if(e.lastTimescaleUnits!==null){h(e.lastSample);const c=me(s.decodeTimestamp,e.timescale,!1),l=Math.round(c-e.lastTimescaleUnits);if(h(l>=0),e.lastTimescaleUnits+=l,e.lastSample.timescaleUnitsToNextSample=l,!this.isFragmented){let u=ue(e.timeToSampleTable);if(h(u),u.sampleCount===1){u.sampleDelta=l;const p=e.timeToSampleTable[e.timeToSampleTable.length-2];p&&p.sampleDelta===l&&(p.sampleCount++,e.timeToSampleTable.pop(),u=p)}else u.sampleDelta!==l&&(u.sampleCount--,e.timeToSampleTable.push(u={sampleCount:1,sampleDelta:l}));u.sampleDelta===o?u.sampleCount++:e.timeToSampleTable.push({sampleCount:1,sampleDelta:o});const d=ue(e.compositionTimeOffsetTable);h(d),d.sampleCompositionTimeOffset===a?d.sampleCount++:e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:a})}}else e.lastTimescaleUnits=me(s.decodeTimestamp,e.timescale,!1),this.isFragmented||(e.timeToSampleTable.push({sampleCount:1,sampleDelta:o}),e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:a}));e.lastSample=s}if(e.timestampProcessingQueue.length=0,h(e.lastSample),h(e.lastTimescaleUnits!==null),r!==void 0&&e.lastSample.timescaleUnitsToNextSample===0){h(r.type==="key");const i=me(r.timestamp,e.timescale,!1),s=Math.round(i-e.lastTimescaleUnits);e.lastSample.timescaleUnitsToNextSample=s}}async registerSample(e,r){r.type==="key"&&this.processTimestamps(e,r),e.timestampProcessingQueue.push(r),this.isFragmented?(e.sampleQueue.push(r),await this.interleaveSamples()):this.fastStart==="reserve"?await this.registerSampleFastStartReserve(e,r):await this.addSampleToTrack(e,r)}async addSampleToTrack(e,r){if(!this.isFragmented&&(e.samples.push(r),this.fastStart==="reserve")){const i=e.track.metadata.maximumPacketCount;if(h(i!==void 0),e.samples.length>i)throw new Error(`Track #${e.track.id} has already reached the maximum packet count (${i}). Either add less packets or increase the maximum packet count.`)}let n=!1;if(!e.currentChunk)n=!0;else{e.currentChunk.startTimestamp=Math.min(e.currentChunk.startTimestamp,r.timestamp);const i=r.timestamp-e.currentChunk.startTimestamp;if(this.isFragmented){const s=this.trackDatas.every(a=>{if(e===a)return r.type==="key";const o=a.sampleQueue[0];return o?o.type==="key":a.track.source._closed});i>=this.minimumFragmentDuration&&s&&r.timestamp>this.maxWrittenTimestamp&&(n=!0,await this.finalizeFragment())}else n=i>=.5}n&&(e.currentChunk&&await this.finalizeCurrentChunk(e),e.currentChunk={startTimestamp:r.timestamp,samples:[],offset:null,moofOffset:null}),h(e.currentChunk),e.currentChunk.samples.push(r),this.isFragmented&&(this.maxWrittenTimestamp=Math.max(this.maxWrittenTimestamp,r.timestamp))}async finalizeCurrentChunk(e){if(h(!this.isFragmented),!e.currentChunk)return;e.finalizedChunks.push(e.currentChunk),this.finalizedChunks.push(e.currentChunk);let r=e.currentChunk.samples.length;if(e.type==="audio"&&e.info.requiresPcmTransformation&&(r=e.currentChunk.samples.reduce((n,i)=>n+me(i.duration,e.timescale),0)),(e.compactlyCodedChunkTable.length===0||ue(e.compactlyCodedChunkTable).samplesPerChunk!==r)&&e.compactlyCodedChunkTable.push({firstChunk:e.finalizedChunks.length,samplesPerChunk:r}),this.fastStart==="in-memory"){e.currentChunk.offset=0;return}e.currentChunk.offset=this.writer.getPos();for(const n of e.currentChunk.samples)h(n.data),this.writer.write(n.data),n.data=null;await this.writer.flush()}async interleaveSamples(e=!1){if(h(this.isFragmented),!(!e&&!this.allTracksAreKnown()))e:for(;;){let r=null,n=1/0;for(const s of this.trackDatas){if(!e&&s.sampleQueue.length===0&&!s.track.source._closed)break e;s.sampleQueue.length>0&&s.sampleQueue[0].timestamp<n&&(r=s,n=s.sampleQueue[0].timestamp)}if(!r)break;const i=r.sampleQueue.shift();await this.addSampleToTrack(r,i)}}async finalizeFragment(e=!0){h(this.isFragmented);const r=this.nextFragmentNumber++;if(r===1){this.format._options.onMoov&&this.writer.startTrackingWrites();const g=nr(this);if(this.boxWriter.writeBox(g),this.format._options.onMoov){const{data:w,start:m}=this.writer.stopTrackingWrites();this.format._options.onMoov(w,m)}}const n=this.trackDatas.filter(g=>g.currentChunk),i=mi(r,n),s=this.writer.getPos(),a=s+this.boxWriter.measureBox(i);let o=a+Ne,c=1/0;for(const g of n){g.currentChunk.offset=o,g.currentChunk.moofOffset=s;for(const w of g.currentChunk.samples)o+=w.size;c=Math.min(c,g.currentChunk.startTimestamp)}const l=o-a,u=l>=2**32;if(u)for(const g of n)g.currentChunk.offset+=ut-Ne;this.format._options.onMoof&&this.writer.startTrackingWrites();const d=mi(r,n);if(this.boxWriter.writeBox(d),this.format._options.onMoof){const{data:g,start:w}=this.writer.stopTrackingWrites();this.format._options.onMoof(g,w,c)}h(this.writer.getPos()===a),this.format._options.onMdat&&this.writer.startTrackingWrites();const p=Tr(u);p.size=l,this.boxWriter.writeBox(p),this.writer.seek(a+(u?ut:Ne));for(const g of n)for(const w of g.currentChunk.samples)this.writer.write(w.data),w.data=null;if(this.format._options.onMdat){const{data:g,start:w}=this.writer.stopTrackingWrites();this.format._options.onMdat(g,w)}for(const g of n)g.finalizedChunks.push(g.currentChunk),this.finalizedChunks.push(g.currentChunk),g.currentChunk=null;e&&await this.writer.flush()}async registerSampleFastStartReserve(e,r){if(this.allTracksAreKnown()){if(!this.mdat){const n=nr(this),s=this.boxWriter.measureBox(n)+this.computeSampleTableSizeUpperBound()+4096;h(this.ftypSize!==null),this.writer.seek(this.ftypSize+s),this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat=Tr(!0),this.boxWriter.writeBox(this.mdat);for(const a of this.trackDatas){for(const o of a.sampleQueue)await this.addSampleToTrack(a,o);a.sampleQueue.length=0}}await this.addSampleToTrack(e,r)}else e.sampleQueue.push(r)}computeSampleTableSizeUpperBound(){h(this.fastStart==="reserve");let e=0;for(const r of this.trackDatas){const n=r.track.metadata.maximumPacketCount;h(n!==void 0),e+=(4+4)*Math.ceil(2/3*n),e+=4*n,e+=(4+4)*Math.ceil(2/3*n),e+=(4+4+4)*Math.ceil(2/3*n),e+=4*n,e+=8*n}return e}async onTrackClose(e){const r=await this.mutex.acquire();if(e.type==="subtitle"&&e.source._codec==="webvtt"){const n=this.trackDatas.find(i=>i.track===e);n&&await this.processWebVTTCues(n,1/0)}this.allTracksAreKnown()&&this.allTracksKnown.resolve(),this.isFragmented&&await this.interleaveSamples(),r()}async finalize(){const e=await this.mutex.acquire();this.allTracksKnown.resolve();for(const r of this.trackDatas)r.type==="subtitle"&&r.track.source._codec==="webvtt"&&await this.processWebVTTCues(r,1/0);if(this.isFragmented){await this.interleaveSamples(!0);for(const r of this.trackDatas)this.processTimestamps(r);await this.finalizeFragment(!1)}else for(const r of this.trackDatas)this.processTimestamps(r),await this.finalizeCurrentChunk(r);if(this.fastStart==="in-memory"){this.mdat=Tr(!1);let r;for(let i=0;i<2;i++){const s=nr(this),a=this.boxWriter.measureBox(s);r=this.boxWriter.measureBox(this.mdat);let o=this.writer.getPos()+a+r;for(const c of this.finalizedChunks){c.offset=o;for(const{data:l}of c.samples)h(l),o+=l.byteLength,r+=l.byteLength}if(o<2**32)break;r>=2**32&&(this.mdat.largeSize=!0)}this.format._options.onMoov&&this.writer.startTrackingWrites();const n=nr(this);if(this.boxWriter.writeBox(n),this.format._options.onMoov){const{data:i,start:s}=this.writer.stopTrackingWrites();this.format._options.onMoov(i,s)}this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat.size=r,this.boxWriter.writeBox(this.mdat);for(const i of this.finalizedChunks)for(const s of i.samples)h(s.data),this.writer.write(s.data),s.data=null;if(this.format._options.onMdat){const{data:i,start:s}=this.writer.stopTrackingWrites();this.format._options.onMdat(i,s)}}else if(this.isFragmented){const r=this.writer.getPos(),n=jc(this.trackDatas);this.boxWriter.writeBox(n);const i=this.writer.getPos()-r;this.writer.seek(this.writer.getPos()-4),this.boxWriter.writeU32(i)}else{h(this.mdat);const r=this.boxWriter.offsets.get(this.mdat);h(r!==void 0);const n=this.writer.getPos()-r;if(this.mdat.size=n,this.mdat.largeSize=n>=2**32,this.boxWriter.patchBox(this.mdat),this.format._options.onMdat){const{data:s,start:a}=this.writer.stopTrackingWrites();this.format._options.onMdat(s,a)}const i=nr(this);if(this.fastStart==="reserve"){h(this.ftypSize!==null),this.writer.seek(this.ftypSize),this.format._options.onMoov&&this.writer.startTrackingWrites(),this.boxWriter.writeBox(i);const s=this.boxWriter.offsets.get(this.mdat)-this.writer.getPos();this.boxWriter.writeBox(rc(s))}else this.format._options.onMoov&&this.writer.startTrackingWrites(),this.boxWriter.writeBox(i);if(this.format._options.onMoov){const{data:s,start:a}=this.writer.stopTrackingWrites();this.format._options.onMoov(s,a)}}e()}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class zs{getSupportedVideoCodecs(){return this.getSupportedCodecs().filter(e=>je.includes(e))}getSupportedAudioCodecs(){return this.getSupportedCodecs().filter(e=>Ke.includes(e))}getSupportedSubtitleCodecs(){return this.getSupportedCodecs().filter(e=>Er.includes(e))}_codecUnsupportedHint(e){return""}}class Rs extends zs{constructor(e={}){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(e.fastStart!==void 0&&![!1,"in-memory","reserve","fragmented"].includes(e.fastStart))throw new TypeError("options.fastStart, when provided, must be false, 'in-memory', 'reserve', or 'fragmented'.");if(e.minimumFragmentDuration!==void 0&&(!Number.isFinite(e.minimumFragmentDuration)||e.minimumFragmentDuration<0))throw new TypeError("options.minimumFragmentDuration, when provided, must be a non-negative number.");if(e.onFtyp!==void 0&&typeof e.onFtyp!="function")throw new TypeError("options.onFtyp, when provided, must be a function.");if(e.onMoov!==void 0&&typeof e.onMoov!="function")throw new TypeError("options.onMoov, when provided, must be a function.");if(e.onMdat!==void 0&&typeof e.onMdat!="function")throw new TypeError("options.onMdat, when provided, must be a function.");if(e.onMoof!==void 0&&typeof e.onMoof!="function")throw new TypeError("options.onMoof, when provided, must be a function.");if(e.metadataFormat!==void 0&&!["mdir","mdta","udta","auto"].includes(e.metadataFormat))throw new TypeError("options.metadataFormat, when provided, must be either 'auto', 'mdir', 'mdta', or 'udta'.");super(),this._options=e}getSupportedTrackCounts(){return{video:{min:0,max:1/0},audio:{min:0,max:1/0},subtitle:{min:0,max:1/0},total:{min:1,max:2**32-1}}}get supportsVideoRotationMetadata(){return!0}_createMuxer(e){return new dl(e,this)}}class On extends Rs{constructor(e){super(e)}get _name(){return"MP4"}get fileExtension(){return".mp4"}get mimeType(){return"video/mp4"}getSupportedCodecs(){return[...je,...ar,"pcm-s16","pcm-s16be","pcm-s24","pcm-s24be","pcm-s32","pcm-s32be","pcm-f32","pcm-f32be","pcm-f64","pcm-f64be",...Er]}_codecUnsupportedHint(e){return new Ds().getSupportedCodecs().includes(e)?" Switching to MOV will grant support for this codec.":""}}class Ds extends Rs{constructor(e){super(e)}get _name(){return"MOV"}get fileExtension(){return".mov"}get mimeType(){return"video/quicktime"}getSupportedCodecs(){return[...je,...Ke]}_codecUnsupportedHint(e){return new On().getSupportedCodecs().includes(e)?" Switching to MP4 will grant support for this codec.":""}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const hl=t=>{if(!t||typeof t!="object")throw new TypeError("Encoding config must be an object.");if(!je.includes(t.codec))throw new TypeError(`Invalid video codec '${t.codec}'. Must be one of: ${je.join(", ")}.`);if(!(t.bitrate instanceof nt)&&(!Number.isInteger(t.bitrate)||t.bitrate<=0))throw new TypeError("config.bitrate must be a positive integer or a quality.");if(t.keyFrameInterval!==void 0&&(!Number.isFinite(t.keyFrameInterval)||t.keyFrameInterval<0))throw new TypeError("config.keyFrameInterval, when provided, must be a non-negative number.");if(t.sizeChangeBehavior!==void 0&&!["deny","passThrough","fill","contain","cover"].includes(t.sizeChangeBehavior))throw new TypeError("config.sizeChangeBehavior, when provided, must be 'deny', 'passThrough', 'fill', 'contain' or 'cover'.");if(t.onEncodedPacket!==void 0&&typeof t.onEncodedPacket!="function")throw new TypeError("config.onEncodedChunk, when provided, must be a function.");if(t.onEncoderConfig!==void 0&&typeof t.onEncoderConfig!="function")throw new TypeError("config.onEncoderConfig, when provided, must be a function.");Ms(t.codec,t)},Ms=(t,e)=>{if(!e||typeof e!="object")throw new TypeError("Encoding options must be an object.");if(e.alpha!==void 0&&!["discard","keep"].includes(e.alpha))throw new TypeError("options.alpha, when provided, must be 'discard' or 'keep'.");if(e.bitrateMode!==void 0&&!["constant","variable"].includes(e.bitrateMode))throw new TypeError("bitrateMode, when provided, must be 'constant' or 'variable'.");if(e.latencyMode!==void 0&&!["quality","realtime"].includes(e.latencyMode))throw new TypeError("latencyMode, when provided, must be 'quality' or 'realtime'.");if(e.fullCodecString!==void 0&&typeof e.fullCodecString!="string")throw new TypeError("fullCodecString, when provided, must be a string.");if(e.fullCodecString!==void 0&&Hi(e.fullCodecString)!==t)throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${t}).`);if(e.hardwareAcceleration!==void 0&&!["no-preference","prefer-hardware","prefer-software"].includes(e.hardwareAcceleration))throw new TypeError("hardwareAcceleration, when provided, must be 'no-preference', 'prefer-hardware' or 'prefer-software'.");if(e.scalabilityMode!==void 0&&typeof e.scalabilityMode!="string")throw new TypeError("scalabilityMode, when provided, must be a string.");if(e.contentHint!==void 0&&typeof e.contentHint!="string")throw new TypeError("contentHint, when provided, must be a string.")},xn=t=>{const e=t.bitrate instanceof nt?t.bitrate._toVideoBitrate(t.codec,t.width,t.height):t.bitrate;return{codec:t.fullCodecString??Gs(t.codec,t.width,t.height,e),width:t.width,height:t.height,bitrate:e,bitrateMode:t.bitrateMode,alpha:t.alpha??"discard",framerate:t.framerate,latencyMode:t.latencyMode,hardwareAcceleration:t.hardwareAcceleration,scalabilityMode:t.scalabilityMode,contentHint:t.contentHint,...Zs(t.codec)}},fl=t=>{if(!t||typeof t!="object")throw new TypeError("Encoding config must be an object.");if(!Ke.includes(t.codec))throw new TypeError(`Invalid audio codec '${t.codec}'. Must be one of: ${Ke.join(", ")}.`);if(t.bitrate===void 0&&(!ye.includes(t.codec)||t.codec==="flac"))throw new TypeError("config.bitrate must be provided for compressed audio codecs.");if(t.bitrate!==void 0&&!(t.bitrate instanceof nt)&&(!Number.isInteger(t.bitrate)||t.bitrate<=0))throw new TypeError("config.bitrate, when provided, must be a positive integer or a quality.");if(t.onEncodedPacket!==void 0&&typeof t.onEncodedPacket!="function")throw new TypeError("config.onEncodedChunk, when provided, must be a function.");if(t.onEncoderConfig!==void 0&&typeof t.onEncoderConfig!="function")throw new TypeError("config.onEncoderConfig, when provided, must be a function.");Ns(t.codec,t)},Ns=(t,e)=>{if(!e||typeof e!="object")throw new TypeError("Encoding options must be an object.");if(e.bitrateMode!==void 0&&!["constant","variable"].includes(e.bitrateMode))throw new TypeError("bitrateMode, when provided, must be 'constant' or 'variable'.");if(e.fullCodecString!==void 0&&typeof e.fullCodecString!="string")throw new TypeError("fullCodecString, when provided, must be a string.");if(e.fullCodecString!==void 0&&Hi(e.fullCodecString)!==t)throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${t}).`)},Cn=t=>{const e=t.bitrate instanceof nt?t.bitrate._toAudioBitrate(t.codec):t.bitrate;return{codec:t.fullCodecString??Ys(t.codec,t.numberOfChannels,t.sampleRate),numberOfChannels:t.numberOfChannels,sampleRate:t.sampleRate,bitrate:e,bitrateMode:t.bitrateMode,...Js(t.codec)}};class nt{constructor(e){this._factor=e}_toVideoBitrate(e,r,n){const i=r*n,s={avc:1,hevc:.6,vp9:.6,av1:.4,vp8:1.2},a=1920*1080,o=3e6,c=Math.pow(i/a,.95),d=o*c*s[e]*this._factor;return Math.ceil(d/1e3)*1e3}_toAudioBitrate(e){if(ye.includes(e)||e==="flac")return;const n={aac:128e3,opus:64e3,mp3:16e4,vorbis:64e3}[e];if(!n)throw new Error(`Unhandled codec: ${e}`);let i=n*this._factor;return e==="aac"?i=[96e3,128e3,16e4,192e3].reduce((a,o)=>Math.abs(o-i)<Math.abs(a-i)?o:a):e==="opus"||e==="vorbis"?i=Math.max(6e3,i):e==="mp3"&&(i=[8e3,16e3,24e3,32e3,4e4,48e3,64e3,8e4,96e3,112e3,128e3,16e4,192e3,224e3,256e3,32e4].reduce((a,o)=>Math.abs(o-i)<Math.abs(a-i)?o:a)),Math.round(i/1e3)*1e3}}const gi=new nt(2),ml=async(t,e={})=>{const{width:r=1280,height:n=720,bitrate:i=1e6,...s}=e;if(!je.includes(t))return!1;if(!Number.isInteger(r)||r<=0)throw new TypeError("width must be a positive integer.");if(!Number.isInteger(n)||n<=0)throw new TypeError("height must be a positive integer.");if(!(i instanceof nt)&&(!Number.isInteger(i)||i<=0))throw new TypeError("bitrate must be a positive integer or a quality.");Ms(t,s);let a=null;return dn.length>0&&(a??(a=xn({codec:t,width:r,height:n,bitrate:i,framerate:void 0,...s})),dn.some(l=>l.supports(t,a)))?!0:typeof VideoEncoder>"u"||(r%2===1||n%2===1)&&(t==="avc"||t==="hevc")?!1:(a??(a=xn({codec:t,width:r,height:n,bitrate:i,framerate:void 0,...s,alpha:"discard"})),(await VideoEncoder.isConfigSupported(a)).supported===!0)},pl=async(t,e={})=>{const{numberOfChannels:r=2,sampleRate:n=48e3,bitrate:i=128e3,...s}=e;if(!Ke.includes(t))return!1;if(!Number.isInteger(r)||r<=0)throw new TypeError("numberOfChannels must be a positive integer.");if(!Number.isInteger(n)||n<=0)throw new TypeError("sampleRate must be a positive integer.");if(!(i instanceof nt)&&(!Number.isInteger(i)||i<=0))throw new TypeError("bitrate must be a positive integer.");Ns(t,s);let a=null;return hn.length>0&&(a??(a=Cn({codec:t,numberOfChannels:r,sampleRate:n,bitrate:i,...s})),hn.some(c=>c.supports(t,a)))||ye.includes(t)?!0:typeof AudioEncoder>"u"?!1:(a??(a=Cn({codec:t,numberOfChannels:r,sampleRate:n,bitrate:i,...s})),(await AudioEncoder.isConfigSupported(a)).supported===!0)},bi=async(t=Ke,e)=>{const r=await Promise.all(t.map(n=>pl(n,e)));return t.filter((n,i)=>r[i])},gl=async(t,e)=>{for(const r of t)if(await ml(r,e))return r;return null};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Vn{constructor(){this._connectedTrack=null,this._closingPromise=null,this._closed=!1,this._timestampOffset=0}_ensureValidAdd(){if(!this._connectedTrack)throw new Error("Source is not connected to an output track.");if(this._connectedTrack.output.state==="canceled")throw new Error("Output has been canceled.");if(this._connectedTrack.output.state==="finalizing"||this._connectedTrack.output.state==="finalized")throw new Error("Output has been finalized.");if(this._connectedTrack.output.state==="pending")throw new Error("Output has not started.");if(this._closed)throw new Error("Source is closed.")}async _start(){}async _flushAndClose(e){}close(){if(this._closingPromise)return;const e=this._connectedTrack;if(!e)throw new Error("Cannot call close without connecting the source to an output track.");if(e.output.state==="pending")throw new Error("Cannot call close before output has been started.");this._closingPromise=(async()=>{await this._flushAndClose(!1),this._closed=!0,!(e.output.state==="finalizing"||e.output.state==="finalized")&&e.output._muxer.onTrackClose(e)})()}async _flushOrWaitForOngoingClose(e){return this._closingPromise?this._closingPromise:this._flushAndClose(e)}}class Un extends Vn{constructor(e){if(super(),this._connectedTrack=null,!je.includes(e))throw new TypeError(`Invalid video codec '${e}'. Must be one of: ${je.join(", ")}.`);this._codec=e}}class bl extends Un{constructor(e){super(e)}add(e,r){if(!(e instanceof ie))throw new TypeError("packet must be an EncodedPacket.");if(e.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be added.");if(r!==void 0&&(!r||typeof r!="object"))throw new TypeError("meta, when provided, must be an object.");return this._ensureValidAdd(),this._connectedTrack.output._muxer.addEncodedVideoPacket(this._connectedTrack,e,r)}}class wl{constructor(e,r){this.source=e,this.encodingConfig=r,this.ensureEncoderPromise=null,this.encoderInitialized=!1,this.encoder=null,this.muxer=null,this.lastMultipleOfKeyFrameInterval=-1,this.codedWidth=null,this.codedHeight=null,this.resizeCanvas=null,this.customEncoder=null,this.customEncoderCallSerializer=new Or,this.customEncoderQueueSize=0,this.alphaEncoder=null,this.splitter=null,this.splitterCreationFailed=!1,this.alphaFrameQueue=[],this.error=null,this.errorNeedsNewStack=!0}async add(e,r,n){try{if(this.checkForEncoderError(),this.source._ensureValidAdd(),this.codedWidth!==null&&this.codedHeight!==null){if(e.codedWidth!==this.codedWidth||e.codedHeight!==this.codedHeight){const o=this.encodingConfig.sizeChangeBehavior??"deny";if(o!=="passThrough"){if(o==="deny")throw new Error(`Video sample size must remain constant. Expected ${this.codedWidth}x${this.codedHeight}, got ${e.codedWidth}x${e.codedHeight}. To allow the sample size to change over time, set \`sizeChangeBehavior\` to a value other than 'strict' in the encoding options.`);{let c=!1;this.resizeCanvas||(typeof document<"u"?(this.resizeCanvas=document.createElement("canvas"),this.resizeCanvas.width=this.codedWidth,this.resizeCanvas.height=this.codedHeight):this.resizeCanvas=new OffscreenCanvas(this.codedWidth,this.codedHeight),c=!0);const l=this.resizeCanvas.getContext("2d",{alpha:dr()});h(l),c||(dr()?(l.fillStyle="black",l.fillRect(0,0,this.codedWidth,this.codedHeight)):l.clearRect(0,0,this.codedWidth,this.codedHeight)),e.drawWithFit(l,{fit:o}),r&&e.close(),e=new Ae(this.resizeCanvas,{timestamp:e.timestamp,duration:e.duration,rotation:e.rotation}),r=!0}}}}else this.codedWidth=e.codedWidth,this.codedHeight=e.codedHeight;this.encoderInitialized||(this.ensureEncoderPromise||this.ensureEncoder(e),this.encoderInitialized||await this.ensureEncoderPromise),h(this.encoderInitialized);const i=this.encodingConfig.keyFrameInterval??5,s=Math.floor(e.timestamp/i),a={...n,keyFrame:(n==null?void 0:n.keyFrame)||i===0||s!==this.lastMultipleOfKeyFrameInterval};if(this.lastMultipleOfKeyFrameInterval=s,this.customEncoder){this.customEncoderQueueSize++;const o=e.clone(),c=this.customEncoderCallSerializer.call(()=>this.customEncoder.encode(o,a)).then(()=>this.customEncoderQueueSize--).catch(l=>this.error??(this.error=l)).finally(()=>{o.close()});this.customEncoderQueueSize>=4&&await c}else{h(this.encoder);const o=e.toVideoFrame();if(!this.alphaEncoder)this.encoder.encode(o,a),o.close();else if(!!o.format&&!o.format.includes("A")||this.splitterCreationFailed)this.alphaFrameQueue.push(null),this.encoder.encode(o,a),o.close();else{const l=o.displayWidth,u=o.displayHeight;if(!this.splitter)try{this.splitter=new kl(l,u)}catch(d){console.error("Due to an error, only color data will be encoded.",d),this.splitterCreationFailed=!0,this.alphaFrameQueue.push(null),this.encoder.encode(o,a),o.close()}if(this.splitter){const d=this.splitter.extractColor(o),p=this.splitter.extractAlpha(o);this.alphaFrameQueue.push(p),this.encoder.encode(d,a),d.close(),o.close()}}r&&e.close(),this.encoder.encodeQueueSize>=4&&await new Promise(c=>this.encoder.addEventListener("dequeue",c,{once:!0}))}await this.muxer.mutex.currentPromise}finally{r&&e.close()}}ensureEncoder(e){const r=new Error;this.ensureEncoderPromise=(async()=>{var s,a,o;const n=xn({width:e.codedWidth,height:e.codedHeight,...this.encodingConfig,framerate:(s=this.source._connectedTrack)==null?void 0:s.metadata.frameRate});(o=(a=this.encodingConfig).onEncoderConfig)==null||o.call(a,n);const i=dn.find(c=>c.supports(this.encodingConfig.codec,n));if(i)this.customEncoder=new i,this.customEncoder.codec=this.encodingConfig.codec,this.customEncoder.config=n,this.customEncoder.onPacket=(c,l)=>{var u,d;if(!(c instanceof ie))throw new TypeError("The first argument passed to onPacket must be an EncodedPacket.");if(l!==void 0&&(!l||typeof l!="object"))throw new TypeError("The second argument passed to onPacket must be an object or undefined.");(d=(u=this.encodingConfig).onEncodedPacket)==null||d.call(u,c,l),this.muxer.addEncodedVideoPacket(this.source._connectedTrack,c,l).catch(p=>{this.error??(this.error=p),this.errorNeedsNewStack=!1})},await this.customEncoder.init();else{if(typeof VideoEncoder>"u")throw new Error("VideoEncoder is not supported by this browser.");if(n.alpha="discard",this.encodingConfig.alpha==="keep"&&(n.latencyMode="quality"),(n.width%2===1||n.height%2===1)&&(this.encodingConfig.codec==="avc"||this.encodingConfig.codec==="hevc"))throw new Error(`The dimensions ${n.width}x${n.height} are not supported for codec '${this.encodingConfig.codec}'; both width and height must be even numbers. Make sure to round your dimensions to the nearest even number.`);if(!(await VideoEncoder.isConfigSupported(n)).supported)throw new Error(`This specific encoder configuration (${n.codec}, ${n.bitrate} bps, ${n.width}x${n.height}, hardware acceleration: ${n.hardwareAcceleration??"no-preference"}) is not supported by this browser. Consider using another codec or changing your video parameters.`);const u=[],d=[];let p=0,g=0;const w=(m,k,T)=>{var S,x;const b={};if(k){const _=new Uint8Array(k.byteLength);k.copyTo(_),b.alpha=_}const y=ie.fromEncodedChunk(m,b);(x=(S=this.encodingConfig).onEncodedPacket)==null||x.call(S,y,T),this.muxer.addEncodedVideoPacket(this.source._connectedTrack,y,T).catch(_=>{this.error??(this.error=_),this.errorNeedsNewStack=!1})};this.encoder=new VideoEncoder({output:(m,k)=>{if(!this.alphaEncoder){w(m,null,k);return}const T=this.alphaFrameQueue.shift();h(T!==void 0),T?(this.alphaEncoder.encode(T,{keyFrame:m.type==="key"}),g++,T.close(),u.push({chunk:m,meta:k})):g===0?w(m,null,k):(d.push(p+g),u.push({chunk:m,meta:k}))},error:m=>{m.stack=r.stack,this.error??(this.error=m)}}),this.encoder.configure(n),this.encodingConfig.alpha==="keep"&&(this.alphaEncoder=new VideoEncoder({output:(m,k)=>{g--;const T=u.shift();for(h(T!==void 0),w(T.chunk,m,T.meta),p++;d.length>0&&d[0]===p;){d.shift();const b=u.shift();h(b!==void 0),w(b.chunk,null,b.meta)}},error:m=>{m.stack=r.stack,this.error??(this.error=m)}}),this.alphaEncoder.configure(n))}h(this.source._connectedTrack),this.muxer=this.source._connectedTrack.output._muxer,this.encoderInitialized=!0})()}async flushAndClose(e){var r,n;e||this.checkForEncoderError(),this.customEncoder?(e||this.customEncoderCallSerializer.call(()=>this.customEncoder.flush()),await this.customEncoderCallSerializer.call(()=>this.customEncoder.close())):this.encoder&&(e||(await this.encoder.flush(),await((r=this.alphaEncoder)==null?void 0:r.flush())),this.encoder.state!=="closed"&&this.encoder.close(),this.alphaEncoder&&this.alphaEncoder.state!=="closed"&&this.alphaEncoder.close(),this.alphaFrameQueue.forEach(i=>i==null?void 0:i.close()),(n=this.splitter)==null||n.close()),e||this.checkForEncoderError()}getQueueSize(){var e;return this.customEncoder?this.customEncoderQueueSize:((e=this.encoder)==null?void 0:e.encodeQueueSize)??0}checkForEncoderError(){if(this.error)throw this.errorNeedsNewStack&&(this.error.stack=new Error().stack),this.error}}class kl{constructor(e,r){this.lastFrame=null,typeof OffscreenCanvas<"u"?this.canvas=new OffscreenCanvas(e,r):(this.canvas=document.createElement("canvas"),this.canvas.width=e,this.canvas.height=r);const n=this.canvas.getContext("webgl2",{alpha:!0});if(!n)throw new Error("Couldn't acquire WebGL 2 context.");this.gl=n,this.colorProgram=this.createColorProgram(),this.alphaProgram=this.createAlphaProgram(),this.vao=this.createVAO(),this.sourceTexture=this.createTexture(),this.alphaResolutionLocation=this.gl.getUniformLocation(this.alphaProgram,"u_resolution"),this.gl.useProgram(this.colorProgram),this.gl.uniform1i(this.gl.getUniformLocation(this.colorProgram,"u_sourceTexture"),0),this.gl.useProgram(this.alphaProgram),this.gl.uniform1i(this.gl.getUniformLocation(this.alphaProgram,"u_sourceTexture"),0)}createVertexShader(){return this.createShader(this.gl.VERTEX_SHADER,`#version 300 es
			in vec2 a_position;
			in vec2 a_texCoord;
			out vec2 v_texCoord;
			
			void main() {
				gl_Position = vec4(a_position, 0.0, 1.0);
				v_texCoord = a_texCoord;
			}
		`)}createColorProgram(){const e=this.createVertexShader(),r=this.createShader(this.gl.FRAGMENT_SHADER,`#version 300 es
			precision highp float;
			
			uniform sampler2D u_sourceTexture;
			in vec2 v_texCoord;
			out vec4 fragColor;
			
			void main() {
				vec4 source = texture(u_sourceTexture, v_texCoord);
				fragColor = vec4(source.rgb, 1.0);
			}
		`),n=this.gl.createProgram();return this.gl.attachShader(n,e),this.gl.attachShader(n,r),this.gl.linkProgram(n),n}createAlphaProgram(){const e=this.createVertexShader(),r=this.createShader(this.gl.FRAGMENT_SHADER,`#version 300 es
			precision highp float;
			
			uniform sampler2D u_sourceTexture;
			uniform vec2 u_resolution; // The width and height of the canvas
			in vec2 v_texCoord;
			out vec4 fragColor;

			// This function determines the value for a single byte in the YUV stream
			float getByteValue(float byteOffset) {
				float width = u_resolution.x;
				float height = u_resolution.y;

				float yPlaneSize = width * height;

				if (byteOffset < yPlaneSize) {
					// This byte is in the luma plane. Find the corresponding pixel coordinates to sample from
					float y = floor(byteOffset / width);
					float x = mod(byteOffset, width);
					
					// Add 0.5 to sample the center of the texel
					vec2 sampleCoord = (vec2(x, y) + 0.5) / u_resolution;
					
					// The luma value is the alpha from the source texture
					return texture(u_sourceTexture, sampleCoord).a;
				} else {
					// Write a fixed value for chroma and beyond
					return 128.0 / 255.0;
				}
			}
			
			void main() {
				// Each fragment writes 4 bytes (R, G, B, A)
				float pixelIndex = floor(gl_FragCoord.y) * u_resolution.x + floor(gl_FragCoord.x);
				float baseByteOffset = pixelIndex * 4.0;

				vec4 result;
				for (int i = 0; i < 4; i++) {
					float currentByteOffset = baseByteOffset + float(i);
					result[i] = getByteValue(currentByteOffset);
				}
				
				fragColor = result;
			}
		`),n=this.gl.createProgram();return this.gl.attachShader(n,e),this.gl.attachShader(n,r),this.gl.linkProgram(n),n}createShader(e,r){const n=this.gl.createShader(e);return this.gl.shaderSource(n,r),this.gl.compileShader(n),this.gl.getShaderParameter(n,this.gl.COMPILE_STATUS)||console.error("Shader compile error:",this.gl.getShaderInfoLog(n)),n}createVAO(){const e=this.gl.createVertexArray();this.gl.bindVertexArray(e);const r=new Float32Array([-1,-1,0,1,1,-1,1,1,-1,1,0,0,1,1,1,0]),n=this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER,n),this.gl.bufferData(this.gl.ARRAY_BUFFER,r,this.gl.STATIC_DRAW);const i=this.gl.getAttribLocation(this.colorProgram,"a_position"),s=this.gl.getAttribLocation(this.colorProgram,"a_texCoord");return this.gl.enableVertexAttribArray(i),this.gl.vertexAttribPointer(i,2,this.gl.FLOAT,!1,16,0),this.gl.enableVertexAttribArray(s),this.gl.vertexAttribPointer(s,2,this.gl.FLOAT,!1,16,8),e}createTexture(){const e=this.gl.createTexture();return this.gl.bindTexture(this.gl.TEXTURE_2D,e),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR),e}updateTexture(e){this.lastFrame!==e&&((e.displayWidth!==this.canvas.width||e.displayHeight!==this.canvas.height)&&(this.canvas.width=e.displayWidth,this.canvas.height=e.displayHeight),this.gl.activeTexture(this.gl.TEXTURE0),this.gl.bindTexture(this.gl.TEXTURE_2D,this.sourceTexture),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,e),this.lastFrame=e)}extractColor(e){return this.updateTexture(e),this.gl.useProgram(this.colorProgram),this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.gl.bindVertexArray(this.vao),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),new VideoFrame(this.canvas,{timestamp:e.timestamp,duration:e.duration??void 0,alpha:"discard"})}extractAlpha(e){this.updateTexture(e),this.gl.useProgram(this.alphaProgram),this.gl.uniform2f(this.alphaResolutionLocation,this.canvas.width,this.canvas.height),this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.gl.bindVertexArray(this.vao),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4);const{width:r,height:n}=this.canvas,i=Math.ceil(r/2)*Math.ceil(n/2),s=r*n+i*2,a=Math.ceil(s/(r*4));let o=new Uint8Array(4*r*a);this.gl.readPixels(0,0,r,a,this.gl.RGBA,this.gl.UNSIGNED_BYTE,o),o=o.subarray(0,s),h(o[r*n]===128),h(o[o.length-1]===128);const c={format:"I420",codedWidth:r,codedHeight:n,timestamp:e.timestamp,duration:e.duration??void 0,transfer:[o.buffer]};return new VideoFrame(o,c)}close(){var e;(e=this.gl.getExtension("WEBGL_lose_context"))==null||e.loseContext(),this.gl=null}}class wi extends Un{constructor(e){hl(e),super(e.codec),this._encoder=new wl(this,e)}add(e,r){if(!(e instanceof Ae))throw new TypeError("videoSample must be a VideoSample.");return this._encoder.add(e,!1,r)}_flushAndClose(e){return this._encoder.flushAndClose(e)}}class Wn extends Vn{constructor(e){if(super(),this._connectedTrack=null,!Ke.includes(e))throw new TypeError(`Invalid audio codec '${e}'. Must be one of: ${Ke.join(", ")}.`);this._codec=e}}class Tl extends Wn{constructor(e){super(e)}add(e,r){if(!(e instanceof ie))throw new TypeError("packet must be an EncodedPacket.");if(e.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be added.");if(r!==void 0&&(!r||typeof r!="object"))throw new TypeError("meta, when provided, must be an object.");return this._ensureValidAdd(),this._connectedTrack.output._muxer.addEncodedAudioPacket(this._connectedTrack,e,r)}}class yl{constructor(e,r){this.source=e,this.encodingConfig=r,this.ensureEncoderPromise=null,this.encoderInitialized=!1,this.encoder=null,this.muxer=null,this.lastNumberOfChannels=null,this.lastSampleRate=null,this.isPcmEncoder=!1,this.outputSampleSize=null,this.writeOutputValue=null,this.customEncoder=null,this.customEncoderCallSerializer=new Or,this.customEncoderQueueSize=0,this.error=null,this.errorNeedsNewStack=!0}async add(e,r){try{if(this.checkForEncoderError(),this.source._ensureValidAdd(),this.lastNumberOfChannels!==null&&this.lastSampleRate!==null){if(e.numberOfChannels!==this.lastNumberOfChannels||e.sampleRate!==this.lastSampleRate)throw new Error(`Audio parameters must remain constant. Expected ${this.lastNumberOfChannels} channels at ${this.lastSampleRate} Hz, got ${e.numberOfChannels} channels at ${e.sampleRate} Hz.`)}else this.lastNumberOfChannels=e.numberOfChannels,this.lastSampleRate=e.sampleRate;if(this.encoderInitialized||(this.ensureEncoderPromise||this.ensureEncoder(e),this.encoderInitialized||await this.ensureEncoderPromise),h(this.encoderInitialized),this.customEncoder){this.customEncoderQueueSize++;const n=e.clone(),i=this.customEncoderCallSerializer.call(()=>this.customEncoder.encode(n)).then(()=>this.customEncoderQueueSize--).catch(s=>this.error??(this.error=s)).finally(()=>{n.close()});this.customEncoderQueueSize>=4&&await i,await this.muxer.mutex.currentPromise}else if(this.isPcmEncoder)await this.doPcmEncoding(e,r);else{h(this.encoder);const n=e.toAudioData();this.encoder.encode(n),n.close(),r&&e.close(),this.encoder.encodeQueueSize>=4&&await new Promise(i=>this.encoder.addEventListener("dequeue",i,{once:!0})),await this.muxer.mutex.currentPromise}}finally{r&&e.close()}}async doPcmEncoding(e,r){var p,g;h(this.outputSampleSize),h(this.writeOutputValue);const{numberOfChannels:n,numberOfFrames:i,sampleRate:s,timestamp:a}=e,o=2048,c=[];for(let w=0;w<i;w+=o){const m=Math.min(o,e.numberOfFrames-w),k=m*n*this.outputSampleSize,T=new ArrayBuffer(k),b=new DataView(T);c.push({frameCount:m,view:b})}const l=e.allocationSize({planeIndex:0,format:"f32-planar"}),u=new Float32Array(l/Float32Array.BYTES_PER_ELEMENT);for(let w=0;w<n;w++){e.copyTo(u,{planeIndex:w,format:"f32-planar"});for(let m=0;m<c.length;m++){const{frameCount:k,view:T}=c[m];for(let b=0;b<k;b++)this.writeOutputValue(T,(b*n+w)*this.outputSampleSize,u[m*o+b])}}r&&e.close();const d={decoderConfig:{codec:this.encodingConfig.codec,numberOfChannels:n,sampleRate:s}};for(let w=0;w<c.length;w++){const{frameCount:m,view:k}=c[w],T=k.buffer,b=w*o,y=new ie(new Uint8Array(T),"key",a+b/s,m/s);(g=(p=this.encodingConfig).onEncodedPacket)==null||g.call(p,y,d),await this.muxer.addEncodedAudioPacket(this.source._connectedTrack,y,d)}}ensureEncoder(e){const r=new Error;this.ensureEncoderPromise=(async()=>{var o,c;const{numberOfChannels:n,sampleRate:i}=e,s=Cn({numberOfChannels:n,sampleRate:i,...this.encodingConfig});(c=(o=this.encodingConfig).onEncoderConfig)==null||c.call(o,s);const a=hn.find(l=>l.supports(this.encodingConfig.codec,s));if(a)this.customEncoder=new a,this.customEncoder.codec=this.encodingConfig.codec,this.customEncoder.config=s,this.customEncoder.onPacket=(l,u)=>{var d,p;if(!(l instanceof ie))throw new TypeError("The first argument passed to onPacket must be an EncodedPacket.");if(u!==void 0&&(!u||typeof u!="object"))throw new TypeError("The second argument passed to onPacket must be an object or undefined.");(p=(d=this.encodingConfig).onEncodedPacket)==null||p.call(d,l,u),this.muxer.addEncodedAudioPacket(this.source._connectedTrack,l,u).catch(g=>{this.error??(this.error=g),this.errorNeedsNewStack=!1})},await this.customEncoder.init();else if(ye.includes(this.encodingConfig.codec))this.initPcmEncoder();else{if(typeof AudioEncoder>"u")throw new Error("AudioEncoder is not supported by this browser.");if(!(await AudioEncoder.isConfigSupported(s)).supported)throw new Error(`This specific encoder configuration (${s.codec}, ${s.bitrate} bps, ${s.numberOfChannels} channels, ${s.sampleRate} Hz) is not supported by this browser. Consider using another codec or changing your audio parameters.`);this.encoder=new AudioEncoder({output:(u,d)=>{var g,w;const p=ie.fromEncodedChunk(u);(w=(g=this.encodingConfig).onEncodedPacket)==null||w.call(g,p,d),this.muxer.addEncodedAudioPacket(this.source._connectedTrack,p,d).catch(m=>{this.error??(this.error=m),this.errorNeedsNewStack=!1})},error:u=>{u.stack=r.stack,this.error??(this.error=u)}}),this.encoder.configure(s)}h(this.source._connectedTrack),this.muxer=this.source._connectedTrack.output._muxer,this.encoderInitialized=!0})()}initPcmEncoder(){this.isPcmEncoder=!0;const e=this.encodingConfig.codec,{dataType:r,sampleSize:n,littleEndian:i}=kt(e);switch(this.outputSampleSize=n,n){case 1:r==="unsigned"?this.writeOutputValue=(s,a,o)=>s.setUint8(a,pe((o+1)*127.5,0,255)):r==="signed"?this.writeOutputValue=(s,a,o)=>{s.setInt8(a,pe(Math.round(o*128),-128,127))}:r==="ulaw"?this.writeOutputValue=(s,a,o)=>{const c=pe(Math.floor(o*32767),-32768,32767);s.setUint8(a,xa(c))}:r==="alaw"?this.writeOutputValue=(s,a,o)=>{const c=pe(Math.floor(o*32767),-32768,32767);s.setUint8(a,Pa(c))}:h(!1);break;case 2:r==="unsigned"?this.writeOutputValue=(s,a,o)=>s.setUint16(a,pe((o+1)*32767.5,0,65535),i):r==="signed"?this.writeOutputValue=(s,a,o)=>s.setInt16(a,pe(Math.round(o*32767),-32768,32767),i):h(!1);break;case 3:r==="unsigned"?this.writeOutputValue=(s,a,o)=>Ri(s,a,pe((o+1)*83886075e-1,0,16777215),i):r==="signed"?this.writeOutputValue=(s,a,o)=>Hs(s,a,pe(Math.round(o*8388607),-8388608,8388607),i):h(!1);break;case 4:r==="unsigned"?this.writeOutputValue=(s,a,o)=>s.setUint32(a,pe((o+1)*21474836475e-1,0,4294967295),i):r==="signed"?this.writeOutputValue=(s,a,o)=>s.setInt32(a,pe(Math.round(o*2147483647),-2147483648,2147483647),i):r==="float"?this.writeOutputValue=(s,a,o)=>s.setFloat32(a,o,i):h(!1);break;case 8:r==="float"?this.writeOutputValue=(s,a,o)=>s.setFloat64(a,o,i):h(!1);break;default:bt(n),h(!1)}}async flushAndClose(e){e||this.checkForEncoderError(),this.customEncoder?(e||this.customEncoderCallSerializer.call(()=>this.customEncoder.flush()),await this.customEncoderCallSerializer.call(()=>this.customEncoder.close())):this.encoder&&(e||await this.encoder.flush(),this.encoder.state!=="closed"&&this.encoder.close()),e||this.checkForEncoderError()}getQueueSize(){var e;return this.customEncoder?this.customEncoderQueueSize:this.isPcmEncoder?0:((e=this.encoder)==null?void 0:e.encodeQueueSize)??0}checkForEncoderError(){if(this.error)throw this.errorNeedsNewStack&&(this.error.stack=new Error().stack),this.error}}class ki extends Wn{constructor(e){fl(e),super(e.codec),this._encoder=new yl(this,e)}add(e){if(!(e instanceof qe))throw new TypeError("audioSample must be an AudioSample.");return this._encoder.add(e,!1)}_flushAndClose(e){return this._encoder.flushAndClose(e)}}class Sl extends Vn{constructor(e){if(super(),this._connectedTrack=null,!Er.includes(e))throw new TypeError(`Invalid subtitle codec '${e}'. Must be one of: ${Er.join(", ")}.`);this._codec=e}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const xl=["video","audio","subtitle"],rn=t=>{if(!t||typeof t!="object")throw new TypeError("metadata must be an object.");if(t.languageCode!==void 0&&!ur(t.languageCode))throw new TypeError("metadata.languageCode, when provided, must be a three-letter, ISO 639-2/T language code.");if(t.name!==void 0&&typeof t.name!="string")throw new TypeError("metadata.name, when provided, must be a string.");if(t.maximumPacketCount!==void 0&&(!Number.isInteger(t.maximumPacketCount)||t.maximumPacketCount<0))throw new TypeError("metadata.maximumPacketCount, when provided, must be a non-negative integer.")};class Pn{constructor(e){if(this.state="pending",this._tracks=[],this._startPromise=null,this._cancelPromise=null,this._finalizePromise=null,this._mutex=new wt,this._metadataTags={},!e||typeof e!="object")throw new TypeError("options must be an object.");if(!(e.format instanceof zs))throw new TypeError("options.format must be an OutputFormat.");if(!(e.target instanceof Nn))throw new TypeError("options.target must be a Target.");if(e.target._output)throw new Error("Target is already used for another output.");e.target._output=this,this.format=e.format,this.target=e.target,this._writer=e.target._createWriter(),this._muxer=e.format._createMuxer(this)}addVideoTrack(e,r={}){if(!(e instanceof Un))throw new TypeError("source must be a VideoSource.");if(rn(r),r.rotation!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError(`Invalid video rotation: ${r.rotation}. Has to be 0, 90, 180 or 270.`);if(!this.format.supportsVideoRotationMetadata&&r.rotation)throw new Error(`${this.format._name} does not support video rotation metadata.`);if(r.frameRate!==void 0&&(!Number.isFinite(r.frameRate)||r.frameRate<=0))throw new TypeError(`Invalid video frame rate: ${r.frameRate}. Must be a positive number.`);this._addTrack("video",e,r)}addAudioTrack(e,r={}){if(!(e instanceof Wn))throw new TypeError("source must be an AudioSource.");rn(r),this._addTrack("audio",e,r)}addSubtitleTrack(e,r={}){if(!(e instanceof Sl))throw new TypeError("source must be a SubtitleSource.");rn(r),this._addTrack("subtitle",e,r)}setMetadataTags(e){if(cn(e),this.state!=="pending")throw new Error("Cannot set metadata tags after output has been started or canceled.");this._metadataTags=e}_addTrack(e,r,n){if(this.state!=="pending")throw new Error("Cannot add track after output has been started or canceled.");if(r._connectedTrack)throw new Error("Source is already used for a track.");const i=this.format.getSupportedTrackCounts(),s=this._tracks.reduce((l,u)=>l+(u.type===e?1:0),0),a=i[e].max;if(s===a)throw new Error(a===0?`${this.format._name} does not support ${e} tracks.`:`${this.format._name} does not support more than ${a} ${e} track${a===1?"":"s"}.`);const o=i.total.max;if(this._tracks.length===o)throw new Error(`${this.format._name} does not support more than ${o} tracks${o===1?"":"s"} in total.`);const c={id:this._tracks.length+1,output:this,type:e,source:r,metadata:n};if(c.type==="video"){const l=this.format.getSupportedVideoCodecs();if(l.length===0)throw new Error(`${this.format._name} does not support video tracks.`+this.format._codecUnsupportedHint(c.source._codec));if(!l.includes(c.source._codec))throw new Error(`Codec '${c.source._codec}' cannot be contained within ${this.format._name}. Supported video codecs are: ${l.map(u=>`'${u}'`).join(", ")}.`+this.format._codecUnsupportedHint(c.source._codec))}else if(c.type==="audio"){const l=this.format.getSupportedAudioCodecs();if(l.length===0)throw new Error(`${this.format._name} does not support audio tracks.`+this.format._codecUnsupportedHint(c.source._codec));if(!l.includes(c.source._codec))throw new Error(`Codec '${c.source._codec}' cannot be contained within ${this.format._name}. Supported audio codecs are: ${l.map(u=>`'${u}'`).join(", ")}.`+this.format._codecUnsupportedHint(c.source._codec))}else if(c.type==="subtitle"){const l=this.format.getSupportedSubtitleCodecs();if(l.length===0)throw new Error(`${this.format._name} does not support subtitle tracks.`+this.format._codecUnsupportedHint(c.source._codec));if(!l.includes(c.source._codec))throw new Error(`Codec '${c.source._codec}' cannot be contained within ${this.format._name}. Supported subtitle codecs are: ${l.map(u=>`'${u}'`).join(", ")}.`+this.format._codecUnsupportedHint(c.source._codec))}this._tracks.push(c),r._connectedTrack=c}async start(){const e=this.format.getSupportedTrackCounts();for(const n of xl){const i=this._tracks.reduce((a,o)=>a+(o.type===n?1:0),0),s=e[n].min;if(i<s)throw new Error(s===e[n].max?`${this.format._name} requires exactly ${s} ${n} track${s===1?"":"s"}.`:`${this.format._name} requires at least ${s} ${n} track${s===1?"":"s"}.`)}const r=e.total.min;if(this._tracks.length<r)throw new Error(r===e.total.max?`${this.format._name} requires exactly ${r} track${r===1?"":"s"}.`:`${this.format._name} requires at least ${r} track${r===1?"":"s"}.`);if(this.state==="canceled")throw new Error("Output has been canceled.");return this._startPromise?(console.warn("Output has already been started."),this._startPromise):this._startPromise=(async()=>{this.state="started",this._writer.start();const n=await this._mutex.acquire();await this._muxer.start();const i=this._tracks.map(s=>s.source._start());await Promise.all(i),n()})()}getMimeType(){return this._muxer.getMimeType()}async cancel(){if(this._cancelPromise)return console.warn("Output has already been canceled."),this._cancelPromise;if(this.state==="finalizing"||this.state==="finalized"){console.warn("Output has already been finalized.");return}return this._cancelPromise=(async()=>{this.state="canceled";const e=await this._mutex.acquire(),r=this._tracks.map(n=>n.source._flushOrWaitForOngoingClose(!0));await Promise.all(r),await this._writer.close(),e()})()}async finalize(){if(this.state==="pending")throw new Error("Cannot finalize before starting.");if(this.state==="canceled")throw new Error("Cannot finalize after canceling.");return this._finalizePromise?(console.warn("Output has already been finalized."),this._finalizePromise):this._finalizePromise=(async()=>{this.state="finalizing";const e=await this._mutex.acquire(),r=this._tracks.map(n=>n.source._flushOrWaitForOngoingClose(!1));await Promise.all(r),await this._muxer.finalize(),await this._writer.flush(),await this._writer.finalize(),this.state="finalized",e()})()}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Ti=t=>{if(t!==void 0&&(!t||typeof t!="object"))throw new TypeError("options.video, when provided, must be an object.");if((t==null?void 0:t.discard)!==void 0&&typeof t.discard!="boolean")throw new TypeError("options.video.discard, when provided, must be a boolean.");if((t==null?void 0:t.forceTranscode)!==void 0&&typeof t.forceTranscode!="boolean")throw new TypeError("options.video.forceTranscode, when provided, must be a boolean.");if((t==null?void 0:t.codec)!==void 0&&!je.includes(t.codec))throw new TypeError(`options.video.codec, when provided, must be one of: ${je.join(", ")}.`);if((t==null?void 0:t.bitrate)!==void 0&&!(t.bitrate instanceof nt)&&(!Number.isInteger(t.bitrate)||t.bitrate<=0))throw new TypeError("options.video.bitrate, when provided, must be a positive integer or a quality.");if((t==null?void 0:t.width)!==void 0&&(!Number.isInteger(t.width)||t.width<=0))throw new TypeError("options.video.width, when provided, must be a positive integer.");if((t==null?void 0:t.height)!==void 0&&(!Number.isInteger(t.height)||t.height<=0))throw new TypeError("options.video.height, when provided, must be a positive integer.");if((t==null?void 0:t.fit)!==void 0&&!["fill","contain","cover"].includes(t.fit))throw new TypeError("options.video.fit, when provided, must be one of 'fill', 'contain', or 'cover'.");if((t==null?void 0:t.width)!==void 0&&t.height!==void 0&&t.fit===void 0)throw new TypeError("When both options.video.width and options.video.height are provided, options.video.fit must also be provided.");if((t==null?void 0:t.rotate)!==void 0&&![0,90,180,270].includes(t.rotate))throw new TypeError("options.video.rotate, when provided, must be 0, 90, 180 or 270.");if((t==null?void 0:t.crop)!==void 0&&Fn(t.crop,"options.video."),(t==null?void 0:t.frameRate)!==void 0&&(!Number.isFinite(t.frameRate)||t.frameRate<=0))throw new TypeError("options.video.frameRate, when provided, must be a finite positive number.");if((t==null?void 0:t.alpha)!==void 0&&!["discard","keep"].includes(t.alpha))throw new TypeError("options.video.alpha, when provided, must be either 'discard' or 'keep'.")},yi=t=>{if(t!==void 0&&(!t||typeof t!="object"))throw new TypeError("options.audio, when provided, must be an object.");if((t==null?void 0:t.discard)!==void 0&&typeof t.discard!="boolean")throw new TypeError("options.audio.discard, when provided, must be a boolean.");if((t==null?void 0:t.forceTranscode)!==void 0&&typeof t.forceTranscode!="boolean")throw new TypeError("options.audio.forceTranscode, when provided, must be a boolean.");if((t==null?void 0:t.codec)!==void 0&&!Ke.includes(t.codec))throw new TypeError(`options.audio.codec, when provided, must be one of: ${Ke.join(", ")}.`);if((t==null?void 0:t.bitrate)!==void 0&&!(t.bitrate instanceof nt)&&(!Number.isInteger(t.bitrate)||t.bitrate<=0))throw new TypeError("options.audio.bitrate, when provided, must be a positive integer or a quality.");if((t==null?void 0:t.numberOfChannels)!==void 0&&(!Number.isInteger(t.numberOfChannels)||t.numberOfChannels<=0))throw new TypeError("options.audio.numberOfChannels, when provided, must be a positive integer.");if((t==null?void 0:t.sampleRate)!==void 0&&(!Number.isInteger(t.sampleRate)||t.sampleRate<=0))throw new TypeError("options.audio.sampleRate, when provided, must be a positive integer.")},nn=2,sn=48e3;class Ln{static async init(e){const r=new Ln(e);return await r._init(),r}constructor(e){var i,s,a,o,c;if(this._addedCounts={video:0,audio:0,subtitle:0},this._totalTrackCount=0,this._trackPromises=[],this._executed=!1,this._synchronizer=new Cl,this._totalDuration=null,this._maxTimestamps=new Map,this._canceled=!1,this.onProgress=void 0,this._computeProgress=!1,this._lastProgress=0,this.isValid=!1,this.utilizedTracks=[],this.discardedTracks=[],!e||typeof e!="object")throw new TypeError("options must be an object.");if(!(e.input instanceof ws))throw new TypeError("options.input must be an Input.");if(!(e.output instanceof Pn))throw new TypeError("options.output must be an Output.");if(e.output._tracks.length>0||Object.keys(e.output._metadataTags).length>0||e.output.state!=="pending")throw new TypeError("options.output must be fresh: no tracks or metadata tags added and not started.");if(typeof e.video!="function"&&Ti(e.video),typeof e.audio!="function"&&yi(e.audio),e.trim!==void 0&&(!e.trim||typeof e.trim!="object"))throw new TypeError("options.trim, when provided, must be an object.");if(((i=e.trim)==null?void 0:i.start)!==void 0&&(!Number.isFinite(e.trim.start)||e.trim.start<0))throw new TypeError("options.trim.start, when provided, must be a non-negative number.");if(((s=e.trim)==null?void 0:s.end)!==void 0&&(!Number.isFinite(e.trim.end)||e.trim.end<0))throw new TypeError("options.trim.end, when provided, must be a non-negative number.");if(((a=e.trim)==null?void 0:a.start)!==void 0&&e.trim.end!==void 0&&e.trim.start>=e.trim.end)throw new TypeError("options.trim.start must be less than options.trim.end.");if(e.tags!==void 0&&(typeof e.tags!="object"||!e.tags)&&typeof e.tags!="function")throw new TypeError("options.tags, when provided, must be an object or a function.");if(typeof e.tags=="object"&&cn(e.tags),e.showWarnings!==void 0&&typeof e.showWarnings!="boolean")throw new TypeError("options.showWarnings, when provided, must be a boolean.");this._options=e,this.input=e.input,this.output=e.output,this._startTimestamp=((o=e.trim)==null?void 0:o.start)??0,this._endTimestamp=((c=e.trim)==null?void 0:c.end)??1/0;const{promise:r,resolve:n}=ke();this._started=r,this._start=n}async _init(){const e=await this.input.getTracks(),r=this.output.format.getSupportedTrackCounts();let n=1,i=1;for(const l of e){let u;if(l.isVideoTrack()?this._options.video&&(typeof this._options.video=="function"?(u=await this._options.video(l,n),Ti(u),n++):u=this._options.video):l.isAudioTrack()?this._options.audio&&(typeof this._options.audio=="function"?(u=await this._options.audio(l,i),yi(u),i++):u=this._options.audio):h(!1),u!=null&&u.discard){this.discardedTracks.push({track:l,reason:"discarded_by_user"});continue}if(this._totalTrackCount===r.total.max){this.discardedTracks.push({track:l,reason:"max_track_count_reached"});continue}if(this._addedCounts[l.type]===r[l.type].max){this.discardedTracks.push({track:l,reason:"max_track_count_of_type_reached"});continue}l.isVideoTrack()?await this._processVideoTrack(l,u??{}):l.isAudioTrack()&&await this._processAudioTrack(l,u??{})}const s=await this.input.getMetadataTags();let a;if(this._options.tags){const l=typeof this._options.tags=="function"?await this._options.tags(s):this._options.tags;cn(l),a=l}else a=s;const o=(await this.input.getFormat()).mimeType===this.output.format.mimeType,c=s.raw===a.raw;if(s.raw&&c&&!o&&delete a.raw,this.output.setMetadataTags(a),this.isValid=this._totalTrackCount>=r.total.min&&this._addedCounts.video>=r.video.min&&this._addedCounts.audio>=r.audio.min&&this._addedCounts.subtitle>=r.subtitle.min,this._options.showWarnings??!0){const l=[],u=this.discardedTracks.filter(d=>d.reason!=="discarded_by_user");u.length>0&&l.push("Some tracks had to be discarded from the conversion:",u),this.isValid||l.push(`

`+this._getInvalidityExplanation().join("")),l.length>0&&console.warn(...l)}}_getInvalidityExplanation(){const e=[];if(this.discardedTracks.length===0)e.push("Due to missing tracks, this conversion cannot be executed.");else{const r=this.discardedTracks.every(n=>n.reason==="discarded_by_user"||n.reason==="no_encodable_target_codec");if(e.push("Due to discarded tracks, this conversion cannot be executed."),r){const n=this.discardedTracks.flatMap(i=>i.reason==="discarded_by_user"?[]:i.track.type==="video"?this.output.format.getSupportedVideoCodecs():i.track.type==="audio"?this.output.format.getSupportedAudioCodecs():this.output.format.getSupportedSubtitleCodecs());n.length===1?e.push(`
Tracks were discarded because your environment is not able to encode '${n[0]}'.`):e.push(`
Tracks were discarded because your environment is not able to encode any of the following codecs: ${n.map(i=>`'${i}'`).join(", ")}.`),n.includes("mp3")&&e.push(`
The @mediabunny/mp3-encoder extension package provides support for encoding MP3.`)}else e.push(`
Check the discardedTracks field for more info.`)}return e}async execute(){var e,r;if(!this.isValid)throw new Error(`Cannot execute this conversion because its output configuration is invalid. Make sure to always check the isValid field before executing a conversion.
`+this._getInvalidityExplanation().join(""));if(this._executed)throw new Error("Conversion cannot be executed twice.");if(this._executed=!0,this.onProgress){this._computeProgress=!0,this._totalDuration=Math.min(await this.input.computeDuration()-this._startTimestamp,this._endTimestamp-this._startTimestamp);for(const n of this.utilizedTracks)this._maxTimestamps.set(n.id,0);(e=this.onProgress)==null||e.call(this,0)}await this.output.start(),this._start();try{await Promise.all(this._trackPromises)}catch(n){throw this._canceled||this.cancel(),n}this._canceled&&await new Promise(()=>{}),await this.output.finalize(),this._computeProgress&&((r=this.onProgress)==null||r.call(this,1))}async cancel(){if(!(this.output.state==="finalizing"||this.output.state==="finalized")){if(this._canceled){console.warn("Conversion already canceled.");return}this._canceled=!0,await this.output.cancel()}}async _processVideoTrack(e,r){const n=e.codec;if(!n){this.discardedTracks.push({track:e,reason:"unknown_source_codec"});return}let i;const s=vn(e.rotation+(r.rotate??0)),a=this.output.format.supportsVideoRotationMetadata,[o,c]=s%180===0?[e.codedWidth,e.codedHeight]:[e.codedHeight,e.codedWidth],l=r.crop;l&&In(l,o,c);const[u,d]=l?[l.width,l.height]:[o,c];let p=u,g=d;const w=p/g,m=x=>Math.ceil(x/2)*2;r.width!==void 0&&r.height===void 0?(p=m(r.width),g=m(Math.round(p/w))):r.width===void 0&&r.height!==void 0?(g=m(r.height),p=m(Math.round(g*w))):r.width!==void 0&&r.height!==void 0&&(p=m(r.width),g=m(r.height));const k=await e.getFirstTimestamp(),T=!!r.forceTranscode||this._startTimestamp>0||k<0||!!r.frameRate;let b=p!==u||g!==d||s!==0&&!a||!!l;const y=r.alpha??"discard";let S=this.output.format.getSupportedVideoCodecs();if(!T&&!r.bitrate&&!b&&S.includes(n)&&(!r.codec||r.codec===n)){const x=new bl(n);i=x,this._trackPromises.push((async()=>{await this._started;const _=new hr(e),M={decoderConfig:await e.getDecoderConfig()??void 0},F=Number.isFinite(this._endTimestamp)?await _.getPacket(this._endTimestamp,{metadataOnly:!0})??void 0:void 0;for await(const z of _.packets(void 0,F,{verifyKeyPackets:!0})){if(this._synchronizer.shouldWait(e.id,z.timestamp)&&await this._synchronizer.wait(z.timestamp),this._canceled)return;y==="discard"&&(delete z.sideData.alpha,delete z.sideData.alphaByteLength),await x.add(z,M),this._reportProgress(e.id,z.timestamp+z.duration)}x.close(),this._synchronizer.closeTrack(e.id)})())}else{if(!await e.canDecode()){this.discardedTracks.push({track:e,reason:"undecodable_source_codec"});return}r.codec&&(S=S.filter(z=>z===r.codec));const _=r.bitrate??gi,P=await gl(S,{width:p,height:g,bitrate:_});if(!P){this.discardedTracks.push({track:e,reason:"no_encodable_target_codec"});return}const M={codec:P,bitrate:_,sizeChangeBehavior:r.fit??"passThrough",alpha:y,onEncodedPacket:z=>this._reportProgress(e.id,z.timestamp+z.duration)},F=new wi(M);if(i=F,!b){const z=new Pn({format:new On,target:new cl}),O=new wi(M);z.addVideoTrack(O),await z.start();const X=await new fn(e).getSample(k);if(X)try{await O.add(X),X.close(),await z.finalize()}catch(se){console.info("Error when probing encoder support. Falling back to rerender path.",se),b=!0,z.cancel()}else await z.cancel()}b?this._trackPromises.push((async()=>{await this._started;const O=new Aa(e,{width:p,height:g,fit:r.fit??"fill",rotation:s,crop:r.crop,poolSize:1,alpha:y==="keep"}).canvases(this._startTimestamp,this._endTimestamp),L=r.frameRate;let X=null,se=null,ve=null;const oe=async he=>{h(X),h(L!==void 0);const ce=Math.round((he-se)*L);for(let Ee=1;Ee<ce;Ee++){const Ce=new Ae(X,{timestamp:se+Ee/L,duration:1/L});await F.add(Ce)}};for await(const{canvas:he,timestamp:ce,duration:Ee}of O){if(this._synchronizer.shouldWait(e.id,ce)&&await this._synchronizer.wait(ce),this._canceled)return;let Ce=Math.max(ce-this._startTimestamp,0);if(ve=Ce+Ee,L!==void 0){const Oe=Math.floor(Ce*L)/L;if(X!==null)if(Oe<=se){X=he,se=Oe;continue}else await oe(Oe);Ce=Oe}const it=new Ae(he,{timestamp:Ce,duration:L!==void 0?1/L:Ee});await F.add(it),L!==void 0?(X=he,se=Ce):it.close()}X&&(h(ve!==null),h(L!==void 0),await oe(Math.floor(ve*L)/L)),F.close(),this._synchronizer.closeTrack(e.id)})()):this._trackPromises.push((async()=>{await this._started;const z=new fn(e),O=r.frameRate;let L=null,X=null,se=null;const ve=async oe=>{h(L),h(O!==void 0);const he=Math.round((oe-X)*O);for(let ce=1;ce<he;ce++)L.setTimestamp(X+ce/O),L.setDuration(1/O),await F.add(L);L.close()};for await(const oe of z.samples(this._startTimestamp,this._endTimestamp)){if(this._synchronizer.shouldWait(e.id,oe.timestamp)&&await this._synchronizer.wait(oe.timestamp),this._canceled){L==null||L.close();return}let he=Math.max(oe.timestamp-this._startTimestamp,0);if(se=he+oe.duration,O!==void 0){const ce=Math.floor(he*O)/O;if(L!==null)if(ce<=X){L.close(),L=oe,X=ce;continue}else await ve(ce);he=ce,oe.setDuration(1/O)}oe.setTimestamp(he),await F.add(oe),O!==void 0?(L=oe,X=he):oe.close()}L&&(h(se!==null),h(O!==void 0),await ve(Math.floor(se*O)/O)),F.close(),this._synchronizer.closeTrack(e.id)})())}this.output.addVideoTrack(i,{frameRate:r.frameRate,languageCode:ur(e.languageCode)?e.languageCode:void 0,name:e.name??void 0,rotation:b?0:s}),this._addedCounts.video++,this._totalTrackCount++,this.utilizedTracks.push(e)}async _processAudioTrack(e,r){const n=e.codec;if(!n){this.discardedTracks.push({track:e,reason:"unknown_source_codec"});return}let i;const s=e.numberOfChannels,a=e.sampleRate,o=await e.getFirstTimestamp();let c=r.numberOfChannels??s,l=r.sampleRate??a,u=c!==s||l!==a||this._startTimestamp>0||o<0,d=this.output.format.getSupportedAudioCodecs();if(!r.forceTranscode&&!r.bitrate&&!u&&d.includes(n)&&(!r.codec||r.codec===n)){const p=new Tl(n);i=p,this._trackPromises.push((async()=>{await this._started;const g=new hr(e),m={decoderConfig:await e.getDecoderConfig()??void 0},k=Number.isFinite(this._endTimestamp)?await g.getPacket(this._endTimestamp,{metadataOnly:!0})??void 0:void 0;for await(const T of g.packets(void 0,k)){if(this._synchronizer.shouldWait(e.id,T.timestamp)&&await this._synchronizer.wait(T.timestamp),this._canceled)return;await p.add(T,m),this._reportProgress(e.id,T.timestamp+T.duration)}p.close(),this._synchronizer.closeTrack(e.id)})())}else{if(!await e.canDecode()){this.discardedTracks.push({track:e,reason:"undecodable_source_codec"});return}let g=null;r.codec&&(d=d.filter(k=>k===r.codec));const w=r.bitrate??gi,m=await bi(d,{numberOfChannels:c,sampleRate:l,bitrate:w});if(!m.some(k=>ar.includes(k))&&d.some(k=>ar.includes(k))&&(c!==nn||l!==sn)){const T=(await bi(d,{numberOfChannels:nn,sampleRate:sn,bitrate:w})).find(b=>ar.includes(b));T&&(u=!0,g=T,c=nn,l=sn)}else g=m[0]??null;if(g===null){this.discardedTracks.push({track:e,reason:"no_encodable_target_codec"});return}if(u)i=this._resampleAudio(e,g,c,l,w);else{const k=new ki({codec:g,bitrate:w,onEncodedPacket:T=>this._reportProgress(e.id,T.timestamp+T.duration)});i=k,this._trackPromises.push((async()=>{await this._started;const T=new ii(e);for await(const b of T.samples(void 0,this._endTimestamp)){if(this._synchronizer.shouldWait(e.id,b.timestamp)&&await this._synchronizer.wait(b.timestamp),this._canceled)return;await k.add(b),b.close()}k.close(),this._synchronizer.closeTrack(e.id)})())}}this.output.addAudioTrack(i,{languageCode:ur(e.languageCode)?e.languageCode:void 0,name:e.name??void 0}),this._addedCounts.audio++,this._totalTrackCount++,this.utilizedTracks.push(e)}_resampleAudio(e,r,n,i,s){const a=new ki({codec:r,bitrate:s,onEncodedPacket:o=>this._reportProgress(e.id,o.timestamp+o.duration)});return this._trackPromises.push((async()=>{await this._started;const o=new Pl({targetNumberOfChannels:n,targetSampleRate:i,startTime:this._startTimestamp,endTime:this._endTimestamp,onSample:u=>a.add(u)}),l=new ii(e).samples(this._startTimestamp,this._endTimestamp);for await(const u of l){if(this._synchronizer.shouldWait(e.id,u.timestamp)&&await this._synchronizer.wait(u.timestamp),this._canceled)return;await o.add(u)}await o.finalize(),a.close(),this._synchronizer.closeTrack(e.id)})()),a}_reportProgress(e,r){var s;if(!this._computeProgress)return;h(this._totalDuration!==null),this._maxTimestamps.set(e,Math.max(r,this._maxTimestamps.get(e)));const n=Math.min(...this._maxTimestamps.values()),i=pe(n/this._totalDuration,0,1);i!==this._lastProgress&&(this._lastProgress=i,(s=this.onProgress)==null||s.call(this,i))}}const Si=5;class Cl{constructor(){this.maxTimestamps=new Map,this.resolvers=[]}computeMinAndMaybeResolve(){let e=1/0;for(const[,r]of this.maxTimestamps)e=Math.min(e,r);for(let r=0;r<this.resolvers.length;r++){const n=this.resolvers[r];n.timestamp-e<Si&&(n.resolve(),this.resolvers.splice(r,1),r--)}return e}shouldWait(e,r){this.maxTimestamps.set(e,Math.max(r,this.maxTimestamps.get(e)??-1/0));const n=this.computeMinAndMaybeResolve();return r-n>=Si}wait(e){const{promise:r,resolve:n}=ke();return this.resolvers.push({timestamp:e,resolve:n}),r}closeTrack(e){this.maxTimestamps.delete(e),this.computeMinAndMaybeResolve()}}class Pl{constructor(e){this.sourceSampleRate=null,this.sourceNumberOfChannels=null,this.targetSampleRate=e.targetSampleRate,this.targetNumberOfChannels=e.targetNumberOfChannels,this.startTime=e.startTime,this.endTime=e.endTime,this.onSample=e.onSample,this.bufferSizeInFrames=Math.floor(this.targetSampleRate*5),this.bufferSizeInSamples=this.bufferSizeInFrames*this.targetNumberOfChannels,this.outputBuffer=new Float32Array(this.bufferSizeInSamples),this.bufferStartFrame=0,this.maxWrittenFrame=-1}doChannelMixerSetup(){h(this.sourceNumberOfChannels!==null);const e=this.sourceNumberOfChannels,r=this.targetNumberOfChannels;e===1&&r===2?this.channelMixer=(n,i)=>n[i*e]:e===1&&r===4?this.channelMixer=(n,i,s)=>n[i*e]*+(s<2):e===1&&r===6?this.channelMixer=(n,i,s)=>n[i*e]*+(s===2):e===2&&r===1?this.channelMixer=(n,i)=>{const s=i*e;return .5*(n[s]+n[s+1])}:e===2&&r===4?this.channelMixer=(n,i,s)=>n[i*e+s]*+(s<2):e===2&&r===6?this.channelMixer=(n,i,s)=>n[i*e+s]*+(s<2):e===4&&r===1?this.channelMixer=(n,i)=>{const s=i*e;return .25*(n[s]+n[s+1]+n[s+2]+n[s+3])}:e===4&&r===2?this.channelMixer=(n,i,s)=>{const a=i*e;return .5*(n[a+s]+n[a+s+2])}:e===4&&r===6?this.channelMixer=(n,i,s)=>{const a=i*e;return s<2?n[a+s]:s===2||s===3?0:n[a+s-2]}:e===6&&r===1?this.channelMixer=(n,i)=>{const s=i*e;return Math.SQRT1_2*(n[s]+n[s+1])+n[s+2]+.5*(n[s+4]+n[s+5])}:e===6&&r===2?this.channelMixer=(n,i,s)=>{const a=i*e;return n[a+s]+Math.SQRT1_2*(n[a+2]+n[a+s+4])}:e===6&&r===4?this.channelMixer=(n,i,s)=>{const a=i*e;return s<2?n[a+s]+Math.SQRT1_2*n[a+2]:n[a+s+2]}:this.channelMixer=(n,i,s)=>s<e?n[i*e+s]:0}ensureTempBufferSize(e){let r=this.tempSourceBuffer.length;for(;r<e;)r*=2;if(r!==this.tempSourceBuffer.length){const n=new Float32Array(r);n.set(this.tempSourceBuffer),this.tempSourceBuffer=n}}async add(e){this.sourceSampleRate===null&&(this.sourceSampleRate=e.sampleRate,this.sourceNumberOfChannels=e.numberOfChannels,this.tempSourceBuffer=new Float32Array(this.sourceSampleRate*this.sourceNumberOfChannels),this.doChannelMixerSetup());const r=e.numberOfFrames*e.numberOfChannels;this.ensureTempBufferSize(r);const n=e.allocationSize({planeIndex:0,format:"f32"}),i=new Float32Array(this.tempSourceBuffer.buffer,0,n/4);e.copyTo(i,{planeIndex:0,format:"f32"});const s=e.timestamp-this.startTime,a=e.numberOfFrames/this.sourceSampleRate,o=Math.min(s+a,this.endTime-this.startTime),c=Math.floor(s*this.targetSampleRate),l=Math.ceil(o*this.targetSampleRate);for(let u=c;u<l;u++){if(u<this.bufferStartFrame)continue;for(;u>=this.bufferStartFrame+this.bufferSizeInFrames;)await this.finalizeCurrentBuffer(),this.bufferStartFrame+=this.bufferSizeInFrames;const d=u-this.bufferStartFrame;h(d<this.bufferSizeInFrames);const w=(u/this.targetSampleRate-s)*this.sourceSampleRate,m=Math.floor(w),k=Math.ceil(w),T=w-m;for(let b=0;b<this.targetNumberOfChannels;b++){let y=0,S=0;m>=0&&m<e.numberOfFrames&&(y=this.channelMixer(i,m,b)),k>=0&&k<e.numberOfFrames&&(S=this.channelMixer(i,k,b));const x=y+T*(S-y),_=d*this.targetNumberOfChannels+b;this.outputBuffer[_]+=x}this.maxWrittenFrame=Math.max(this.maxWrittenFrame,d)}}async finalizeCurrentBuffer(){if(this.maxWrittenFrame<0)return;const e=(this.maxWrittenFrame+1)*this.targetNumberOfChannels,r=new Float32Array(e);r.set(this.outputBuffer.subarray(0,e));const n=this.bufferStartFrame/this.targetSampleRate,i=new qe({format:"f32",sampleRate:this.targetSampleRate,numberOfChannels:this.targetNumberOfChannels,timestamp:n,data:r});await this.onSample(i),this.outputBuffer.fill(0),this.maxWrittenFrame=-1}finalize(){return this.finalizeCurrentBuffer()}}const _l=document.querySelector("#select-file"),vl=document.querySelector("#load-url"),El=document.querySelector("#file-name"),Il=document.querySelector("hr");document.querySelector("#progress-bar-container");const Fl=document.querySelector("#progress-bar"),xi=document.querySelector("#speedometer"),At=document.querySelector("video"),Al=document.querySelector("#compression-facts"),Ci=document.querySelector("#error-element"),Pi=document.querySelector("#error-message"),Bl=document.querySelector("#file-info-section"),zl=document.querySelector("#original-size"),Rl=document.querySelector("#file-duration"),yr=document.querySelector("#file-resolution"),Sr=document.querySelector("#progress-container"),Dl=document.querySelector("#progress-percentage"),_i=document.querySelector("#eta"),an=document.querySelector("#success-info"),Ml=document.querySelector("#original-file-size"),Nl=document.querySelector("#compressed-file-size"),Ol=document.querySelector("#space-saved"),Vl=document.querySelector("#download-btn"),Pt=document.querySelector("#drop-zone"),vi=document.querySelectorAll(".preset-btn");let _n="medium",Ge=null,xr=-1,lr=null,Bt=0;const Ul={low:{targetSize:3,videoBitrateFactor:.7,audioBitrate:32},medium:{targetSize:7.2,videoBitrateFactor:.9,audioBitrate:64},high:{targetSize:8,videoBitrateFactor:1,audioBitrate:128}},Cr=t=>{if(t===0)return"0 B";const e=1024,r=["B","KB","MB","GB"],n=Math.floor(Math.log(t)/Math.log(e));return`${parseFloat((t/Math.pow(e,n)).toFixed(1))} ${r[n]}`},Wl=t=>{const e=Math.floor(t/60),r=Math.floor(t%60);return`${e}:${r.toString().padStart(2,"0")}`};vi.forEach(t=>{t.addEventListener("click",()=>{vi.forEach(e=>e.classList.remove("active","ring-2","ring-blue-500")),t.classList.add("active","ring-2","ring-blue-500"),_n=t.dataset.preset})});var Ei;(Ei=document.querySelector('[data-preset="medium"]'))==null||Ei.classList.add("ring-2","ring-blue-500");const Hn=async t=>{clearInterval(xr),await(Ge==null?void 0:Ge.cancel()),El.textContent=t instanceof File?t.name:t,Bl.style.display="block",Il.style.display="block",Sr.style.display="none",At.style.display="none",At.src="",Ci.style.display="none",an.style.display="none",Pi.textContent="";try{const e=t instanceof File?new jo(t):new Qo(t),r=new ws({source:e,formats:$o});Bt=await e.getSize();const n=Bt/(1024*1024),i=await r.getPrimaryVideoTrack(),s=await(i==null?void 0:i.computeDuration()),a=await(i==null?void 0:i.computePacketStats());zl.textContent=` Size: ${Cr(Bt)}`,Rl.textContent=s?` Duration: ${Wl(s)}`:" Duration: -";try{yr.textContent=" Resolution: Processing...";const F=(a==null?void 0:a.width)||0,z=(a==null?void 0:a.height)||0;F&&z?yr.textContent=` Resolution: ${F}x${z}`:yr.textContent=" Resolution: Unknown"}catch{yr.textContent=" Resolution: Unknown"}const o=t instanceof File?t.name:t,c=[".mp4",".avi",".mov",".mkv",".webm",".wmv",".flv",".m4v"];if(!c.some(F=>o.toLowerCase().endsWith(F)))throw new Error(`Unsupported file format. Please use: ${c.join(", ")}`);const u=new Pn({target:new Bs,format:new On}),d=await r.computeDuration(),p=Ul[_n],w=p.targetSize*1024*1024*8*.9,m=p.audioBitrate*1e3,k=m*d,T=w-k,b=Math.max(1e5,Math.round(T/d*p.videoBitrateFactor));console.log(`Duration: ${d}s`),console.log(`Preset: ${_n}`),console.log(`Target size: ${p.targetSize.toFixed(1)}MB`),console.log(`Audio bitrate: ${p.audioBitrate}kbps`),console.log(`Video bitrate: ${(b/1e3).toFixed(0)}kbps`),Sr.style.display="block",Ge=await Ln.init({input:r,output:u,video:{width:1280,bitrate:b,frameRate:24},audio:{bitrate:m}});let y=0;const S=performance.now();Ge.onProgress=F=>{y=F};const x=()=>{const F=Math.round(y*100);Fl.style.width=`${F}%`,Dl.textContent=`${F}%`;const O=(performance.now()-S)/1e3;if(y>0){const L=d/(O/y);xi.textContent=`Speed: ~${L.toPrecision(3)}x realtime`;const X=O/y*(1-y);_i.textContent=`ETA: ${Math.max(0,Math.round(X))}s`}else xi.textContent="Speed: -",_i.textContent="ETA: -"};xr=window.setInterval(x,1e3/30),await Ge.execute(),clearInterval(xr),x(),lr=new Blob([u.target.buffer],{type:u.format.mimeType}),Sr.style.display="none",At.style.display="block",At.src=URL.createObjectURL(lr),an.style.display="block";const _=lr.size,P=_/Bt*100,M=Bt-_;Ml.textContent=Cr(Bt),Nl.textContent=Cr(_),Al.textContent=`${P.toFixed(1)}% of original size`,Ol.textContent=Cr(M),At.play()}catch(e){console.error(e),await(Ge==null?void 0:Ge.cancel()),clearInterval(xr),Pi.textContent=String(e),Ci.style.display="block",Sr.style.display="none",an.style.display="none",At.style.display="none"}};Vl.addEventListener("click",()=>{if(!lr)return;const t=URL.createObjectURL(lr),e=document.createElement("a");e.href=t,e.download=`compressed_video_${Date.now()}.mp4`,document.body.appendChild(e),e.click(),document.body.removeChild(e),URL.revokeObjectURL(t)});let Dr=0;Pt.addEventListener("dragenter",t=>{t.preventDefault(),Dr++,Pt.classList.add("border-blue-500","bg-blue-50","dark:bg-blue-900/20")});Pt.addEventListener("dragleave",t=>{t.preventDefault(),Dr--,Dr===0&&Pt.classList.remove("border-blue-500","bg-blue-50","dark:bg-blue-900/20")});Pt.addEventListener("dragover",t=>{t.preventDefault(),t.dataTransfer.dropEffect="copy"});Pt.addEventListener("drop",t=>{var n;t.preventDefault(),Dr=0,Pt.classList.remove("border-blue-500","bg-blue-50","dark:bg-blue-900/20");const e=(n=t.dataTransfer)==null?void 0:n.files,r=e&&e.length>0?e[0]:void 0;r&&Hn(r)});_l.addEventListener("click",()=>{const t=document.createElement("input");t.type="file",t.accept="video/*,video/x-matroska,audio/*,audio/aac",t.addEventListener("change",()=>{var r;const e=(r=t.files)==null?void 0:r[0];e&&Hn(e)}),t.click()});vl.addEventListener("click",()=>{const t=prompt("Please enter a URL of a media file. Note that it must be HTTPS and support cross-origin requests, so have the right CORS headers set.","https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4");t&&Hn(t)});
